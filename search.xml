<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指Offer（二）]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面试题目录 找出数组中重复的数字 不修改数组找出重复的数字 摄影：Roberto Nickson，来自Unsplash 找出数组中重复的数字(P39)题目 在一个长度为 n 的数组里的所有数字都在 0~n-1 的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次，请找出数组中任意一个重复的数字。例如，如果输入长度为7，的数组 {2, 3, 1, 0, 2, 5, 3} ，那么对应的输出是重复的数字2和或者3。 解题思路 从头到位依次扫描这个数字中的每个数字，当扫描到下标为 i 的数字时，首先比较这个数字（用 m 表示）是不是等于 i，如果是，则接着扫描下一个数字；如果不是，则再拿它和第 m 个数字进行比较。如果它和第 m 个数字相等，就找到了一个重复的数字（该数字在下标为 i 和 m 的位置都出现了）；如果它和第 m 个数字不相等，就把第 i 个数字和第 m 个数字交换，把 m 个数字交换，把 m 放到属于它的位置。接下来，再重复比较、交换的过程，知道发现一个重复的数字。 代码 public class Test3_1 { private static boolean duplicate(int[] arr) { if (arr.length &lt;= 0) { return false; } for (int i1 : arr) { if (i1 &lt; 0 || i1 &gt; arr.length - 1) { return false; } } for (int i = 0; i &lt; arr.length; i++) { while (arr[i] != i) { if (arr[i] == arr[arr[i]]) { return true; } int temp = arr[i]; arr[i] = arr[temp]; arr[temp] = temp; } } return false; } public static void main(String[] args) { int[] arr = new int[]{2, 3, 1, 0, 2, 5, 3}; System.out.println(duplicate(arr)); } } 不修改数组找出重复的数字题目 在一个长度为 n+1 的数组里的所有数字都在 1~n 的范围内，所以数组中至少有一个数字是重复的，请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为 8 的数组 {2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3 解题思路 把从 1~n 的数字从中间的数字m分为两部分，前面一半为 1~m，后面一半为 m+1~n。如果 1~m 的数字的数目超过 m，那么这一班的区间里一定包含重复的数字；否则，另一半 m+1~n 的区间里一定包含重复的数字。 代码 public class Test3_2 { private static int getDuplication(int[] arr) { if (arr.length &lt;= 0) { return -1; } int start = 1; int end = arr.length - 1; while (end &gt;= start) { int middle = ((end - start) &gt;&gt; 1) + start; int count = countRange(arr, start, middle); if (end == start) { if (count &gt; 1) { return start; } else { break; } } if (count &gt; (middle - start + 1)) { end = middle; } else { start = middle + 1; } } return -1; } private static int countRange(int[] arr, int start, int end) { if (arr == null) { return 0; } int count = 0; for (int i : arr) { if (i &gt;= start &amp;&amp; i &lt;= end) { count++; } } return count; } public static void main(String[] args) { int[] arr = new int[] {2, 3, 5, 4, 3, 2, 6, 7}; System.out.println(getDuplication(arr)); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer（一）]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[知识点目录 赋值运算符 C++ 中的 struct 和 class 的区别 摄影：Ernest Ojeh，来自Unsplash 赋值运算符(P25)有以下类型CMyString的声明，添加赋值运算符函数 class CMyString { public: CMyString(char* pData = nullptr); CMyString(const CMyString&amp; str); ~CMyString(void); private: char* m_pData; } 考点 是否发返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用（*this) 是否把传入的参数声明为常量引用 是否释放实例自身已有的内存 判断传入的参数和当前的实例（*this）是不是同一个实例 经典解法 - 初级程序员 CMyString&amp; CMyString::operator = (const CMyString &amp;str) { if (this == &amp;str) { return *this; } delete []m_pData; m_pData = nullptr; m_pData = new char[strlen(str.m_pData) + 1]; strcpy(m_pData, str.m_pData); return *this; } 考虑异常安全性的解法 - 高级程序员 CMyString&amp; CMyString::operator = (const CMyString &amp;str) { if (this != &amp;str) { CMyString strTemp(str); // 创建一个临时实例 /** * 以下三行是将临时实例与自身实例进行交换 */ char* pTemp = strTemp.m_pData; strTemp.m_pData = m_pData; m_pData = pTemp; } // 到该作用域外后，临时实例将会调用析构函数，销毁内存 // 因为临时实例交换后就是之前的实例自身，析构后便可以达到销毁原实例内存的目的 return *this; } 源码地址 C++ 中的 struct 和 class 的区别 如果没有标明成员函数或者变量的访问权限级别，在 struct 中默认的是 public，而在class中默认的是private struct 定义的是值类型，值类型的实例在栈上分配内存；而 class 定义的是引用类型，引用类型的实例在堆上分配内存]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程知识点（第三篇）]]></title>
    <url>%2F2019%2F03%2F06%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[知识点目录 什么是并发容器的实现？ 多线程同步和互斥实现方法 什么是竞争条件 为什么调用 start() 方法时会执行 run() 方法，为什么不直接调用 run() 方法 Java 中怎样唤醒一个阻塞地线程 CycliBarriar 和 CountdownLatch 有什么区别？ 什么是不可变对象，它对写并发应用有什么帮助？ 图片来自第三方 Unsplash 什么是并发容器的实现？何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如 Vector、Hashtable、Collections.synchronizedSet、synchronizedList 等方法返回的容器。 可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字synchronized。 并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。 多线程同步和互斥实现方法线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。 线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。 线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。 用户模式下的方法有：原子操作、临界区。内核模式下的方法有：事件、信号量、互斥量。 什么是竞争条件当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件。 为什么调用 start() 方法时会执行 run() 方法，为什么不直接调用 run() 方法当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。 但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。 Java 中怎样唤醒一个阻塞地线程在 Java 发展史上曾经使用 suspend()、resume() 方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。 解决方案可以使用以对象为目标的阻塞，即利用 Object 类的 wait() 和 notify() 方法实现线程阻塞。 首先，wait、notify 方法是针对对象的，调用任意对象的 wait() 方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify() 方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行；其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。 CycliBarriar 和 CountdownLatch 有什么区别？CyclicBarrier 可以重复使用，而CountdownLatch不能重复使用。 Java 的 concurrent 包里面的 CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。 你可以向 CountDownLatch 对象设置一个初始的数字作为计数值，任何调用这个对象上的 await() 方法都会阻塞，直到这个计数器的计数值被其他的线程减为0为止。 所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。 CountDownLatch 的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个 CountDownLatch 对象的 await ()方法，其他的任务执行完自己的任务后调用同一个 CountDownLatch 对象上的 countDown() 方法，这个调用 await() 方法的任务将一直阻塞等待，直到这个 CountDownLatch 对象的计数值减到0为止 CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 什么是不可变对象，它对写并发应用有什么帮助？不可变对象即对象一旦被创建它的状态就不能改变，反之即为可变对象。 不可变对象的类即为不可变类。Java 平台类库中包含许多不可变类，如 String、基本类型的包装类、BigInteger 和 BigDecimal 等。 不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。 不可变对象永远是线程安全的。 只有满足如下状态，一个对象才是不可变的； 它的状态不能在创建后再被修改； 所有域都是 final 类型；并且， 它被正确创建（创建期间没有发生this引用的逸出）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程知识点（第二篇）]]></title>
    <url>%2F2019%2F03%2F04%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[知识点目录 在 Java 中 Executor 和 Executors 的区别 原子操作 Java Concurrency API 中的 Lock 接口是什么？对比同步有什么优势？ Executors 框架 什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者 - 消费者模型？ 什么是 Callable 和 Future ？ 什么是 FutureTask ？ 图片来自第三方 Unsplash 在 Java 中 Executor 和 Executors 的区别 Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求 Executor 接口对象能执行我们的线程任务 ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法，能获得任务的执行状态并且可以获取任务的返回值 使用 ThreadPoolExecutor 可以穿件自定义线程池 Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果 原子操作原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。 处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作 在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。CAS 操作 —— Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的CPU指令都支持 CAS 的原子操作 int++ 并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误 为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5之后，java.util.concurrent.automic 包提供了int和long类型的原子包装类，它们可以自动的保证对于它们的操作是原子的并且不需要使用同步 java.util.concurrent 这个包里面提供了一组原子类。其基本方法的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令的时候，不会被其他线程打断，而别的线程就像自旋锁一样，一致等到该方法执行完成，才由 JVM 从等待队列中选择一个线程进入。 Java Concurrency API 中的 Lock 接口是什么？对比同步有什么优势？Lock 接口比同步方法和同步块提供了更具扩展性的锁操作 他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关的条件对象 优势有： 可以使锁更公平 可以使线程在等待锁的时候响应中断 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 可以在不同的范围，以不同的顺序获取和释放锁 整体上来说，Lock 是 synchronize 的扩展版，Lock提供了无条件的，可轮询的，定时的，可中断的，可多条件队列的锁操作。另外 Lock 的实现类都基本支持非公平锁和公平锁，synchronize 只支持非公平锁，但大部分情况下，非公平锁是高效的选择 Executors 框架Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架 无限制的创建线程或引起应用程序内存溢出。所以创建一个线程池是个更好的解决方案，因为可以限制线程的数量，并且可以回收再利用这些线程。利用 Executors 开那个价可以非常方便的创建一个线程池 什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者 - 消费者模型？阻塞队列是一个支持两个附加操作的队列。在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。 阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿出元素 JDK7 提供了7个阻塞队列： ArrayBlockingQueue：一个由数组结构组成的游街阻塞队列 LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列 PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列 DelayQueue：一个使用优先级队列实现的无界阻塞队列 SynchronousQueue：一个不存储元素的阻塞队列 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列 Java5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要技术就是用 wait，notify，notifyAll，synchronized 这些关键字。在 Java5 之后，可以使用阻塞队列来实现，此方式大大减少了代码量，是的多线程编程更加容易，安全方面也有保障。 BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的工具，因此他具有一个很明显的特征，当生产者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为他所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，他可以很好的控制线程之间的通信 阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程，不断从队列取数据解析 什么是 Callable 和 Future ？Callable 接口类似于 Runnable，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说 Future 可以拿到异步执行任务的返回值 可以认为是带有回调的 Runnable Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以所 Callable 用于产生结果，Future 用于获取结果 什么是 FutureTask ？在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。他有启动和取消运算、查询运算是否完成和取回运算结果等方法 只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnabel 接口，所以它可以提交给 Executor 来执行]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程知识点（第一篇）]]></title>
    <url>%2F2019%2F03%2F03%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[知识点目录 在java中守护线程和本地线程的区别 线程与进程的区别 多线程的上下文切换 死锁与活锁的区别，死锁与饥饿的区别 Java中用到的线程调度算法 什么是线程组，为什么在Java中不推荐使用 为什么使用Executor框架 图片来自第三方 Unsplash 在java中守护线程和本地线程的区别java中的线程分为两种：守护线程（Daemon）和用户线程（User） 任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(boolean)；true则把该线程设置为守护线程，反之则为用户抛出异常。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常 两者的区别：虚拟机（JVM）何时离开，Daemon是为其他线程提供服务，如果全部的UserThread已经撤离，Daemon没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程，守护线程就没有工作继续执行，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开 扩展：Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows下的监听Ctrl+break的守护进程、Finalizer守护进程、引用处理守护进程、GC守护进程 线程与进程的区别进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。一个程序至少有一个进程，一个进程至少有一个线程 多线程的上下文切换多线程会共同使用一组计算机的CPU，二线程数大于给程序分配的CPU数是，为了让各个线程都有执行的机会，就需要轮转使用CPU。不同的线程切换使用CPU发生的切换数据等就是上下文切换 死锁与活锁的区别，死锁与饥饿的区别死锁：是指两个或两个以上的进程（或线程）在指定过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去 产生死锁的必要条件： 互斥条件：所谓互斥就是进程在某一时间内独占资源 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：进程已获得资源，在未使用完之前不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系 活锁：任务或执行者没有阻塞，由于某些条件没有满足，导致一直重复尝试、失败、尝试、失败 活锁和死锁的区别：处于活锁的实体是在不断的改变状态，所谓的“活”，而处于是死锁的实体表现为等待，活锁可能自己解开，死锁不能 饥饿：一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态 Java中导致饥饿的原因： 高优先级线程吞噬所有低优先级线程的资源 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在他之前持续对该同步块进行访问 线程在等待一个本身也处于永久等待完成的对象（比如调用这个对象的wait方法），因为其他线程总是被持续地获得唤醒 Java中用到的线程调度算法采用时间片轮转的方式，可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿 什么是线程组，为什么在Java中不推荐使用ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构类似于树，有安全隐患，推荐使用线程池 为什么使用Executor框架每次执行任务创建线程 new Thread() 比较消耗性能，创建一个线程是比较耗时的、耗资源的 调用 new Thread() 创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的互相竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源 直接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白蛇缘起影评]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%99%BD%E8%9B%87%E7%BC%98%E8%B5%B7%E5%BD%B1%E8%AF%84%2F</url>
    <content type="text"><![CDATA[这篇影评是我再三斟酌后决定发出来，只是为了表达我对于这部国漫单纯的喜爱，它并没有那么不堪（本文没有大篇幅去评价剧情，画面，台词等等，只是想表达一名该电影粉丝的想法） 先来说说看我这篇文章的三种人群，一类是《白蛇：缘起》这部动漫的粉丝，一类是《白蛇：缘起》的喷子，一类是持有保留意见的路人，我并不会去针对某一类人群说一些有失偏颇的话，这样做既没有意义，也违背了我这篇文章的初衷，但我之所以分开这三类人群，旨在希望各位能认真看完文章，它适合所有人 在农历新年之前，有两部电影都被我自己誉为我自己的打脸真香电影，一部是《海王》，另一部就是本文主题《白蛇：缘起》，在电影上映前，我都没抱着多大的期望值，但是观影后心中默认两字“牛逼”，对于看过不少科幻电影的我来说，《海王》是完全超乎我预料之外的好，很大程度归功于它的导演——温子仁，好了，回到我们的话题，相对于动漫，我看的就比较少了，日本动漫就看过《火影忍者》和《名侦探柯南》后者甚至只看过剧场版，而国漫相对多一些，比如《秦时明月》，画江湖系列的《侠岚》《风语咒》《灵主》《不良人》《换世门生》，还有《镇魂街》，有些估计也看过，想不起来了，虽然看过国漫，也挺喜欢，但一直处于喜欢的程度，并没有到达热爱，甚至成为自来水向身边的人疯狂安利，我看了四次《缘起》，每次看我都想不明白为什么我还愿意走进电影院再次观看，一点不觉得腻歪，知道最近我才觉得我找到了答案 在说答案之前，我想说说能让我四次走进电影院的一些原因，对于一场电影，看一遍基本就满足了，二刷就已经是热爱了，刷以上难免会觉得有点过分，甚至会让别人觉得看这么多次难道不觉的腻？我不是一个专业的影评人，没有丰富的词汇去描绘评论整个电影的剧情，但是作为一名观影者，我觉得我还是可以说一说自己的感受。《缘起》全程剧情十分紧凑，对于我来说，一个电影个情节衔接得好不好，可以用在你看电影时，有没有产生右划快进的欲望来恒定，这部电影完全没有，恐怕也正因为这个原因，在几次观影下来我发现了电影中很多地方剧情节奏太快不太符合逻辑。可是，整部电影的逻辑没有问题，四次《何须问》都让我身临其境，四次小白拉许宣魂魄都能触动到我，同样的剧情，能触动我四次的恐怕目前就只有《缘起》了。 但是仅仅只剧情触动的话，那我为我四刷的行为感到不值和奇怪了，接下来，我要说的仅仅代表我个人的观点：在我看来，无论是电影，电视剧，书，或者以任何媒介传播到我大脑里的信息都是可以分类的，但所有类别中有一类，是我认为最最重要的，很多人称之为情怀，我也认，但往往就是情怀能触碰到我内心深处最纯洁，单纯的向往，有同学跟我说过，现在社会变化太快了，有些东西已将变得不一样了，要试图适应，去改变自己。这句话没错，可是，任然有些东西在我心中，我愿意为它留下一方净土，希望在这净土上，能结出我期望的果实，在我没有找到合适的种子，我愿意继续守护它，我有过动摇，有过反思，我不能说这电影带给我什么珍贵的东西，可是剧情中许宣和小白的那种奋不顾身的爱情，的的确确触碰了我心中的这方净土，触及到了我自己对爱情的向往，就算这种爱情不存在，我也愿意相信它。可能会有人说我幼稚，什么都没经历，谈何如此这般，那我反问一句，你何尝没有为自己心中放弃的那一方净土感到后悔，惋惜，悲哀吗？人之初，我们本有着一片纯净的天地，逐渐成长，我们总是在用“无奈”来掩盖自己的妥协，用“放弃”掩盖自己的无能，用“现实”掩盖自己的退缩，这一片天地最终就留下了那一方可怜的土地，能不令人痛心。如果连最后这一点可怜的净土都没了，那我们还能找到自己最初所盼望的东西吗？我不想把“情怀”二字说的如何高大上，但至少，这玩意儿，能在你失落的时候给你一丝安慰，哪怕只有一丝光亮，你也会奋不顾身的往前跑，它不会为你指明任何方向，但是，至少在你行走的过程中，让你保持幸福感。 以上仅仅是我个人的观点，也是自己想了很久总结的话，所以在文章开头说了再三斟酌，并没想针对任何人，我仅仅想表达我为何爱这部电影之深，我也没有要故意抬杠捧高《缘起》的价值观，因为最终它只是一部电影，只是一个商业产物，一千个读者就有一千个哈姆雷特，我仅仅只是那千分之一，所以我尊重任何人的意见，就算是故意甚至恶意诋毁的人，我也愿意接纳，至少你们也是那“一千”中的一个。 全篇文章不长，恐怕还有些许矫情，看电影是我这个程序员业余最大的爱好之一了，我会愿意为自己喜欢的电影打call，好的电影我也会认认真真欣赏，如果有必要，我仍然会写成博客与诸位分享。]]></content>
      <categories>
        <category>观剧后感</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FirstBlog]]></title>
    <url>%2F2019%2F02%2F13%2FFirstBlog%2F</url>
    <content type="text"><![CDATA[FirstBlog第一篇文章这是三级标题 列表1 列表2 a 子列表 b 子列表 列表3 ZEALER 倾斜字体 加粗 println(&quot;Hello World&quot;); for (int i = 0; i &lt; 10; i++) { println(&quot;Hello World&quot;); } 引用文章 Markdown源码# FirstBlog ## 第一篇文章 ### 这是三级标题 - 列表1 - 列表2 a 子列表 b 子列表 - 列表3 --- --------------------- [ZEALER](http://www.zealer.com/) ![白色缘起](https://img1.doubanio.com/view/photo/l/public/p2540374727.webp) *倾斜字体* **加粗** `println(&quot;Hello World&quot;);`]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
