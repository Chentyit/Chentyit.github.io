<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>集群环境Jar包冲突解决方案</title>
    <url>/2019/12/20/%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83Jar%E5%8C%85%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>开发环境：Maven 3.6 || jdk 1.8（解决方案亲测有效）</p>
</blockquote>
<p><img src="/2019/12/20/集群环境Jar包冲突解决方案/D:/Blog/myblog/source/_posts/Maven项目加载不到Mybatis的xml文件报异常的解决方案/christian-lambert-1452519-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/XR0kq2VDIUo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Christian Lambert</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>集成环境中（比如大数据的 CDH，Oozie）有配套的第三方 Jar 包，在自己编写的工具中使用了相同的包，但是版本不同，就会在运行是报错，包的版本产生冲突</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NoSuchFieldError: INSTANCE</span><br></pre></td></tr></table></figure>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用 <strong>maven-shade-plugin</strong> 对需要的第三方包重命名并重新打包，<strong>映射</strong>成自己定义的名字</p>
<h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><h3 id="在-pom-xml-文件中添加-shade-插件"><a href="#在-pom-xml-文件中添加-shade-插件" class="headerlink" title="在 pom.xml 文件中添加 shade 插件"></a>在 pom.xml 文件中添加 shade 插件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">createDependencyReducedPom</span>&gt;</span>false<span class="tag">&lt;/<span class="name">createDependencyReducedPom</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- Run shade goal on package phase --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">relocations</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>my.elasticsearch<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>org.apache.http<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>my.apache.http<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>com.fasterxml.jackson<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>my.fasterxml.jackson<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">relocations</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!-- 配置主类 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></span><br><span class="line"><span class="tag">                                         <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.xxx.app.EsApp<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置编译插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>主要配置：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">relocations</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>my.elasticsearch<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>org.apache.http<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>my.apache.http<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>com.fasterxml.jackson<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shadedPattern</span>&gt;</span>my.fasterxml.jackson<span class="tag">&lt;/<span class="name">shadedPattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">relocations</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将官方包的名称及路径修改成为自定义的名称，防止冲突</p>
<h3 id="重新编译打包"><a href="#重新编译打包" class="headerlink" title="重新编译打包"></a>重新编译打包</h3><p>推荐使用 <strong>luyten</strong> 这个工具打开编译打包好的 jar 包，在使用到对应类的 class 文件中就可以看到，原来的 <code>org.elasticsearch</code> 都被替换成 <code>my.elasticsearch</code> 了，其他同理，也就不会出现在集群环境重产生 jar 包冲突的错误了</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>开发问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-promise</title>
    <url>/2019/12/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-promise/</url>
    <content><![CDATA[<p><img src="/2019/12/14/微信小程序-promise/D:/Blog/myblog/source/_posts/SpringBoot学习笔记（Day03）/max-van-den-oetelaar-1328723-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/F3rDBnQQbQU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Max van den Oetelaar</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="ES6-中的约定"><a href="#ES6-中的约定" class="headerlink" title="ES6 中的约定"></a>ES6 中的约定</h2><ul>
<li>pending：既不成功也不失败</li>
<li>fulfilled：成功状态</li>
<li>rejected：失败状态</li>
</ul>
<p><strong>代码写法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'p1'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'p2'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'p3'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'全部完成'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Promise.race：</strong>是要有一个任务完成就算是完成了</li>
<li><strong>Promise.race：</strong>所有任务开启运行</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-wx</title>
    <url>/2019/12/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-wx/</url>
    <content><![CDATA[<p><img src="/2019/12/14/微信小程序-wx/D:/Blog/myblog/source/_posts/SpringBoot学习笔记（Day03）/max-van-den-oetelaar-1328723-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/F3rDBnQQbQU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Max van den Oetelaar</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="wx"><a href="#wx" class="headerlink" title="wx"></a>wx</h2><h3 id="wx-for"><a href="#wx-for" class="headerlink" title="wx:for"></a>wx:for</h3><p><strong>作用：</strong>用于遍历 data 里面的数据</p>
<h3 id="wx-for-item"><a href="#wx-for-item" class="headerlink" title="wx:for-item"></a>wx:for-item</h3><p><strong>作用：</strong>用于指定遍历的元素名称（默认 item）</p>
<h3 id="wx-for-index"><a href="#wx-for-index" class="headerlink" title="wx:for-index"></a>wx:for-index</h3><p><strong>作用：</strong>用于指定遍历的索引名称（默认 index）</p>
<h3 id="wx-key"><a href="#wx-key" class="headerlink" title="wx:key"></a>wx:key</h3><p><strong>官方解释：</strong>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;arr&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"*this"</span> <span class="attr">wx:for-item</span>=<span class="string">"data"</span> <span class="attr">wx:for-index</span>=<span class="string">"idx"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">checkbox</span>/&gt;</span>&#123;&#123;data&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bind:tap</span>=<span class="string">"sort"</span>&gt;</span>随机排序<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;arrObj&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">checkbox</span>/&gt;</span>&#123;&#123;item.name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bind:tap</span>=<span class="string">"sortObj"</span>&gt;</span>随机排序<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="bind-tap"><a href="#bind-tap" class="headerlink" title="bind:tap"></a>bind:tap</h3><p><strong>作用：</strong>绑定 js 函数</p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-轮播图</title>
    <url>/2019/12/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
    <content><![CDATA[<p><img src="/2019/12/09/微信小程序-轮播图/D:/Blog/myblog/source/_posts/SpringBoot学习笔记（Day03）/max-van-den-oetelaar-1328723-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/F3rDBnQQbQU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Max van den Oetelaar</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="轮播图组件"><a href="#轮播图组件" class="headerlink" title="轮播图组件"></a>轮播图组件</h2><p><strong>swiper：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">swiper</span> <span class="attr">indicator-dots</span>=<span class="string">"true"</span> <span class="attr">autoplay</span>=<span class="string">"true"</span> <span class="attr">interval</span>=<span class="string">"2000"</span> <span class="attr">duration</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;swiperImgUrls&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;item.url&#125;&#125;"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>indicator-dots=”true”：</strong>轮播图的导航器</li>
<li><strong>autoplay=”true”：</strong>是否自动播放</li>
<li><strong>interval=”2000”：</strong>设置滚动时间</li>
<li><strong>duration=”1000”：</strong>滑动时长</li>
<li><strong>mode：</strong><ul>
<li>scaleToFill：不保证横纵比例缩放图片，但能让图片覆盖当前容器</li>
<li>aspectFit：显示图片完整的宽度，但不一定能填满容器高度</li>
<li>widthFix：保证宽度不变，高度自动变化，保证图片宽高比</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>6种排序</title>
    <url>/2019/10/20/6%E7%A7%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<ul>
<li>各种排序的简介</li>
<li>冒泡排序</li>
<li>选择排序</li>
<li>直接插入排序</li>
<li>希尔排序</li>
<li>归并排序</li>
<li>快速排序</li>
</ul>
<a id="more"></a>
<h2 id="各种排序的简介"><a href="#各种排序的简介" class="headerlink" title="各种排序的简介"></a>各种排序的简介</h2><ul>
<li><a href="https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin" target="_blank" rel="noopener">冒泡排序</a></li>
<li><a href="https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418?fr=aladdin" target="_blank" rel="noopener">选择排序</a></li>
<li><a href="https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">直接插入排序</a></li>
<li><a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">希尔排序</a></li>
<li><a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">归并排序</a></li>
<li><a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95?fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&amp;fromid=2084344" target="_blank" rel="noopener">快速排序</a></li>
</ul>
<p>（声明：最基础的排序公认有 8 种，我目前了解并学习的只有当前的 6 种，剩下的还有<strong>堆排序</strong>， <strong>桶排序</strong> ， <strong>基数排序</strong>等等，算法的范围很大，需要慢慢学习）</p>
<h2 id="冒泡排序实现代码"><a href="#冒泡排序实现代码" class="headerlink" title="冒泡排序实现代码"></a>冒泡排序实现代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类冒泡排序，并非正统的冒泡排序，是效率最低的排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BobbleSort0</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[j]:</span><br><span class="line">                arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 冒泡排序方法 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BobbleSort1</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="comment"># 指定冒泡的顶点位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        <span class="comment"># 开始冒泡</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr) - <span class="number">1</span>, i, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 满足条件就开始交换</span></span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[j - <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j - <span class="number">1</span>] = arr[j - <span class="number">1</span>], arr[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化的冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BobbleSort2</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="comment"># 指定一个标志位，表示是否有交换操作</span></span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="comment"># 指定冒泡的顶点位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">            <span class="comment"># 开始冒泡</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr) - <span class="number">1</span>, i, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> arr[j] &lt; arr[j - <span class="number">1</span>]:</span><br><span class="line">                    arr[j], arr[j - <span class="number">1</span>] = arr[j - <span class="number">1</span>], arr[j]</span><br><span class="line">                    <span class="comment"># 发生交换，修改标志位</span></span><br><span class="line">                    flag = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line">    BobbleSort2(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure>
<h2 id="选择排序实现代码"><a href="#选择排序实现代码" class="headerlink" title="选择排序实现代码"></a>选择排序实现代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SelectSort0</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="comment"># 第一重循环选择位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr) - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 选择当前位置</span></span><br><span class="line">        min = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(arr)):</span><br><span class="line">            <span class="comment"># 满足条件就重设当前位置</span></span><br><span class="line">            <span class="keyword">if</span> arr[min] &gt; arr[j]:</span><br><span class="line">                min = j</span><br><span class="line">        <span class="comment"># 如果选择值发生了改变说明需要交换位置了</span></span><br><span class="line">        <span class="keyword">if</span> i != min:</span><br><span class="line">            arr[min], arr[i] = arr[i], arr[min]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line">    SelectSort0(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure>
<h2 id="直接插入排序实现代码"><a href="#直接插入排序实现代码" class="headerlink" title="直接插入排序实现代码"></a>直接插入排序实现代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InsertSort0</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="comment"># 从第一位选择一个值向前插入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        <span class="comment"># 向前插入该值知道满足规律</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 找到合适的位置插入</span></span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[j - <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j - <span class="number">1</span>] = arr[j - <span class="number">1</span>], arr[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line">    InsertSort0(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序实现代码"><a href="#希尔排序实现代码" class="headerlink" title="希尔排序实现代码"></a>希尔排序实现代码</h2><p>简要说明：希尔排序就是插入排序的改进版本，因为直接插入排序面向的本来就是基本有序全局无序的序列，如果全局无序，就会造成效率变低，所以就引入了希尔排序，先按照一定的步长排序，然后逐渐减少步长直至步长为 1，提高了一定的效率，但是时间复杂度和直接插入排序相同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ShellSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="comment"># 设置第一次的步长为排序序列的长度的一半</span></span><br><span class="line">    dk = int(len(arr) / <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 保证最后的步长一定为 1</span></span><br><span class="line">    <span class="keyword">while</span> dk &gt;= <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 这里就是直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(dk, len(arr), dk):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, -dk):</span><br><span class="line">                <span class="keyword">if</span> arr[j] &lt; arr[j - dk]:</span><br><span class="line">                    arr[j], arr[j - <span class="number">1</span>] = arr[j - <span class="number">1</span>], arr[j]</span><br><span class="line">        <span class="comment"># 重设步长为当前步长的一半</span></span><br><span class="line">        dk = int(dk / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line">    ShellSort(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure>
<h2 id="归并排序实现代码"><a href="#归并排序实现代码" class="headerlink" title="归并排序实现代码"></a>归并排序实现代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="comment"># 保证最后切割出来的值只有一个</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得中间位置</span></span><br><span class="line">    mid = len(arr) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得左边的序列</span></span><br><span class="line">    left = arr[:mid]</span><br><span class="line">    <span class="comment"># 获得右边的序列</span></span><br><span class="line">    right = arr[mid:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归切割左边序列</span></span><br><span class="line">    ll = MergeSort(left)</span><br><span class="line">    <span class="comment"># 递归切割右边序列</span></span><br><span class="line">    rl = MergeSort(right)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并左右序列</span></span><br><span class="line">    <span class="keyword">return</span> Merge(ll, rl)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并（归并两个序列）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(ll, rl)</span>:</span></span><br><span class="line">    <span class="comment"># 用于存储结果的容器</span></span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 归并过程</span></span><br><span class="line">    <span class="keyword">while</span> len(ll) &gt; <span class="number">0</span> <span class="keyword">and</span> len(rl) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> ll[<span class="number">0</span>] &lt; rl[<span class="number">0</span>]:</span><br><span class="line">            result.append(ll.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(rl.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并剩下的左序列</span></span><br><span class="line">    result += ll</span><br><span class="line">    <span class="comment"># 合并剩下的右序列</span></span><br><span class="line">    result += rl</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回合并的序列</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line">    arr = MergeSort(arr)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure>
<h2 id="快速排序实现代码"><a href="#快速排序实现代码" class="headerlink" title="快速排序实现代码"></a>快速排序实现代码</h2><p>简要说明：归并排序和快速排序使用的都是分治策略，从局部有序到全局有序，但是实现的方法不同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QuickSort</span><span class="params">(arr, left, right)</span>:</span></span><br><span class="line">    <span class="comment"># 如果左指针等于右指针说明无法继续分区</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得一个分区节点</span></span><br><span class="line">    index = left</span><br><span class="line">    <span class="comment"># 存储分区节点的值</span></span><br><span class="line">    value = arr[left]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 快速排序核心</span></span><br><span class="line">    <span class="comment"># 将分区内的序列按照小的放到节点左边，大的放到节点右边</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> value &gt; arr[i]:</span><br><span class="line">            arr[index] = arr[i]</span><br><span class="line">            arr[i] = arr[index + <span class="number">1</span>]</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重新放置分区节点的值</span></span><br><span class="line">    arr[index] = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归调用快排函数</span></span><br><span class="line">    QuickSort(arr, left, index - <span class="number">1</span>)</span><br><span class="line">    QuickSort(arr, index + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line">    QuickSort(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>八皇后问题</title>
    <url>/2019/10/20/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li>问题介绍</li>
<li>解题思路</li>
<li>实例代码</li>
</ul>
<a id="more"></a>
<h2 id="问题介绍（来源百度百科）"><a href="#问题介绍（来源百度百科）" class="headerlink" title="问题介绍（来源百度百科）"></a>问题介绍（来源百度百科）</h2><p> 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手<strong>马克斯·贝瑟尔</strong>于 1848 年提出：在 <strong>8×8</strong> 格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都<strong>不能处于同一行、同一列或同一斜线</strong>上，问有多少种摆法。 <a href="https://baike.baidu.com/item/高斯/24098" target="_blank" rel="noopener">高斯</a>认为有 76 种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用<strong>图论</strong>的方法解出 <strong>92</strong> 种结果。计算机发明后，有多种计算机语言可以解决此问题。 </p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>先选择棋盘中的一个点</li>
<li>判断该点是否满足放置要求</li>
<li>满足则将该位置设置标志位，不满足则不放置</li>
<li>寻找下一个点</li>
<li>循环 2，3，4 步骤直至遍历整个棋盘</li>
</ol>
<h2 id="实例代码（Python）"><a href="#实例代码（Python）" class="headerlink" title="实例代码（Python）"></a>实例代码（Python）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用于记录有多少种解法</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment"># 生成棋盘</span></span><br><span class="line">arr = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查这个坐标是否可以放棋子</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(row, col)</span>:</span></span><br><span class="line">    <span class="comment"># 设置全局可修改 arr</span></span><br><span class="line">    <span class="keyword">global</span> arr</span><br><span class="line">    <span class="comment"># 检查行列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">        <span class="keyword">if</span> arr[i][col] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查左对角线</span></span><br><span class="line">    <span class="keyword">for</span> (i, m) <span class="keyword">in</span> zip(range(row - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>), range(col - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>)):</span><br><span class="line">        <span class="keyword">if</span> arr[i][m] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查右对角线</span></span><br><span class="line">    <span class="keyword">for</span> (i, m) <span class="keyword">in</span> zip(range(row - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>), range(col + <span class="number">1</span>, <span class="number">8</span>)):</span><br><span class="line">        <span class="keyword">if</span> arr[i][m] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始布局</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findQueen</span><span class="params">(row)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    <span class="keyword">global</span> arr</span><br><span class="line">    <span class="comment"># 如果存在某一种情况则加一</span></span><br><span class="line">    <span class="keyword">if</span> row &gt; <span class="number">7</span>:</span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> check(row, col):</span><br><span class="line">            <span class="comment"># 棋子放置的位置设置为 1</span></span><br><span class="line">            arr[row][col] = <span class="number">1</span></span><br><span class="line">            findQueen(row + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 将数据归 0 防止出现脏数据</span></span><br><span class="line">            arr[row][col] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"八皇后问题"</span>)</span><br><span class="line">    findQueen(<span class="number">0</span>)</span><br><span class="line">    print(count)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink on Yarn 集群 HA 安装及配置</title>
    <url>/2019/10/19/Flink-on-Yarn-%E9%9B%86%E7%BE%A4-HA-%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<ul>
<li>搭建 Hadoop HA 集群及 ZK 集群</li>
<li>下载 Flink</li>
<li>解压安装包</li>
<li>修改 /etc/profile 添加环境变量</li>
<li>修改配置文件</li>
<li>启动 Flink 集群</li>
<li>HA 容错机制</li>
<li>On Yarn</li>
</ul>
<a id="more"></a>
<h2 id="搭建-Hadoop-HA-集群及-ZK-集群"><a href="#搭建-Hadoop-HA-集群及-ZK-集群" class="headerlink" title="搭建 Hadoop HA 集群及 ZK 集群"></a>搭建 Hadoop HA 集群及 ZK 集群</h2><p><a href="http://chentyit.com/2019/09/15/Zookeeper%E5%AE%89%E8%A3%85%E5%92%8CHadoop%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener">Zookeeper 安装和 Hadoop 安装</a></p>
<h2 id="下载-Flink"><a href="#下载-Flink" class="headerlink" title="下载 Flink"></a>下载 Flink</h2><p>我使用的是 <a href="https://www.apache.org/dyn/closer.lua/flink/flink-1.7.2/flink-1.7.2-bin-hadoop28-scala_2.11.tgz" target="_blank" rel="noopener">Flink 1.7.2</a></p>
<p>这里要注意，如果要搭配 Hadoop 使用，一定要下载带有 <strong>with Hadoop</strong> 或者 <strong>Pre-bundled Hadoop</strong> 的安装包，只有 <code>for Scala</code> 的没法连接到 HDFS（亲测踩坑），应该是少了一些包，因为我测试的时候，两种安装包的大小都相差了 30Mb 左右</p>
<h2 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 这里注意，安装包是带有 hadoop 的，没有的话重新去下载</span><br><span class="line">tar -xzvf flink-1.7.2-bin-hadoop28-scala_2.11.tgz</span><br></pre></td></tr></table></figure>
<h2 id="修改-etc-profile-添加环境变量"><a href="#修改-etc-profile-添加环境变量" class="headerlink" title="修改 /etc/profile 添加环境变量"></a>修改 /etc/profile 添加环境变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export FLINK_HOME="/usr/local/flink-1.7.2"</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;FLINK_HOME&#125;/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 更新一下</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 进入解压路径</span><br><span class="line">cd **/flink-1.7.2</span><br></pre></td></tr></table></figure>
<h3 id="flink-conf-yaml-修改配置项"><a href="#flink-conf-yaml-修改配置项" class="headerlink" title="flink-conf.yaml 修改配置项"></a>flink-conf.yaml 修改配置项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim conf/flink-conf.yaml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 改成各自节点的名称或者 IP 地址</span><br><span class="line"><span class="meta">#</span> 这个配置项有坑（更坑的是官网还没说），可以借鉴这篇博客：https://www.jianshu.com/p/e48b73221c67</span><br><span class="line">jobmanager.rpc.address: bigdata1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 开启高可用模式</span><br><span class="line">high-availability: zookeeper</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 指定 HDFS 的路径，用于存储 JobManager 的元数据</span><br><span class="line">high-availability.storageDir: hdfs://ns/flink/ha/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 配置 zk 各个节点的端口</span><br><span class="line">high-availability.zookeeper.quorum: bigdata1:2181,bigdata2:2181,bigdata3:2181</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> zk 节点根目录，放置所有 flink 集群节点的 namespace</span><br><span class="line">high-availability.zookeeper.path.root: /flink</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> zk 节点集群 id，放置了 flink 集群所需要的所有协调数据</span><br><span class="line">high-availability.cluster-id: /cluster_one</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 配置Yarn重试次数</span><br><span class="line">yarn.application-attempts: 10</span><br></pre></td></tr></table></figure>
<h3 id="slaves-添加-TaskManagerRunner"><a href="#slaves-添加-TaskManagerRunner" class="headerlink" title="slaves 添加 TaskManagerRunner"></a>slaves 添加 TaskManagerRunner</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim conf/slaves</span><br><span class="line"></span><br><span class="line">bigdata1</span><br><span class="line">bigdata2</span><br><span class="line">bigdata3</span><br></pre></td></tr></table></figure>
<h3 id="masters-添加-StandaloneSessionClusterEntrypoint"><a href="#masters-添加-StandaloneSessionClusterEntrypoint" class="headerlink" title="masters 添加 StandaloneSessionClusterEntrypoint"></a>masters 添加 StandaloneSessionClusterEntrypoint</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim conf/masters</span><br><span class="line"></span><br><span class="line">bigdata5:8081</span><br><span class="line">bigdata6:8081</span><br></pre></td></tr></table></figure>
<h3 id="修改-yarn-site-xml"><a href="#修改-yarn-site-xml" class="headerlink" title="修改 yarn-site.xml"></a>修改 yarn-site.xml</h3><p><strong>添加以下信息</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置提交应用程序的最大尝试次数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.am.max-attempts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">        The maximum number of application master execution attempts.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="启动-Flink-集群"><a href="#启动-Flink-集群" class="headerlink" title="启动 Flink 集群"></a>启动 Flink 集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 因为前面已经添加到环境变量了，直接运行命令即可</span><br><span class="line"><span class="meta">#</span> 没有添加就要到 flink 的 bin 目录下运行该命令</span><br><span class="line">start-cluster.sh</span><br></pre></td></tr></table></figure>
<h3 id="启动结果"><a href="#启动结果" class="headerlink" title="启动结果"></a>启动结果</h3><p><strong>bigdata1</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">14195 TaskManagerRunner</span><br></pre></td></tr></table></figure>
<p><strong>bigdata2</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">56062 TaskManagerRunner</span><br></pre></td></tr></table></figure>
<p><strong>bigdata3</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">44918 TaskManagerRunner</span><br></pre></td></tr></table></figure>
<p><strong>bigdata5</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">44734 StandaloneSessionClusterEntrypoint</span><br></pre></td></tr></table></figure>
<p><strong>bigdata6</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">4177 StandaloneSessionClusterEntrypoint</span><br></pre></td></tr></table></figure>
<h3 id="WebUI"><a href="#WebUI" class="headerlink" title="WebUI"></a>WebUI</h3><p><img src="/2019/10/19/Flink-on-Yarn-集群-HA-安装及配置/FlinkWebUI.png" alt="FlinkWebUI"></p>
<h3 id="ZK-节点查看"><a href="#ZK-节点查看" class="headerlink" title="ZK 节点查看"></a>ZK 节点查看</h3><p><img src="/2019/10/19/Flink-on-Yarn-集群-HA-安装及配置/FlinkZK.png" alt="FlinkZK"></p>
<h3 id="HDFS-查看"><a href="#HDFS-查看" class="headerlink" title="HDFS 查看"></a>HDFS 查看</h3><p><img src="/2019/10/19/Flink-on-Yarn-集群-HA-安装及配置/FlinkHDFS.png" alt="FlinkHDFS"></p>
<h2 id="HA-容错机制"><a href="#HA-容错机制" class="headerlink" title="HA 容错机制"></a>HA 容错机制</h2><p>直接 kill 一个 Master 进程，另一个 Master 会自动上线（需要点时间，可能有点长，亲测成功）</p>
<p><strong>重启被 kill 的进程：jobmanager.sh start</strong></p>
<h2 id="On-Yarn"><a href="#On-Yarn" class="headerlink" title="On Yarn"></a>On Yarn</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn-session.sh -n 2</span><br></pre></td></tr></table></figure>
<h3 id="WebUI-查看-job"><a href="#WebUI-查看-job" class="headerlink" title="WebUI 查看 job"></a>WebUI 查看 job</h3><p>这里我用 <code>yarn application -kill jobId</code> 关掉了，所以状态是 History（这个命令在我面试的时候被问到过，-list 是列出所有的 job）</p>
<p><img src="/2019/10/19/Flink-on-Yarn-集群-HA-安装及配置/FlinkOnYarn.png" alt="FlinkOnYarn"></p>
<h2 id="至此安装完成"><a href="#至此安装完成" class="headerlink" title="至此安装完成"></a>至此安装完成</h2>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase 概念</title>
    <url>/2019/10/12/HBase-%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<ul>
<li>HBase 安装</li>
<li>简介</li>
<li>Hbase数据模型</li>
<li>RowKey 的设计</li>
<li>列簇设计</li>
</ul>
<a id="more"></a>
<h2 id="HBase-安装"><a href="#HBase-安装" class="headerlink" title="HBase 安装"></a>HBase 安装</h2><p><a href="http://chentyit.com/2019/09/01/HBase-%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener">安装连接</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-HBase"><a href="#什么是-HBase" class="headerlink" title="什么是 HBase"></a>什么是 HBase</h3><p>Hbase 是一个高可靠性，高性能，面向列，可伸缩的分布式存储系统，目标是存储并处理大型的数据</p>
<h3 id="与传统数据相比"><a href="#与传统数据相比" class="headerlink" title="与传统数据相比"></a>与传统数据相比</h3><table>
<thead>
<tr>
<th>特点</th>
<th>MySQL</th>
<th>HBase</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库的概念</td>
<td>有数据库 database 的概念和表 table 的概念</td>
<td>没有数据库的概念，有替代的命名空间 namespace 的概念，有表的概念，所有的表都是在一个 namespace 下的</td>
</tr>
<tr>
<td>主键</td>
<td>主键唯一决定了一行</td>
<td>没有主键但是有行建：rowkey</td>
</tr>
<tr>
<td>字段</td>
<td>表中直接包含字段</td>
<td>有列簇的概念，每个列簇中才包含了字段，给相同属性的列划分一个组，叫做 column family 列簇，在建表的时候至少要指明一个列簇，可以不给字段</td>
</tr>
<tr>
<td>版本</td>
<td>行列交叉可到一个唯一的单元格，数据的版本数只有 1</td>
<td>可以存储多个版本 version（相当于是可以存储多个值），HBase 行列交叉得到一个唯一的单元格组，组中可以有多个单元格，可以设置 HBase 的 version 版本数，是 int 值，当 version 为 1 的时候没就没有单元格组的概念了，就是一个单元格，默认情况下，显示 timestamp 最新的那个单元格的值</td>
</tr>
<tr>
<td>空值</td>
<td>MySQL 中没有值的话就是 null，是占空间的</td>
<td>对于 HBase 来说，如果没有这一列的信息，那么就不会存储，不会分配任何空间</td>
</tr>
</tbody>
</table>
<h3 id="Hbase-架构"><a href="#Hbase-架构" class="headerlink" title="Hbase 架构"></a>Hbase 架构</h3><p><a href="https://blog.csdn.net/lzxlfly/article/details/82229511" target="_blank" rel="noopener"><strong>架构详解</strong></a></p>
<p><img src="/2019/10/12/HBase-概念/hbase架构.jpg" alt="hbase架构"></p>
<h3 id="HBase-集群中的角色"><a href="#HBase-集群中的角色" class="headerlink" title="HBase 集群中的角色"></a>HBase 集群中的角色</h3><ul>
<li>一个或多个主节点 HMaster<ol>
<li>管理 HRegionServer，通过 ZK 监控其状态，实现负载均衡</li>
<li>管理和分配 HRegion，比如在 HRegion 进行 spilit 的时候将分配新的 HRegion，当 HRegionServer 退出或者宕机的时候对 HRegionServer 管理的 HRegion 进行迁移</li>
<li>Admin 职能：创建、修改、删除 Table 的定义，实现 DDL 操作（namespace 和 table 的增删改，列簇的增删改）</li>
<li>管理 namespace 和表的元数据（存储在 HDFS 上）</li>
<li>权限控制</li>
</ol>
</li>
<li>多个从节点 RegionServer<ol>
<li>管理自己负责的 Region 数据的读写</li>
<li>读写 HDFS，管理 table 中的数据</li>
<li>Client 直接通过 RegionServer 读写数据（从 ZK 中获取 meta 表的存储位置，从 meta 表中获取 RowKey 所在的 RegionServer 的位置）</li>
</ol>
</li>
<li>Zookeeper<ol>
<li>存放整个 HBase 集群的元数据</li>
<li>保证任何时候，集群中只有一个master</li>
<li>保证 HMaster 的失败恢复</li>
<li>监控 RegionServer 的运行状态</li>
<li>存储 HBase 的 schema 和 table 元数据</li>
</ol>
</li>
</ul>
<h3 id="HBase-中的表的特点"><a href="#HBase-中的表的特点" class="headerlink" title="HBase 中的表的特点"></a>HBase 中的表的特点</h3><ol>
<li>大：一个表可以有上亿行，上百万列</li>
<li>面向列：面向列的存储和权限控制，列独立检索</li>
<li>稀疏：对于为空（null）的列，并不占用存储空间，因此，表可以设计的非常稀疏</li>
<li>HBase 的存储数据都是二进制的</li>
</ol>
<h2 id="Hbase数据模型"><a href="#Hbase数据模型" class="headerlink" title="Hbase数据模型"></a>Hbase数据模型</h2><ul>
<li><p>单元格（<strong>Cell</strong>）</p>
<ol>
<li>cell 由行和列的坐标交叉决定</li>
<li>单元格是有版本的</li>
<li>cell 的内容是未解析的字节数组</li>
<li>cell 由 <strong>{rowkey, column(<code>&lt;column family&gt;</code> + <code>&lt;qualifier&gt;</code>), value}</strong> 来确定唯一的单元</li>
<li>cell 中的数据是没有类型的，全部是字节码形式存储的</li>
</ol>
</li>
<li><p>RowKey</p>
<ol>
<li>决定一行数据，按行检索数据，相当于一级索引</li>
<li>按照字典顺序排序，说明数据是有序的</li>
<li>只能存储 64k 的字节数据，RowKey 越短越好</li>
</ol>
</li>
<li><p>列族 / 列簇（Column Family）</p>
<ol>
<li>HBase 表中的每个列都归属于某个列簇，列簇必须作为表模式（schema）定义的一部分预先给出，列名以列簇作为前缀，每个列簇都可以有多个列</li>
<li>权限控制、存储以及调优都是在列簇层面进行的</li>
<li>HBase 把同一列簇里面的数据存储在同一目录下，由几个文件保存</li>
</ol>
</li>
<li><p>时间戳（Timestamp）</p>
<ol>
<li>在 HBase 每个 cell 存储单元对同一份数据可以有多个版本，根据唯一的时间戳来区分每个版本之间的差异，不同本的数据按照时间倒序排序，最新的数据版本排在最前面</li>
<li>时间戳的类型是 64 位整型，一般由 HBase（在数据写入时自动）赋值，此时时间戳时精确到毫秒的当前系统时间</li>
</ol>
<p>时间戳也可以由客户显示赋值，如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳</p>
</li>
</ul>
<h2 id="HBase-读数据流程"><a href="#HBase-读数据流程" class="headerlink" title="HBase 读数据流程"></a>HBase 读数据流程</h2><p><a href="https://www.imooc.com/article/73049" target="_blank" rel="noopener">hbase 读数据</a></p>
<h2 id="RowKey-的设计"><a href="#RowKey-的设计" class="headerlink" title="RowKey 的设计"></a>RowKey 的设计</h2><p><a href="https://blog.csdn.net/wangshuminjava/article/details/80575864" target="_blank" rel="noopener"><strong>rk设计</strong></a></p>
<h2 id="列簇设计"><a href="#列簇设计" class="headerlink" title="列簇设计"></a>列簇设计</h2><p><a href="https://www.cnblogs.com/llphhl/p/6609876.html" target="_blank" rel="noopener">列簇设计</a></p>
<p><strong>一般不建议设计多个列族</strong>，具体原因如下</p>
<p>假如 HBase 的表设置两个列族，若已一个列族 1000 万行，另一个列族 100 行。当一个要求 region 分裂时候，会导致 100 行的列会同样分布到多个 region 中。这样就出现基数问题，会导致扫描列族A的性能低下。某个列族在 flush 的时候，它邻近的列族也会因关联效应出发 flush，最终导致系统产生更多的I/O。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive 概念</title>
    <url>/2019/10/11/Hive-%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<ul>
<li>简介</li>
<li>Hive 特点</li>
<li>Hive 架构</li>
<li>MetaStore 组件</li>
<li>Hive 执行流程</li>
<li>Hive 与传统数据库相比</li>
<li>创建 Hive 表</li>
<li>分区表和分桶表</li>
<li>Hive 优化</li>
</ul>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-Hive"><a href="#什么是-Hive" class="headerlink" title="什么是 Hive"></a>什么是 Hive</h3><p>Hive 是基于 Hadoop 的一个<strong>数据仓库</strong>工具，可以将结构化的数据文件映射为一张数据库表，并提供类似于 SQL 的查询功能功能</p>
<h3 id="为什么使用-Hive"><a href="#为什么使用-Hive" class="headerlink" title="为什么使用 Hive"></a>为什么使用 Hive</h3><p><strong>直接使用 hadoop 所面临的问题：</strong></p>
<ul>
<li>人员学习成本太高</li>
<li>项目周期要求太短</li>
<li>MapReduce 实现复杂查询逻辑开发难度太大</li>
</ul>
<p><strong>为什么要使用 Hive：</strong></p>
<ul>
<li>操作接口采用类 SQL 语法，提供快速开发的能力</li>
<li>避免了去写 MapReduce，减少开发人员的学习成本</li>
<li>扩展功能很方便</li>
</ul>
<h2 id="Hive-特点"><a href="#Hive-特点" class="headerlink" title="Hive 特点"></a>Hive 特点</h2><ul>
<li><p>可扩展</p>
<p>Hive 可以自由的扩展集群的规模，一般情况下不需要重启服务</p>
</li>
<li><p>延展性</p>
<p>Hive 支持用户自定义函数，用户可以根据自己的需求来实现自己的函数</p>
</li>
<li><p>容错性</p>
<p>良好的容错性，节点出问题，SQL 仍可完成执行</p>
</li>
</ul>
<h2 id="Hive-架构"><a href="#Hive-架构" class="headerlink" title="Hive 架构"></a>Hive 架构</h2><p><img src="/2019/10/11/Hive-概念/hive架构图.png" alt="hive 架构"></p>
<h3 id="服务端主件"><a href="#服务端主件" class="headerlink" title="服务端主件"></a>服务端主件</h3><ol>
<li><p>用户接口：Client</p>
<p>CLI（command-line interface）、JDBC/ODBC(jdbc访问hive)、WEBUI（浏览器访问hive）</p>
</li>
<li><p>元数据：Metastore</p>
<ul>
<li><p>single user mode：</p>
<p>默认安装在 hive 的机器上，hive 是使用 derby 内数据库保存 hive 的元数据，这样是不可以并发调用 hive 的</p>
</li>
<li><p>multiuser node ：</p>
<p>通过网络连接到一个数据库中，是最经常使用到的模式，假设使用本机 mysql 服务器存储元数据</p>
</li>
<li><p>remote server mode：</p>
<p>用于非 java 客户端访问元数据库，在服务器端启动一个 MetaStoreServer，客户端利用 Thrift 协议通过 MetaStoreServer 访问元数据库</p>
</li>
</ul>
</li>
<li><p>存储介质：Hadoop</p>
<p>Hive 使用 HDFS 进行存储,使用 MapReduce 进行计算</p>
</li>
<li><p>驱动器：Driver</p>
<p>该组件包括Complier、Optimizer 和 Executor，它的作用是将我们写的 HiveQL（类SQL）语句进行解析、编译优化，生成执行计划，然后调用底层的 mapreduce 计算框架。</p>
</li>
</ol>
<h3 id="客户端组件"><a href="#客户端组件" class="headerlink" title="客户端组件"></a>客户端组件</h3><ol>
<li><p>CLI：</p>
<p>command line interface，命令行接口</p>
</li>
<li><p>Thrift 客户端：</p>
<p>hive 架构的许多客户端接口是建立在 thrift 客户端之上，包括 JDBC 和 ODBC 接口</p>
</li>
<li><p>WebUI：</p>
<p>hive 客户端提供了一种通过网页的方式访问 hive 所提供的服务，这个接口对应 hive 的 hwi（hive-web-interface），使用前需要启动 hwi 服务</p>
</li>
</ol>
<h2 id="MetaStore-组件"><a href="#MetaStore-组件" class="headerlink" title="MetaStore 组件"></a>MetaStore 组件</h2><p>Hive 的 MetaStore 组件是 hive 元数据集中存放地。MetaStore 组件包括两个部分：</p>
<ol>
<li>MetaStore 服务</li>
<li>后台数据的存储</li>
</ol>
<p>后台数据存储的介质就是关系数据库，hive 默认的嵌入式磁盘数据库 derby，还有 mysql 数据库。MetaStore 服务是建立在后台数据存储介质之上，并且可以和 hive 服务是安装在一起的，运行在同一个 JVM 进程当中。</p>
<p>但也可以将 MetaStore 服务从 Hive 中剥离出来，单独放在一个集群中，为这个集群安装防火墙，提供安全服务，保证元数据安全，客户端只需要通过防火墙认证连接到元数据即可，保证了 hive 的稳定性，也提高了效率</p>
<h2 id="Hive-执行流程"><a href="#Hive-执行流程" class="headerlink" title="Hive 执行流程"></a>Hive 执行流程</h2><p><img src="/2019/10/11/Hive-概念/hive执行流程.png" alt="Hive 执行流程"></p>
<h2 id="Hive-与传统数据库相比"><a href="#Hive-与传统数据库相比" class="headerlink" title="Hive 与传统数据库相比"></a>Hive 与传统数据库相比</h2><table>
<thead>
<tr>
<th></th>
<th>Hive</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询语言</td>
<td>HQL</td>
<td>SQL</td>
</tr>
<tr>
<td>数据存储</td>
<td>HDFS</td>
<td>Raw Device or Local FS</td>
</tr>
<tr>
<td>执行</td>
<td>MapReduce</td>
<td>Excutor</td>
</tr>
<tr>
<td>执行延迟</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>处理数据规模</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>索引</td>
<td>0.8 版本后加入位图索引，紧凑索引</td>
<td>有复杂的索引</td>
</tr>
</tbody>
</table>
<p><strong>总结：</strong>hive 具有 sql 数据库的外表，但应用场景完全不同，hive 只适合用来做批量数据统计分析</p>
<h3 id="其他比较"><a href="#其他比较" class="headerlink" title="其他比较"></a>其他比较</h3><ul>
<li><p>读时模式 VS 写时模式</p>
<p>在传统数据里，插入数据时，表的模式是强制确定了的，如果不符合，就不允许插入，在写入时检查数据被称为<strong>“写时模式”</strong></p>
<p>hive 对数据的验证不在加载数据时进行，而在查询时进行，称为<strong>“读时模式”</strong></p>
<p>写时模式有利于提升查询性能，数据库可以对列进行索引，并对数据库进行压缩，但是加载数据库就会消耗更多的时间</p>
</li>
<li><p>更新、事务</p>
<p>hive 的表更新是通过把数据变换后放入新表实现的</p>
<p>HDFS 不提供就地文件更新，所以，插入、更新和删除操作因引起的变化都被保存在一个较小的增量文件中，由 metastore 在后台运行的 MapReduce 作业定期将增量的文件合并到 <strong>“基表”</strong> 中。这些功能只能在事务的背景环境下才能使用（hive 0.13.0 版本引入事务)</p>
</li>
<li><p>索引</p>
<ul>
<li><strong>紧凑索引：</strong>存储每个值的 HDFS 的块号，不是存储文件内的偏移量，不会占用过多的磁盘空间</li>
<li><strong>位图索引：</strong>使用压缩的<strong>位集合</strong>来存储具有某个特殊值的行，通常用于<strong>具有少取值可能的列</strong></li>
</ul>
</li>
</ul>
<h2 id="创建-Hive-表"><a href="#创建-Hive-表" class="headerlink" title="创建 Hive 表"></a>创建 Hive 表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 表中的字段和数据类型</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="keyword">string</span>,</span><br><span class="line">    age <span class="built_in">int</span>,</span><br><span class="line">    fav <span class="built_in">array</span>&lt;<span class="keyword">string</span>&gt;,</span><br><span class="line">    addr <span class="keyword">map</span>&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;</span><br><span class="line">)</span><br><span class="line">// 表的简介</span><br><span class="line"><span class="keyword">comment</span> <span class="string">'This is the person table'</span></span><br><span class="line">// 定义这张表使用的数据文件格式，这里指定为 txt 类型</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span></span><br><span class="line">collection items <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'-'</span></span><br><span class="line"><span class="keyword">map</span> <span class="keyword">keys</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">':'</span></span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> textfile;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>row format delimited fields terminated by ‘\t’</strong></p>
<p>定义每一个字段的分隔符，这里 ‘\t’ 表示以 Tab 作为分隔符分隔每行字段</p>
</li>
<li><p><strong>collection items terminated by ‘-‘</strong></p>
<p>定义集合中每个对象的分隔符，fav 字段是 String 类型的数组，以 ‘-‘ 为分隔符，分隔每个字符串</p>
</li>
<li><p><strong>map keys terminated by ‘:’</strong></p>
<p>定义 Map 类型键值对的分隔符，这里指定为 txt 类型</p>
</li>
</ul>
<h2 id="分区表和分桶表"><a href="#分区表和分桶表" class="headerlink" title="分区表和分桶表"></a>分区表和分桶表</h2><p><a href="https://blog.csdn.net/shudaqi2010/article/details/90288901" target="_blank" rel="noopener">Hive的分区表和分桶表的区别</a></p>
<h2 id="Hive-优化"><a href="#Hive-优化" class="headerlink" title="Hive 优化"></a>Hive 优化</h2><p><a href="https://www.cnblogs.com/smartloli/p/4356660.html" target="_blank" rel="noopener">hive优化</a></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn 概念</title>
    <url>/2019/10/10/Yarn-%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<ul>
<li>简介</li>
<li>重要概念</li>
<li>执行过程</li>
<li>YARN的高可用</li>
</ul>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Yarn 是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而 MapReduce 等运算程序则相当于运行于操作系统之上的应用程序</p>
<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><ol>
<li>yarn 并不清楚用户提交的程序的运行机制</li>
<li>yarn 只提供运算资源的调度（用户向 yarn 申请资源，yarn 就负责分配资源）</li>
<li>yarn 中的主管角色叫 ResourceManager</li>
<li>yarn 中具体提供运算资源的角色叫 NodeManager</li>
<li>yarn 于运行用户程序完全解耦，意味着 yarn 上可以运行各种类型的分布式运算程序（MapReduce 只是其中一种）</li>
<li>spark 等运算框架都可以整合在 yarn 上运行，只要他们各自的框架中有符合 yarn 规范的资源请求机制即可</li>
</ol>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ol>
<li>客户端通过 YarnRunner 向 RM 提交 job 任务。申请运行一个 MR 程序，RM 返回一个 job id，资源提交路径</li>
<li>客户端提交 MR 相关的资源文件：job.xml，job.jar，job.split，job.splitmateinfo</li>
<li>客户端通知 RM 资源提交完毕，RM 初始化任务创建一个 Container，RM 随机在一台 NM 上启动一个 MRAppMaster，MRAppMaster 向 RM 申请资源分配容器（CPU，RAM，job 等资源）</li>
<li>在 NM 上启动 MapTask，Task 在执行的时候会向 MRAppMaster 汇报进度和状态，MRAppMaster 会向 RM 注册，用户可以通过 RM 查看当前作业的状态</li>
<li>MRAppMaster 会向 RM 为各个任务申请资源，并监控状态直到任务完成</li>
<li>MRAppMaster 等待所有 MapTask 执行完毕，再启动 ReduceTask</li>
<li>所有任务完成后，MRAppMaster 通知 RM 回收资源</li>
</ol>
<p><img src="/2019/10/10/Yarn-概念/yarn.png" alt="yarn"></p>
<h2 id="YARN的高可用"><a href="#YARN的高可用" class="headerlink" title="YARN的高可用"></a>YARN的高可用</h2><p><strong>ResourceManager：</strong>基于 Zookeeper 实现高可用机制，避免单节点故障</p>
<p><strong>NodeManager：</strong>执行失败后，ResourceManager 将失败任务告诉对应的 ApplicationMaster，由 ApplicationMaster 来决定如何处理失败的任务</p>
<p><strong>ApplicationMaster：</strong>执行失败后，由 ResourceManager 负责重启；ApplicationMaster 需处理内部的容错问题，并保存已经运行完成的 Task，重启后无需重新运行</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>MR 概念</title>
    <url>/2019/10/10/MR-%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<ul>
<li>简介</li>
<li>MR 程序组成部分</li>
<li>MapTask 并行度</li>
<li>ReduceTask 的并行度</li>
<li>Shuffle 机制</li>
<li>文件太小如何处理</li>
<li>自定义分区</li>
<li>二次排序</li>
</ul>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MapReduce 是一个分布式运算程序的<strong>编程框架</strong>，是用户开发<strong>基于 hadoop 的数据分析应用</strong>的核心框架</p>
<p>MapReduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 hadoop 集群上</p>
<h2 id="MR-程序组成部分"><a href="#MR-程序组成部分" class="headerlink" title="MR 程序组成部分"></a>MR 程序组成部分</h2><ul>
<li><p>Split</p>
<p>将程序输入的数据进行切分，每个 split 交给一个 MapTask 执行。split 的数量可以自己定义，默认情况下一个文件一个 split</p>
</li>
<li><p>Map</p>
<p>输入 为一个 split 中的数据，对 split 中的数据进行拆分，并以&lt;key, value&gt; 对的格式保存数据</p>
</li>
<li><p>Shuffle / Combine / sort</p>
<p>这几个过程在简单的 MR 程序中并不需要我们关注，因为源代码中已经给出了一些默认的 Shuffle / Combine / sort 处理器，作用分别是：</p>
<ul>
<li>Combine：对 MapTask 产生的结果在本地节点上进行合并、统计等，以减少后续整个集群间的 Shuffle 过程所需要传输的数据量</li>
<li>Shuffle / Sort：将集群中各个 MapTask 的处理结果在集群间进行传输，排序，数据经过这个阶段之后就作为 Reduce 端的输入</li>
</ul>
</li>
<li><p>Reduce</p>
<p>ReduceTask 的输入数据是经过排序之后的一系列 key 值相同的 &lt;key, value&gt; 对，ReduceTask 对其进行统计等处理，产生最终的输出。ReduceTask 的数量可以设置</p>
</li>
</ul>
<h2 id="MapTask-并行度"><a href="#MapTask-并行度" class="headerlink" title="MapTask 并行度"></a>MapTask 并行度</h2><p>选择并发数的影响因素：</p>
<ol>
<li>运算节点的硬件配置</li>
<li>运算任务的类型：CPU 密集型还是 IO 密集型</li>
<li>运算任务的数据量</li>
</ol>
<h3 id="Task-并行度的经验"><a href="#Task-并行度的经验" class="headerlink" title="Task 并行度的经验"></a>Task 并行度的经验</h3><ul>
<li>最好每个 task 执行的时间至少一分钟</li>
<li>如果 job 的每个 map 或者 reducetask 运行时间比较短，那就应该减少 job 的 map 或者 reduce 的数量，因为每个 task 的 setup 和加入到调度器需要消耗一定的时间，如果每个 task 都花不了太多时间，就没必要有太多的 task</li>
<li>默认情况下，每个 task 都是一个 jvm 实例，都需要开启和销毁，jvm 的开启和销毁所需要的时间比执行的时间要长，所以配置 jvm 的可重用性可以改善性能</li>
<li>mapred.job.reuse.jvm.num.tasks，默认是 1，表示一个 JVM 上最可以顺序执行的 task 数目是 1，也就是说一个 task 启动一个 JVM</li>
<li>如果 input 的文件非常大，可以考虑将 hdfs 上的每个 blocksize 设置大一些，比如 256MB 或者 512MB</li>
<li>JVM 重用技术不是指同一个 job 的多个 task 可以同时运行于同一个 JVM 上，而是排队按顺序执行</li>
</ul>
<h2 id="ReduceTask-的并行度"><a href="#ReduceTask-的并行度" class="headerlink" title="ReduceTask 的并行度"></a>ReduceTask 的并行度</h2><p>maptask 的并发数由切片数决定不同，reducetask 数量是可以手动设置的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认为 1，手动设置为 4</span></span><br><span class="line">job.setNumReduceTask(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>如果数据分布不均匀，就有可能在 reduce 阶段产生数据倾斜</p>
<p><strong>注意：</strong>ReduceTask 数量并不是任意设置的，需要考虑业务逻辑需求，有些情况需要计算全局汇总结果，就只能有一个 reducetask</p>
<p>尽量不要运行太多的 reducetask。最好 reduce 数量和集群中的 reduce 持平或者比集群中的 reduce slots 小</p>
<h2 id="Shuffle-机制"><a href="#Shuffle-机制" class="headerlink" title="Shuffle 机制"></a>Shuffle 机制</h2><p><img src="/2019/10/10/MR-概念/shuffer.png" alt="shuffle"></p>
<p><strong>wordcount 的 shuffle 详细过程：</strong></p>
<ol>
<li><strong>读取数据：</strong>MR 默认使用 TextInputFormat 来获取切片的数量，通过 createRecordReader 方法获取 RecordReader，缺省的 RecordReader 是 LineRecordReader，通过调用 LineRecordReader 的 nextKeyValue 方法获取每行的数据</li>
<li><strong>溢出：</strong>通过 OutputCollector 收集器收集读取的数据，缺省使用的是 Task.CombineOutputCollector，调用其 collect 进行溢出，收集器默认的空间是 100 M，当收集器达到 80% 的时候开始溢出</li>
<li><strong>分区排序：</strong>mapreduce 默认通过 HashPartitioner 进行分区且有序（在内存中结束）</li>
<li><strong>输出文件：</strong>maptask 的最终输出文件分区有序</li>
<li><strong>Reduce拉取文件：</strong>从各个分区中拉取相同的 key 到 reducetask 中，合并归并排序，相同的 key 看作一个 group</li>
<li><strong>写出数据：</strong>FileOutputFormat 调用 RecordWriter 写出文件，相同的 key 会写到一个分区</li>
</ol>
<h2 id="文件太小如何处理"><a href="#文件太小如何处理" class="headerlink" title="文件太小如何处理"></a>文件太小如何处理</h2><p><a href="https://blog.csdn.net/zgc625238677/article/details/51793259" target="_blank" rel="noopener">小文件处理方法</a></p>
<h2 id="自定义分区"><a href="#自定义分区" class="headerlink" title="自定义分区"></a>自定义分区</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizeParitioner</span> <span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">Text</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">"139"</span>, <span class="number">0</span>);</span><br><span class="line">        map.put(<span class="string">"186"</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">"187"</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">"136"</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(Text key, NullWritable value, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">        String key_ = key.toString().subString(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> map.get(key_) != <span class="keyword">null</span> ? map.get(key_) : <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二次排序"><a href="#二次排序" class="headerlink" title="二次排序"></a>二次排序</h2><p>在 hadoop 中一般都是按照 key 进行排序的，但有时候还需要按照 value 进行排序</p>
<p>有两种方法：buffer and int memory sort 和 value-to-key conversion</p>
<ul>
<li>buffer and in memory sort：主要是在 reduce() 函数中，将每个 key 对应的 value 值保存下来，进行排序。缺点是会造成 out of memory</li>
<li>value-to-key conversion：主要思想是将 key 和 value 拼接成一个组合 key，然后进行排序，这样 reduce() 函数获取结果就实现了按照 key 排序，然后按照 value 排序，但是需要用户自己实现 paritioner，以便只按照 key 进行数据划分</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS 概念</title>
    <url>/2019/10/09/HDFS-%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<ul>
<li>简介</li>
<li>重要特性</li>
<li>HDFS 角色说明</li>
<li>HDFS 高可用机制</li>
<li>读数据流程</li>
<li>写数据流程</li>
</ul>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>分而治之：将大文件大批量文件，分布式存放在大量服务器上，以便于采取分而治之的方式对海量数据进行运算分析</p>
<h3 id="重点概念"><a href="#重点概念" class="headerlink" title="重点概念"></a>重点概念</h3><p>文件切块、副本存放、元数据</p>
<h2 id="重要特性"><a href="#重要特性" class="headerlink" title="重要特性"></a>重要特性</h2><ol>
<li><p>HDFS 中的文件在物理上是<strong>分块存储</strong>，块的大小可以通过配置参数 dfs.blocksize 来规定，默认大小在 hadoop2.x 版本中是 128M</p>
</li>
<li><p>HDFS 文件系统会给客户端提供一个<strong>统一的抽象目录树</strong>，客户端通过路径来访问文件</p>
</li>
<li><p>目录结构及文件分块信息（元数据）的管理由 namenode 节点承担</p>
<p>namenode 是 HDFS 集群主节点，负责维护整个 HDFS 文件系统的目录树，以及每一个路径（文件）所对应的 block 块信息（block 的 id，及所在的 datanode 服务器）</p>
</li>
<li><p>文件的各个 block 的存储管理由 datanode 节点承担</p>
<p>datanode 是 HDFS 集群从节点，每个 block 都可以在多个 datanode 上存储多个副本（可以通过 dfs.replication 设置）</p>
</li>
<li><p>HDFS 是设计成适应一次写入，多次读出的场景，且不支持文件的修改</p>
</li>
</ol>
<h2 id="HDFS-角色说明"><a href="#HDFS-角色说明" class="headerlink" title="HDFS 角色说明"></a>HDFS 角色说明</h2><table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>namenode</td>
<td>接受客户端的读写请求<br>存储元数据信息<br>接收 datanode 心跳报告<br>负载均衡<br>分配数据块的存储节点</td>
</tr>
<tr>
<td>datanode</td>
<td>真正处理客户端的读写请求<br>向 namenode 发送心跳<br>向 namenode 发送块报告<br>真正存储数据<br>副本之间的相互复制</td>
</tr>
<tr>
<td>journalnode</td>
<td>两个 namenode 为了数据同步，会通过一组称作 journalnode 的独立进程相互通信<br>当 active 状态的 namenode 的命名空间有任何修改时，会告知大部分的 journalnode 进程</td>
</tr>
<tr>
<td>客户端</td>
<td>进行数据块的物理切分<br>向 namenode 发送读写请求<br>向 namenode发送读写响应</td>
</tr>
</tbody>
</table>
<h2 id="HDFS-高可用机制"><a href="#HDFS-高可用机制" class="headerlink" title="HDFS 高可用机制"></a>HDFS 高可用机制</h2><p><a href="https://blog.csdn.net/u012736748/article/details/79534019" target="_blank" rel="noopener">HDFS的高可用机制详解（journalnode 及 editlog）</a></p>
<p><a href="https://blog.csdn.net/u012736748/article/details/79541311" target="_blank" rel="noopener">HDFS高可用（HA）之ZKFC详解</a></p>
<h2 id="读数据流程"><a href="#读数据流程" class="headerlink" title="读数据流程"></a>读数据流程</h2><ol>
<li><p>客户端通过调用 FileSyste 对象 DistributedFileSystem（以下简称 DFS） 的 open() 方法带打开希望读取的文件</p>
</li>
<li><p>DFS 对象通过远程调用（RPC）来调用 namenode，以确定文件起始块的位置</p>
<p>namenode 返回存储该数据块副本的 datanod 的地址，datanode 也会根据与客户端的距离来排序（就近原则读取信息）</p>
</li>
<li><p>DFS 类返回一个 FSDataInputStream 对象给客户端用于读取数据，FSDataInputStream 封装 DFSInputStream 对象，该对象管理 datanode 和 namenode 的 I/O</p>
</li>
<li><p>客户端调用 read() 方法</p>
</li>
<li><p>DFSInputStream 连接地址最近的一个 datanode，然后反复调用 read() 方法，将数据从 datanode 中传输到客户端。</p>
</li>
<li><p>读到块末端后，DFSInputStream 关闭连接，并开始寻找下一个最佳的 datanode，执行 4-5-6 步直至读取完成</p>
</li>
<li><p>读取完成后，就调用 close() 方法关闭 FSDataInputStream</p>
</li>
</ol>
<p><img src="/2019/10/09/HDFS-概念/读数据.png" alt="读数据"></p>
<h2 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h2><ol>
<li><p>客户端对 DistributedFileSystem（以下简称 DFS） 对象调用 create() 方法</p>
</li>
<li><p>DFS 对 namenode 创建一个 RPC 调用，在文件系统命名空间中创建一个文件，但没有对应的数据块</p>
<p>namenode 检查文件系统中是否存在这个文件，若不存在且客户端有权限创建，则创建一条记录，反之抛出异常</p>
<p>DFS 向客户端返回一个 FSDataOutputStream 对象，FSDataOutputStream 封装了 DFSOutputStream 对象</p>
</li>
<li><p>客户端调用 write 写数据</p>
</li>
<li><p>DFSOutputStream 将客户端的数据分包写入内部队列，称为<strong>“数据队列”</strong></p>
<p>队列的作用是选择一组合适的 datanode，要求 namenode 分配新的数据块，按照顺序发送数据到 datanode 中</p>
</li>
<li><p>DFSOutputStream 同时维护着一个<strong>“确认队列”</strong>，所有 datanode 确认信息后，数据包才会从确认队列中删除</p>
</li>
<li><p>客户端完成数据写入后调用 close() 方法</p>
</li>
<li><p>联系 namenode 写入完成，等待确认</p>
</li>
</ol>
<p><img src="/2019/10/09/HDFS-概念/写数据.png" alt="写数据"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark Streaming 整合 Flume &amp; Kafka</title>
    <url>/2019/10/05/Spark-Streaming-%E6%95%B4%E5%90%88-Flume-Kafka/</url>
    <content><![CDATA[<ul>
<li>大致流程</li>
<li>使用代码生成 Log4j 日志文件</li>
<li>Flume 配置文件</li>
</ul>
<a id="more"></a>
<h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p><img src="/2019/10/05/Spark-Streaming-整合-Flume-Kafka/Spark Streaming 整合 Flume &amp; Kafka.png" alt="大致流程"></p>
<h2 id="使用代码生成-Log4j-日志文件"><a href="#使用代码生成-Log4j-日志文件" class="headerlink" title="使用代码生成 Log4j 日志文件"></a>使用代码生成 Log4j 日志文件</h2><p>在 log4j 的配置文件中指定将日志文件发送到 flume</p>
<p><strong>Java 代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(LoggerGenerator.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            logger.info(<span class="string">"value : "</span> + index++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>log4j.properties</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=INFO,stdout,flume</span><br><span class="line"></span><br><span class="line">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.target = System.out</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c] [%p] - %m%n</span><br><span class="line"></span><br><span class="line">log4j.appender.flume = org.apache.flume.clients.log4jappender.Log4jAppender</span><br><span class="line">log4j.appender.flume.Hostname = 192.168.10.114</span><br><span class="line">log4j.appender.flume.Port = 41414</span><br><span class="line">log4j.appender.flume.UnsafeMode = true</span><br></pre></td></tr></table></figure>
<h2 id="Flume-配置文件"><a href="#Flume-配置文件" class="headerlink" title="Flume 配置文件"></a>Flume 配置文件</h2><p><strong>streaming.conf</strong>（用来测试 log4j -&gt; flume）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">agent1.sources=avro-source</span><br><span class="line">agent1.channels=logger-channel</span><br><span class="line">agent1.sinks=log-sink</span><br><span class="line"></span><br><span class="line">#define source</span><br><span class="line">agent1.sources.avro-source.type=avro</span><br><span class="line">agent1.sources.avro-source.bind=hadoop000</span><br><span class="line">agent1.sources.avro-source.port=41414</span><br><span class="line"></span><br><span class="line">#define channel</span><br><span class="line">agent1.channels.logger-channel.type=memory</span><br><span class="line"></span><br><span class="line">#define sink</span><br><span class="line">agent1.sinks.log-sink.type=logger</span><br><span class="line"></span><br><span class="line">agent1.sources.avro-source.channels=logger-channel</span><br><span class="line">agent1.sinks.log-sink.channel=logger-channel</span><br></pre></td></tr></table></figure>
<p><strong>streaming2.conf</strong>（log4j -&gt; flume -&gt; kafka)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">agent1.sources=avro-source</span><br><span class="line">agent1.channels=logger-channel</span><br><span class="line">agent1.sinks=kafka-sink</span><br><span class="line"></span><br><span class="line">#define source</span><br><span class="line">agent1.sources.avro-source.type=avro</span><br><span class="line">agent1.sources.avro-source.bind=hadoop000</span><br><span class="line">agent1.sources.avro-source.port=41414</span><br><span class="line"></span><br><span class="line">#define channel</span><br><span class="line">agent1.channels.logger-channel.type=memory</span><br><span class="line"></span><br><span class="line">#define sink</span><br><span class="line">agent1.sinks.kafka-sink.type=org.apache.flume.sink.kafka.KafkaSink</span><br><span class="line">agent1.sinks.kafka-sink.topic = streamingtopic_cty</span><br><span class="line">agent1.sinks.kafka-sink.brokerList = hadoop000:9092</span><br><span class="line">agent1.sinks.kafka-sink.requiredAcks = 1</span><br><span class="line"># 到达 20 条数据才 sink</span><br><span class="line">agent1.sinks.kafka-sink.batchSize = 20</span><br><span class="line"></span><br><span class="line">agent1.sources.avro-source.channels=logger-channel</span><br><span class="line">agent1.sinks.kafka-sink.channel=logger-channel</span><br></pre></td></tr></table></figure>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><strong>KafkaStreamingApp.scala</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 输入参数 192.168.10.114:9092 streamingtopic_cty */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaStreamingApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="type">System</span>.err.println(<span class="string">"Usage: KafkaStreamingApp &lt;brokers&gt; &lt;topics&gt;"</span>)</span><br><span class="line">      <span class="type">System</span>.exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="type">Array</span>(brokers, topics) = args</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"KafkaStreamingApp"</span>).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">    ssc.sparkContext.setLogLevel(<span class="string">"OFF"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topicsSet = topics.split(<span class="string">","</span>).toSet</span><br><span class="line">    <span class="keyword">val</span> kafkaParams = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="string">"metadata.broker.list"</span> -&gt; brokers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> messages = <span class="type">KafkaUtils</span>.createDirectStream[<span class="type">String</span>, <span class="type">String</span>, <span class="type">StringDecoder</span>, <span class="type">StringDecoder</span>](ssc, kafkaParams, topicsSet)</span><br><span class="line"></span><br><span class="line">    messages.map(_._2).count().print()</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Flume</tag>
        <tag>Spark</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试题03</title>
    <url>/2019/10/03/Java%E9%9D%A2%E8%AF%95%E9%A2%9803/</url>
    <content><![CDATA[<ul>
<li>SpringBoot / SpringCloud</li>
<li>MyBatis 模块</li>
<li>Kafka 模块</li>
<li>Zookeeper 模块</li>
<li>MySQL 模块</li>
<li>Redis 模块</li>
<li>JVM 模块</li>
</ul>
<p>题库来源于 <a href="https://www.javazhiyin.com/42272.html" target="_blank" rel="noopener">Java知音</a></p>
<a id="more"></a>
<h2 id="SpringBoot-SpringCloud"><a href="#SpringBoot-SpringCloud" class="headerlink" title="SpringBoot / SpringCloud"></a>SpringBoot / SpringCloud</h2><h3 id="104-什么是-springboot？"><a href="#104-什么是-springboot？" class="headerlink" title="104. 什么是 springboot？"></a>104. 什么是 springboot？</h3><p>springboot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建一斤开发过程的</p>
<h3 id="105-为什么要用-springboot？"><a href="#105-为什么要用-springboot？" class="headerlink" title="105. 为什么要用 springboot？"></a>105. 为什么要用 springboot？</h3><ul>
<li>配置简单</li>
<li>独立运行</li>
<li>自动装配</li>
<li>无代码生成和 xml 配置</li>
<li>提供应用监控</li>
<li>易上手</li>
<li>提升开发效率</li>
</ul>
<h3 id="106-springboot-核心配置文件是什么？"><a href="#106-springboot-核心配置文件是什么？" class="headerlink" title="106. springboot 核心配置文件是什么？"></a>106. springboot 核心配置文件是什么？</h3><ul>
<li>bootstrap（.yml 或者 .properties）：bootstrap 有父 ApplicationContext 加载的，比 application 优先加载，且 bootstrap 里面的属性不能被覆盖</li>
<li>application（.yml 获取 .properties）：用于 springboot 项目的自动化配置</li>
</ul>
<h3 id="107-springboot-配置文件有哪几种类型？他们有什么区别？"><a href="#107-springboot-配置文件有哪几种类型？他们有什么区别？" class="headerlink" title="107. springboot 配置文件有哪几种类型？他们有什么区别？"></a>107. springboot 配置文件有哪几种类型？他们有什么区别？</h3><p>配置文件有 .properties 和 .yml 格式，主要区别是熟悉风格不同</p>
<p>yml 格式不支持 @PropertySource 注解导入</p>
<h3 id="108-springboot-有哪些方式可以实现热部署？"><a href="#108-springboot-有哪些方式可以实现热部署？" class="headerlink" title="108. springboot 有哪些方式可以实现热部署？"></a>108. springboot 有哪些方式可以实现热部署？</h3><p>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring.devtools.restart.enable 设置为 true</p>
<p>使用 Intellij Idea 编译器，勾选上自动编译或手动重新编译</p>
<h3 id="109-JPA-全称-Java-Persistence-API，是-Java-持久化接口规范，hibernate-属于-jpa-的具体实现"><a href="#109-JPA-全称-Java-Persistence-API，是-Java-持久化接口规范，hibernate-属于-jpa-的具体实现" class="headerlink" title="109. JPA 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现"></a>109. JPA 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现</h3><h3 id="110-什么是-springcloud？"><a href="#110-什么是-springcloud？" class="headerlink" title="110. 什么是 springcloud？"></a>110. 什么是 springcloud？</h3><p>springcloud 是一系列框架的有序集合，它利用 springboot 的开发便利性，简化了分布式系统基础设施的开发，如服务发现注册，配置中心，消息总线，负载均衡、断路器、数据监控等，都可以用 springboot 的开发风格做到意见启动和部署</p>
<h3 id="111-springcloud-阻断器的作用是什么？"><a href="#111-springcloud-阻断器的作用是什么？" class="headerlink" title="111. springcloud 阻断器的作用是什么？"></a>111. springcloud 阻断器的作用是什么？</h3><p>在分布式架构中，住短期模式的作用也是类似的，当某个服务单元发生故障之后，通过断路器的故障监控，向调用方返回一个错误响应，而不是长时间的等待，这样就不会使得线程因调用故障服务长时间占用不释放，避免了故障在分布式系统中的蔓延</p>
<h2 id="MyBatis-模块"><a href="#MyBatis-模块" class="headerlink" title="MyBatis 模块"></a>MyBatis 模块</h2><h3 id="125-MyBatis-中-和-的区别是什么？"><a href="#125-MyBatis-中-和-的区别是什么？" class="headerlink" title="125. MyBatis 中 #{} 和 ${} 的区别是什么？"></a>125. MyBatis 中 #{} 和 ${} 的区别是什么？</h3><p>#{} 是预编译处理，${} 是字符串替换</p>
<p>再使用 #{} 时，MyBatis 会将 SQL 中的 #{} 替换成 “?”，配合 PreparedStatement 的 set 方法赋值，有效防止 SQL 注入，保证程序的运行安全</p>
<h3 id="126-MyBatis-有几种分页模式？"><a href="#126-MyBatis-有几种分页模式？" class="headerlink" title="126. MyBatis 有几种分页模式？"></a>126. MyBatis 有几种分页模式？</h3><ul>
<li><strong>逻辑分页：</strong>使用 MyBatis 自带的 RowBounds 进行分页，他是一次性查询很多数据，然后在数据中再进行检索</li>
<li><strong>物理分页：</strong>自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式</li>
</ul>
<h3 id="127-RowBounds-是一次性查询全部结果吗？"><a href="#127-RowBounds-是一次性查询全部结果吗？" class="headerlink" title="127. RowBounds 是一次性查询全部结果吗？"></a>127. RowBounds 是一次性查询全部结果吗？</h3><p>RowBounds 表面是在所有数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库中查询多少条数据，会在执行 next() 的时候，去查询更多的数据</p>
<p>对于 jdbc 来说，当调用 next() 的时候回自动完成查询工作，有效防止内存溢出</p>
<h3 id="128-MyBatis-逻辑分页和物理分页的区别？"><a href="#128-MyBatis-逻辑分页和物理分页的区别？" class="headerlink" title="128. MyBatis 逻辑分页和物理分页的区别？"></a>128. MyBatis 逻辑分页和物理分页的区别？</h3><p>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据，弊端就是需要消耗大量的内存，有内存溢出的风险、对数据塔里较大</p>
<p>物理分页是从数据库中查询指定条数的数据，弥补了一次性全部查出所有数据的种种缺点</p>
<h3 id="129-MyBatis-延迟加载的原理是什么？"><a href="#129-MyBatis-延迟加载的原理是什么？" class="headerlink" title="129. MyBatis 延迟加载的原理是什么？"></a>129. MyBatis 延迟加载的原理是什么？</h3><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可</p>
<p>延迟加载的原理是调用的时候触发加载，而不是在初始化的时候就加载信息</p>
<h3 id="130-说一下-MyBatis-的一级缓存和二级缓存"><a href="#130-说一下-MyBatis-的一级缓存和二级缓存" class="headerlink" title="130. 说一下 MyBatis 的一级缓存和二级缓存"></a>130. 说一下 MyBatis 的一级缓存和二级缓存</h3><ul>
<li>一级缓存：基于 PerpetualCache 和 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的</li>
<li>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个 SQLSession 之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，使用二级缓存属性需要实现 Serializable 序列化接口</li>
</ul>
<p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库</p>
<p>缓存更新机制：当某一作用域（一级缓存 Session / 二级缓存 Mapper）进行了 C / U / D 操作之后，默认该作用域下所有 select 中的缓存将被 clear</p>
<h3 id="131-MyBatis-和-hibernate-区别有哪些？"><a href="#131-MyBatis-和-hibernate-区别有哪些？" class="headerlink" title="131. MyBatis 和 hibernate 区别有哪些？"></a>131. MyBatis 和 hibernate 区别有哪些？</h3><ul>
<li><strong>灵活性：</strong>MyBatis 灵活</li>
<li><strong>可移植性：</strong>MyBatis 需要自己手写 SQL，每个数据库不同，SQL也不同，移植性较差</li>
<li><strong>学习和使用门槛：</strong>MyBatis 简单，入门和使用快</li>
<li><strong>二级缓存：</strong>hibernate 有更好的二级缓存，且可以自行更换为第三方的二级缓存</li>
</ul>
<h3 id="132-MyBatis-有哪些执行器？"><a href="#132-MyBatis-有哪些执行器？" class="headerlink" title="132. MyBatis 有哪些执行器？"></a>132. MyBatis 有哪些执行器？</h3><ul>
<li><strong>SimpleExecutor：</strong>每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象</li>
<li><strong>ReuseExecutor：</strong>执行 update 或 select，以 SQL 作为 key 查找 Statement，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简单地说就是重复使用 Statement 对象</li>
<li><strong>BatchExecutor：</strong>执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理（addBatch()）中，等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象，每个 Statement 对象都是 addBatch() 完毕后，等待逐一执行 executeBatch() 批处理，与 jdbc 批处理相同</li>
</ul>
<h3 id="133-MyBatis-分页插件的实现原理是什么？"><a href="#133-MyBatis-分页插件的实现原理是什么？" class="headerlink" title="133. MyBatis 分页插件的实现原理是什么？"></a>133. MyBatis 分页插件的实现原理是什么？</h3><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，添加对应的物理分页语句和物理分页参数</p>
<h2 id="Kafka-模块"><a href="#Kafka-模块" class="headerlink" title="Kafka 模块"></a>Kafka 模块</h2><h3 id="152-kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#152-kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="152. kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>152. kafka 可以脱离 zookeeper 单独使用吗？为什么？</h3><p>不能，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器</p>
<h3 id="153-kafka-有几种数据保留的策略？"><a href="#153-kafka-有几种数据保留的策略？" class="headerlink" title="153. kafka 有几种数据保留的策略？"></a>153. kafka 有几种数据保留的策略？</h3><ul>
<li><strong>按照过期时间保留</strong></li>
<li><strong>按照存储的消息大小保留</strong></li>
</ul>
<h3 id="154-kafka-同时设置了-7-天和-10G-清楚数据，到第五天的时候消息达到了-10G，kafka-将如何处理？"><a href="#154-kafka-同时设置了-7-天和-10G-清楚数据，到第五天的时候消息达到了-10G，kafka-将如何处理？" class="headerlink" title="154. kafka 同时设置了 7 天和 10G 清楚数据，到第五天的时候消息达到了 10G，kafka 将如何处理？"></a>154. kafka 同时设置了 7 天和 10G 清楚数据，到第五天的时候消息达到了 10G，kafka 将如何处理？</h3><p>kafka 会执行数据清楚工作，时间和大小不论条件是否满足，都会清空数据</p>
<h3 id="155-什么情况下会导致-kafka-运行变慢？"><a href="#155-什么情况下会导致-kafka-运行变慢？" class="headerlink" title="155. 什么情况下会导致 kafka 运行变慢？"></a>155. 什么情况下会导致 kafka 运行变慢？</h3><ul>
<li>CPU 性能瓶颈</li>
<li>磁盘读写瓶颈</li>
<li>网络瓶颈</li>
</ul>
<h3 id="156-使用-kafka-集群需要注意什么？"><a href="#156-使用-kafka-集群需要注意什么？" class="headerlink" title="156. 使用 kafka 集群需要注意什么？"></a>156. 使用 kafka 集群需要注意什么？</h3><p>集群的数量不是越多越好，最好不要超过 7 个，节点越多，消息复制需要的时间就越长，整个群组的吞吐量就会越低</p>
<p>集群数量最好是单数，因为超过一半故障，集群就不能用了，设置为单数容错率更高</p>
<h2 id="Zookeeper-模块"><a href="#Zookeeper-模块" class="headerlink" title="Zookeeper 模块"></a>Zookeeper 模块</h2><h3 id="157-Zookeeper-是什么？"><a href="#157-Zookeeper-是什么？" class="headerlink" title="157. Zookeeper 是什么？"></a>157. Zookeeper 是什么？</h3><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务器，是 google chubby 开源实现，是 hadoop 和 hbase 的重要组件。它是一个分布式应用提供一致性服务的软件，提供的功能包括：配置维护，域名服务，分布式同步，租服务等</p>
<h3 id="158-zookeeper-都有哪些功能？"><a href="#158-zookeeper-都有哪些功能？" class="headerlink" title="158. zookeeper 都有哪些功能？"></a>158. zookeeper 都有哪些功能？</h3><ul>
<li><strong>集群管理：</strong>监控节点存活状态</li>
<li><strong>主节点选举：</strong>主节点挂掉之后，可以从备用的节点开始新一轮选主，注解点选举说的就是这个选举过程，使用 zookeeper 可以协助完成这个过程</li>
<li><strong>分布式锁：</strong>zookeeper 提供两种锁，<strong>独占锁</strong>和<strong>共享锁</strong>。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线程同时读同一个资源，如果要使用写锁，也只能有一个线程使用。zookeeper 可以对分布式锁进行控制</li>
<li><strong>命名服务：</strong>在分布式系统中，通过使用命名服务，客户端应用程序能够根据指定名字来获取资源或服务的地址，提供者等信息</li>
</ul>
<h3 id="159-zookeeper-有几种部署模式？"><a href="#159-zookeeper-有几种部署模式？" class="headerlink" title="159. zookeeper 有几种部署模式？"></a>159. zookeeper 有几种部署模式？</h3><ul>
<li>单机部署</li>
<li>集群部署</li>
<li>伪集群部署</li>
</ul>
<h3 id="160-zookeeper-怎么保证主从节点的状态同步？"><a href="#160-zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="160. zookeeper 怎么保证主从节点的状态同步？"></a>160. zookeeper 怎么保证主从节点的状态同步？</h3><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步，实现这个机制的协议叫做 zab 协议，zab 协议有两种：</p>
<ul>
<li>恢复模式（选主）</li>
<li>广播模式（同步）</li>
</ul>
<p>当服务服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选择出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了，状态同步保证了 leader 和 server 具有相同的系统状态</p>
<h3 id="161-集群中为什么要有主节点？"><a href="#161-集群中为什么要有主节点？" class="headerlink" title="161. 集群中为什么要有主节点？"></a>161. 集群中为什么要有主节点？</h3><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点</p>
<h3 id="162-集群中有-3-太服务器，其中一个节点宕机，zookeeper-还可以使用吗？"><a href="#162-集群中有-3-太服务器，其中一个节点宕机，zookeeper-还可以使用吗？" class="headerlink" title="162. 集群中有 3 太服务器，其中一个节点宕机，zookeeper 还可以使用吗？"></a>162. 集群中有 3 太服务器，其中一个节点宕机，zookeeper 还可以使用吗？</h3><p>可以，单数服务器只要没有超过一半的服务器宕机，就可以继续使用</p>
<h3 id="163-说一下-zookeeper-的通知机制"><a href="#163-说一下-zookeeper-的通知机制" class="headerlink" title="163. 说一下 zookeeper 的通知机制"></a>163. 说一下 zookeeper 的通知机制</h3><p>客户端会对某一个 znode 建立一个 watcher 时间，当该 znode 发生变化时，这些客户端就会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变</p>
<h2 id="MySQL-模块"><a href="#MySQL-模块" class="headerlink" title="MySQL 模块"></a>MySQL 模块</h2><h3 id="164-数据库的三范式是什么？"><a href="#164-数据库的三范式是什么？" class="headerlink" title="164. 数据库的三范式是什么？"></a>164. 数据库的三范式是什么？</h3><ul>
<li>第一范式（1NF）：强调的是列的原子性，<strong>列不可再分</strong></li>
<li>第二范式（2NF）：<strong>属性完全依赖于主键</strong></li>
<li>第三范式（3NF）：<strong>属性不依赖于其它非主属性    属性直接依赖于主键</strong></li>
</ul>
<h3 id="165-一张自增表里面总共有-7-条数据，删除最后两条，重启-MySQL-数据库，又插入一条数据，id-是多少？"><a href="#165-一张自增表里面总共有-7-条数据，删除最后两条，重启-MySQL-数据库，又插入一条数据，id-是多少？" class="headerlink" title="165. 一张自增表里面总共有 7 条数据，删除最后两条，重启 MySQL 数据库，又插入一条数据，id 是多少？"></a>165. 一张自增表里面总共有 7 条数据，删除最后两条，重启 MySQL 数据库，又插入一条数据，id 是多少？</h3><p>表类型如果是 MyISAM，id 就是 8</p>
<p>表类型如果是 InnoDB，id 就是 6</p>
<p>InnoDB 表只会吧自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失</p>
<h3 id="166-如何获取当前数据库版本？"><a href="#166-如何获取当前数据库版本？" class="headerlink" title="166. 如何获取当前数据库版本？"></a>166. 如何获取当前数据库版本？</h3><p>使用 select version() 获取当前 MySQL 数据库版本</p>
<h3 id="167-说下-ACID-是什么？"><a href="#167-说下-ACID-是什么？" class="headerlink" title="167. 说下 ACID 是什么？"></a>167. 说下 ACID 是什么？</h3><ul>
<li><strong>Atomicity（原子性）：</strong>一个事务中的所有操作，或者全部完成，获取全部不完成，不会结束在中间某个环节，事务在执行过程中发生错误，会被恢复（Rollback）到事务开始之前的状态，就像这个事务从来没有执行过一样。<strong>即事务不可分割，不可简约</strong></li>
<li><strong>Consistency（一致性）：</strong>在事务开始之前和事务结束之后，数据库的完整性没有被破坏，这表示<strong>写入的资料必须完全复合物所有的预设约束、触发器、级联回滚等</strong></li>
<li><strong>Isolation（隔离性）：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括：<strong>读未提交</strong>，读提交，<strong>可重复读</strong>和<strong>串行化</strong>。</li>
<li><strong>Durability（持久性）：</strong>事务处理结束后对数据的修改是永久的，即便系统故障也不会丢失。</li>
</ul>
<h3 id="168-char-和-varchar-的区别是什么？"><a href="#168-char-和-varchar-的区别是什么？" class="headerlink" title="168. char 和 varchar 的区别是什么？"></a>168. char 和 varchar 的区别是什么？</h3><ul>
<li>char(n)：固定长度类型<ul>
<li>优点：效率高</li>
<li>缺点：占用空间</li>
<li>适用场景：存储密码的 md5 值，固定长度的使用 char 非常合适</li>
</ul>
</li>
<li>varchar(n)：可变长度，存储的值是每个值占用的字节，加上一个用来记录其长度的字节长度</li>
</ul>
<p>所以，从空间上考虑 varchar 比较合适；从效率上考虑 char 比较合适。二者使用需要权衡</p>
<h3 id="169-float-和-double-的区别是什么？"><a href="#169-float-和-double-的区别是什么？" class="headerlink" title="169. float 和 double 的区别是什么？"></a>169. float 和 double 的区别是什么？</h3><ul>
<li>float 最多可以存储 8 位的十进制数，并且在内存中占 4 字节。</li>
<li>double 最多可以存储 16 位的十进制数，在内存中占 8 字节</li>
</ul>
<h3 id="170-MySQL-的内连接、左连接、右连接有什么区别？"><a href="#170-MySQL-的内连接、左连接、右连接有什么区别？" class="headerlink" title="170. MySQL 的内连接、左连接、右连接有什么区别？"></a>170. MySQL 的内连接、左连接、右连接有什么区别？</h3><p>内连接关键字：inner join</p>
<p>左连接关键字：left join</p>
<p>右连接关键字：right join</p>
<p>内连接是把匹配的关联数据显示出来</p>
<p>左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接相反</p>
<h3 id="171-MySQL-的索引怎么实现的？"><a href="#171-MySQL-的索引怎么实现的？" class="headerlink" title="171. MySQL 的索引怎么实现的？"></a>171. MySQL 的索引怎么实现的？</h3><p>索引是满足某种特定查找算法的数据结构，而这些数据结构和以某种方式指向数据，从而实现高效查找数据</p>
<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同。但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以达到二分法的性能，找到数据区域之后就找到了完整的数据结构了</p>
<h3 id="172-怎么验证买-MySQL-的索引是否满足需求？"><a href="#172-怎么验证买-MySQL-的索引是否满足需求？" class="headerlink" title="172. 怎么验证买 MySQL 的索引是否满足需求？"></a>172. 怎么验证买 MySQL 的索引是否满足需求？</h3><p>使用 explain 查看 SQL 是如何执行查询的，从而分析索引是否满足需求</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">type</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="173-说一下数据库的事务隔离"><a href="#173-说一下数据库的事务隔离" class="headerlink" title="173. 说一下数据库的事务隔离?"></a>173. 说一下数据库的事务隔离?</h3><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ</p>
<p>可用的配置值：<strong>READ-UNCOMMITTED</strong>、<strong>READ-COMMITTED</strong>、<strong>REPEATABLE-READ</strong>、<strong>SERIALIZABLE</strong></p>
<ul>
<li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）</li>
<li>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li>
<li>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）</li>
<li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读</li>
<li>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A</li>
<li>不可重复读 ：是指在一个事务内，多次读同一数据。</li>
<li>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</li>
</ul>
<h3 id="174-说一下-MySQL-常用的引擎？"><a href="#174-说一下-MySQL-常用的引擎？" class="headerlink" title="174.说一下 MySQL 常用的引擎？"></a>174.说一下 MySQL 常用的引擎？</h3><ul>
<li>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(<em>) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</em></li>
<li>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</li>
</ul>
<h3 id="175-说一下-MySQL-的行锁和表锁？"><a href="#175-说一下-MySQL-的行锁和表锁？" class="headerlink" title="175.说一下 MySQL 的行锁和表锁？"></a>175.说一下 MySQL 的行锁和表锁？</h3><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>
<ul>
<li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li>
<li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li>
</ul>
<h3 id="176-说一下乐观锁和悲观锁？"><a href="#176-说一下乐观锁和悲观锁？" class="headerlink" title="176.说一下乐观锁和悲观锁？"></a>176.说一下乐观锁和悲观锁？</h3><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据</p>
<p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁，这样别人想拿这条数据就会阻止，这个锁被释放。</p>
<h3 id="177-MySQL-问题排查都有哪些手段？"><a href="#177-MySQL-问题排查都有哪些手段？" class="headerlink" title="177.MySQL 问题排查都有哪些手段？"></a>177.MySQL 问题排查都有哪些手段？</h3><ul>
<li>使用 show processlist 命令查看当前所有连接信息。</li>
<li>使用 explain 命令查询 SQL 语句执行计划。</li>
<li>开启慢查询日志，查看慢查询的 SQL。</li>
</ul>
<h3 id="178-如何做-MySQL-的性能优化？"><a href="#178-如何做-MySQL-的性能优化？" class="headerlink" title="178.如何做 MySQL 的性能优化？"></a>178.如何做 MySQL 的性能优化？</h3><ul>
<li>为搜索字段创建索引。</li>
<li>避免使用 select *，列出需要查询的字段。</li>
<li>垂直分割分表。</li>
<li>选择正确的存储引擎。</li>
</ul>
<h2 id="Redis-模块"><a href="#Redis-模块" class="headerlink" title="Redis 模块"></a>Redis 模块</h2><h3 id="179-Redis-是什么？都有哪些使用场景？"><a href="#179-Redis-是什么？都有哪些使用场景？" class="headerlink" title="179.Redis 是什么？都有哪些使用场景？"></a>179.Redis 是什么？都有哪些使用场景？</h3><p>Redis 是一个使用 C 语言开发的高速缓存数据库</p>
<p>Redis 使用场景：</p>
<ul>
<li>记录帖子点赞数、点击数、评论数</li>
<li>缓存近期热帖</li>
<li>缓存文章详情信息；</li>
<li>记录用户会话信息</li>
</ul>
<h3 id="180-Redis-有哪些功能？"><a href="#180-Redis-有哪些功能？" class="headerlink" title="180.Redis 有哪些功能？"></a>180.Redis 有哪些功能？</h3><ul>
<li>数据缓存功能</li>
<li>分布式锁的功能</li>
<li>支持数据持久化</li>
<li>支持事务</li>
<li>支持消息队列</li>
</ul>
<h3 id="182-Redis-为什么是单线程的？"><a href="#182-Redis-为什么是单线程的？" class="headerlink" title="182.Redis 为什么是单线程的？"></a>182.Redis 为什么是单线程的？</h3><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽</p>
<h3 id="183-什么是缓存穿透？怎么解决？"><a href="#183-什么是缓存穿透？怎么解决？" class="headerlink" title="183.什么是缓存穿透？怎么解决？"></a>183.什么是缓存穿透？怎么解决？</h3><ul>
<li>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</li>
<li>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</li>
</ul>
<h3 id="184-Redis-支持的数据类型有哪些？"><a href="#184-Redis-支持的数据类型有哪些？" class="headerlink" title="184.Redis 支持的数据类型有哪些？"></a>184.Redis 支持的数据类型有哪些？</h3><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）</p>
<h3 id="185-Redis-支持的-Java-客户端都有哪些？"><a href="#185-Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="185.Redis 支持的 Java 客户端都有哪些？"></a>185.Redis 支持的 Java 客户端都有哪些？</h3><p>支持的 Java 客户端有 Redisson、Jedis、lettuce 等</p>
<h3 id="187-怎么保证缓存和数据库数据的一致性？"><a href="#187-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="187.怎么保证缓存和数据库数据的一致性？"></a>187.怎么保证缓存和数据库数据的一致性？</h3><ol>
<li>合理设置缓存的过期时间。</li>
<li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</li>
</ol>
<h3 id="188-Redis-持久化有几种方式？"><a href="#188-Redis-持久化有几种方式？" class="headerlink" title="188.Redis 持久化有几种方式？"></a>188.Redis 持久化有几种方式？</h3><ol>
<li>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</li>
<li>AOF（Append Only File）：每一个收到的写命令都通过 write 函数追加到文件中。</li>
</ol>
<h3 id="190-Redis-分布式锁有什么缺陷？"><a href="#190-Redis-分布式锁有什么缺陷？" class="headerlink" title="190.Redis 分布式锁有什么缺陷？"></a>190.Redis 分布式锁有什么缺陷？</h3><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题</p>
<h3 id="191-Redis-如何做内存优化？"><a href="#191-Redis-如何做内存优化？" class="headerlink" title="191.Redis 如何做内存优化？"></a>191.Redis 如何做内存优化？</h3><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p>
<h3 id="193-Redis-常见的性能问题有哪些？该如何解决？"><a href="#193-Redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="193.Redis 常见的性能问题有哪些？该如何解决？"></a>193.Redis 常见的性能问题有哪些？该如何解决？</h3><p>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照</p>
<p>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</p>
<h2 id="JVM-模块"><a href="#JVM-模块" class="headerlink" title="JVM 模块"></a>JVM 模块</h2><h3 id="194-说一下-JVM-的主要组成部分？及其作用？"><a href="#194-说一下-JVM-的主要组成部分？及其作用？" class="headerlink" title="194.说一下 JVM 的主要组成部分？及其作用？"></a>194.说一下 JVM 的主要组成部分？及其作用？</h3><ul>
<li>类加载器（ClassLoader）</li>
<li>运行时数据区（Runtime Data Area）</li>
<li>执行引擎（Execution Engine）</li>
<li>本地库接口（Native Interface）</li>
<li>组件的作用：首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</li>
</ul>
<h3 id="195-说一下-JVM-运行时数据区？"><a href="#195-说一下-JVM-运行时数据区？" class="headerlink" title="195.说一下 JVM 运行时数据区？"></a>195.说一下 JVM 运行时数据区？</h3><ul>
<li><strong>程序计数器（Program Counter Register）：</strong>当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成</li>
<li><strong>Java 虚拟机栈（Java Virtual Machine Stacks）：</strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li>
<li><strong>本地方法栈（Native Method Stack）：</strong>与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的</li>
<li><strong>Java 堆（Java Heap）：</strong>Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存</li>
<li><strong>方法区（Methed Area）：</strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据</li>
</ul>
<h3 id="196-说一下堆栈的区别？"><a href="#196-说一下堆栈的区别？" class="headerlink" title="196.说一下堆栈的区别？"></a>196.说一下堆栈的区别？</h3><ul>
<li>功能方面：堆是用来存放对象的，栈是用来执行程序的。</li>
<li>共享性：堆是线程共享的，栈是线程私有的。</li>
<li>空间大小：堆大小远远大于栈。</li>
</ul>
<h3 id="197-队列和栈是什么？有什么区别？"><a href="#197-队列和栈是什么？有什么区别？" class="headerlink" title="197.队列和栈是什么？有什么区别？"></a>197.队列和栈是什么？有什么区别？</h3><p>队列和栈都是被<strong>用来预存储数据的</strong></p>
<p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素</p>
<p>栈和队列很相似，但它运行对元素进行后进先出进行检索</p>
<h3 id="198-什么是双亲委派模型？"><a href="#198-什么是双亲委派模型？" class="headerlink" title="198.什么是双亲委派模型？"></a>198.什么是双亲委派模型？</h3><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身统一确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p>类加载器分类：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li>
<li>其他类加载器：<ul>
<li>扩展类加载器（Extension ClassLoader）：负责加载libext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li>
<li>应用程序类加载器（Application ClassLoader）：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器</li>
</ul>
</li>
</ul>
<p><strong>双亲委派模型：</strong>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<h3 id="199-说一下类装载的执行过程？"><a href="#199-说一下类装载的执行过程？" class="headerlink" title="199.说一下类装载的执行过程？"></a>199.说一下类装载的执行过程？</h3><ol>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>检查：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作；</li>
</ol>
<h3 id="200-怎么判断对象是否可以被回收？"><a href="#200-怎么判断对象是否可以被回收？" class="headerlink" title="200.怎么判断对象是否可以被回收？"></a>200.怎么判断对象是否可以被回收？</h3><ul>
<li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。<strong>它有一个缺点不能解决循环引用的问题</strong></li>
<li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的</li>
</ul>
<h3 id="201-Java-中都有哪些引用类型？"><a href="#201-Java-中都有哪些引用类型？" class="headerlink" title="201.Java 中都有哪些引用类型？"></a>201.Java 中都有哪些引用类型？</h3><ul>
<li>强引用：发生 gc 的时候不会被回收。</li>
<li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收</li>
<li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li>
<li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 现虚引用，虚引用的用途是在 gc 时返回一个通知</li>
</ul>
<h3 id="202-说一下-JVM-有哪些垃圾回收算法？"><a href="#202-说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="202.说一下 JVM 有哪些垃圾回收算法？"></a>202.说一下 JVM 有哪些垃圾回收算法？</h3><ul>
<li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片</li>
<li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存</li>
<li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半</li>
<li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法</li>
</ul>
<h3 id="203-说一下-JVM-有哪些垃圾回收器？"><a href="#203-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="203.说一下 JVM 有哪些垃圾回收器？"></a>203.说一下 JVM 有哪些垃圾回收器？</h3><ul>
<li>Serial：最早的单线程串行垃圾回收器。</li>
<li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li>
<li>ParNew：是 Serial 的多线程版本。</li>
<li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li>
<li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存</li>
</ul>
<p>回收算法。</p>
<ul>
<li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li>
<li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li>
</ul>
<h3 id="205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h3><p>新生代回收器：Serial、ParNew、Parallel Scavenge</p>
<p>老年代回收器：Serial Old、Parallel Old、CMS</p>
<p>整堆回收器：G1</p>
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark Streaming 整合 Kafka</title>
    <url>/2019/10/02/Spark-Streaming-%E6%95%B4%E5%90%88-Kafka/</url>
    <content><![CDATA[<ul>
<li>使用版本</li>
<li>Receiver-based</li>
<li>Direct Approach (No Receivers) 推荐</li>
<li>指定偏移量读取 Kafka 信息</li>
</ul>
<a id="more"></a>
<h2 id="使用版本"><a href="#使用版本" class="headerlink" title="使用版本"></a>使用版本</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-streaming-kafka-0-8_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spark.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 个人感觉 10 版本比较好用 但是下面的 API 就不一样了 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 官网上有详细文档，为了保证工程一致性，下面的 API使用 8 版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-streaming-kafka-0-10_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spark.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Receiver-based"><a href="#Receiver-based" class="headerlink" title="Receiver-based"></a>Receiver-based</h2><p>这种方法使用接收器来接收数据。接收器是使用 Kafka 高级消费者 API 实现的；与所有接收器一样，通过接收器从 Kafka 接收的数据存储在 Spark 执行器中，然后由 Spark Streaming 启动的作业处理数据</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li>启动 ZK</li>
<li>启动 Kafka</li>
<li>创建 topic（kafka_streaming_topic_cty）</li>
</ol>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author Chentyit</span></span><br><span class="line"><span class="comment"> * @Date 2019/10/2 18:21</span></span><br><span class="line"><span class="comment"> * @Description: SparkStreaming 对接 Kafka —— Receiver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaReceiverWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">System</span>.err.println(<span class="string">"KafkaReceiverWordCount &lt;zkQuorum&gt; &lt;group&gt; &lt;topics&gt; &lt;numThreads&gt;"</span>)</span><br><span class="line">            <span class="type">System</span>.exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> <span class="type">Array</span>(zkQuorum, group, topics, numThreads) = args</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> topicMap = topics.split(<span class="string">","</span>).map((_, numThreads.toInt)).toMap</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"KafkaReceiverWordCount"</span>)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">        ssc.sparkContext.setLogLevel(<span class="string">"OFF"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> messages = <span class="type">KafkaUtils</span>.createStream(ssc, zkQuorum, group, topicMap)</span><br><span class="line">        messages map(_._2) flatMap(_.split(<span class="string">" "</span>)) map((_, <span class="number">1</span>)) reduceByKey(_ + _) print()</span><br><span class="line"></span><br><span class="line">        ssc.start()</span><br><span class="line">        ssc.awaitTermination()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提交集群运行"><a href="#提交集群运行" class="headerlink" title="提交集群运行"></a>提交集群运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spark-submit \</span><br><span class="line">--class com.imooc.spark.KafkaReceiverWordCount \</span><br><span class="line">--master local[2] \</span><br><span class="line">--name KafkaReceiverWordCount \</span><br><span class="line"><span class="meta">#</span> 这个必须得加，在生产环境中需要用 maven 下载好 jar 包直接添加到 kafka 的 lib 里面</span><br><span class="line">--packages org.apache.spark:spark-streaming-kafka-0-8_2.11:2.2.0 \</span><br><span class="line">/home/hadoop/lib/sparktrain-1.0.jar  hadoop000:2181 test kafka_streaming_topic 1</span><br></pre></td></tr></table></figure>
<h2 id="Direct-Approach-No-Receivers-推荐"><a href="#Direct-Approach-No-Receivers-推荐" class="headerlink" title="Direct Approach (No Receivers) 推荐"></a>Direct Approach (No Receivers) 推荐</h2><p>与基于接收器的方法（即方法1）相比，该方法具有以下优点：（官网翻译）</p>
<ul>
<li><strong>简化的并行性：</strong>无需创建多个输入Kafka流并将它们合并。使用 directStream，Spark Streaming 将创建与要使用的Kafka分区一样多的 RDD 分区，所有这些分区都将从 Kafka 并行读取数据。因此，Kafka 和 RDD 分区之间存在一对一的映射，这更易于理解和调整</li>
<li><strong>效率：在第一种方法中，要实现零数据丢失，需要将数据存储在预写日志中</strong>，从而进一步复制数据。这实际上是低效的，因为数据被有效地复制了两次-一次是通过 Kafka 复制，另一次是通过 “预写日志” 复制。第二种方法消除了该问题，因为没有接收器，因此不需要预写日志。<strong>只要您有足够的 Kafka 保留时间，就可以从 Kafka 中恢复信息</strong>。</li>
<li><strong>只执行一次精确的语义：</strong>第一种方法使用Kafka的高级 API 将偏移量存储在 Zookeeper 中。传统上，这是从 Kafka 消费数据的方式。尽管这种方法（与预写日志结合使用）可以确保零数据丢失（即至少一次语义），但在某些故障下某些记录可能会被消耗两次的可能性很小。发生这种情况是由于 Spark Streaming 可靠接收的数据与 Zookeeper 跟踪的偏移量之间存在不一致。因此，在第二种方法中，我们使用不使用 Zookeeper 的简单 Kafka API。Spark Streaming 在其检查点内跟踪偏移。这样可以消除 Spark Streaming 与 Zookeeper / Kafka 之间的不一致，因此即使出现故障，Spark Streaming 也会有效地一次接收每条记录。为了获得结果输出的一次语义，将数据保存到外部数据存储的输出操作必须是幂等的，或者是保存结果和偏移量的原子事务（请参见主程序中的输出操作的语义）有关更多信息的指南）</li>
</ul>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author Chentyit</span></span><br><span class="line"><span class="comment"> * @Date 2019/10/2 19:12</span></span><br><span class="line"><span class="comment"> * @Description: SparkStreaming 对接 Kafka —— Direct</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaDirectWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">System</span>.err.println(<span class="string">"Usage: KafkaDirectWordCount &lt;brokers&gt; &lt;topics&gt;"</span>)</span><br><span class="line">            <span class="type">System</span>.exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> <span class="type">Array</span>(brokers, topics) = args</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"KafkaDirectWordCount"</span>).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">        ssc.sparkContext.setLogLevel(<span class="string">"OFF"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> topicsSet = topics.split(<span class="string">","</span>).toSet</span><br><span class="line">        <span class="keyword">val</span> kafkaParams = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="string">"metadata.broker.list"</span> -&gt; brokers)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> messages = <span class="type">KafkaUtils</span>.createDirectStream[<span class="type">String</span>, <span class="type">String</span>, <span class="type">StringDecoder</span>, <span class="type">StringDecoder</span>](ssc, kafkaParams, topicsSet)</span><br><span class="line"></span><br><span class="line">        messages.map(_._2).flatMap(_.split(<span class="string">" "</span>)).map((_, <span class="number">1</span>)).reduceByKey(_ + _).print()</span><br><span class="line"></span><br><span class="line">        ssc.start()</span><br><span class="line">        ssc.awaitTermination()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指定偏移量读取-Kafka-信息"><a href="#指定偏移量读取-Kafka-信息" class="headerlink" title="指定偏移量读取 Kafka 信息"></a>指定偏移量读取 Kafka 信息</h2><p><strong>代码示例</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Offset02App</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> kafkaParams = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>](</span><br><span class="line">        <span class="string">"metadata.broker.list"</span> -&gt; <span class="string">"192.168.1.8:9092"</span>,</span><br><span class="line">        <span class="string">"auto.offset.reset"</span> -&gt; <span class="string">"smallest"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> topics = <span class="string">"imooc_cty_offset"</span>.split(<span class="string">", "</span>).toSet</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> checkpointDirectory = <span class="string">"E:\\test\\ck_point"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionToCreateContext</span></span>(): <span class="type">StreamingContext</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">10</span>))</span><br><span class="line">        ssc.sparkContext.setLogLevel(<span class="string">"OFF"</span>)</span><br><span class="line">        <span class="keyword">val</span> messages = <span class="type">KafkaUtils</span>.createDirectStream[<span class="type">String</span>, <span class="type">String</span>, <span class="type">StringDecoder</span>, <span class="type">StringDecoder</span>](ssc, kafkaParams, topics)</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * set checkpoint directory</span></span><br><span class="line"><span class="comment">         * 将偏移量存储到外部介质中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ssc.checkpoint(checkpointDirectory)</span><br><span class="line">        messages.checkpoint(<span class="type">Duration</span>(<span class="number">10</span> * <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">        messages.foreachRDD(rdd =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rdd.isEmpty()) &#123;</span><br><span class="line">                println(<span class="string">"慕课 CTY: "</span> + rdd.count())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        ssc</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"Offset01App"</span>).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="type">StreamingContext</span>.getOrCreate(checkpointDirectory, functionToCreateContext _)</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark Streaming 整合 Flume</title>
    <url>/2019/10/02/Spark-Streaming-%E6%95%B4%E5%90%88-Flume/</url>
    <content><![CDATA[<ul>
<li>Flume-style Push-based Approach</li>
<li>Pull-based Approach using a Custom Sink（推荐使用）</li>
</ul>
<a id="more"></a>
<h2 id="Flume-style-Push-based-Approach"><a href="#Flume-style-Push-based-Approach" class="headerlink" title="Flume-style Push-based Approach"></a>Flume-style Push-based Approach</h2><p><strong>基于Flume的推送的方法</strong></p>
<p>（管网翻译）</p>
<p>Flume 旨在在 Flume 代理之间推送数据。在这种方法中，Spark Streaming 本质上设置了一个接收器，该接收器充当 Flume 的 Avro 代理，Flume 可以将数据推送到该接收器。</p>
<ul>
<li>启动 Flume + Spark Streaming 应用程序时，其中一个 Spark 辅助程序必须在该计算机上运行</li>
<li>可以将 Flume 配置为将数据推送到该计算机上的端口</li>
</ul>
<h3 id="Flume-Agent-的编写："><a href="#Flume-Agent-的编写：" class="headerlink" title="Flume Agent 的编写："></a>Flume Agent 的编写：</h3><p><strong>flume_push_stream.conf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">simple-agent.sources = netcat-source</span><br><span class="line">simple-agent.sinks = avro-sink</span><br><span class="line">simple-agent.channels = memory-channel</span><br><span class="line"></span><br><span class="line">simple-agent.sources.netcat-source.type = netcat</span><br><span class="line">simple-agent.sources.netcat-source.bind = hadoop000</span><br><span class="line">simple-agent.sources.netcat-source.port = 44444</span><br><span class="line"></span><br><span class="line">simple-agent.sinks.avro-sink.type = avro</span><br><span class="line">simple-agent.sinks.avro-sink.hostname = hadoop000</span><br><span class="line">simple-agent.sinks.avro-sink.port = 41414</span><br><span class="line">simple-agent.sinks.avro-sink.connect-timeout = 30000</span><br><span class="line"></span><br><span class="line">simple-agent.channels.memory-channel.type = memory</span><br><span class="line"></span><br><span class="line">simple-agent.sources.netcat-source.channels = memory-channel</span><br><span class="line">simple-agent.sinks.avro-sink.channel = memory-channel</span><br></pre></td></tr></table></figure>
<p><strong>Spark Streaming 代码</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author Chentyit</span></span><br><span class="line"><span class="comment"> * @Date 2019/10/2 10:18</span></span><br><span class="line"><span class="comment"> * @Description: Spark Streaming 整合 Flume —— Push</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FlumePushWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交到集群运行时需要判断参数</span></span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">System</span>.err.println(<span class="string">"Usage: FlumePushWordCount &lt;hostname&gt; &lt;port&gt;"</span>)</span><br><span class="line">            <span class="type">System</span>.exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> <span class="type">Array</span>(hostname, port) = args</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"FlumePushWordCount"</span>)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">        ssc.sparkContext.setLogLevel(<span class="string">"OFF"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的 IP 地址是 Flume 机器的地址</span></span><br><span class="line">        <span class="comment">// 将参数传递到这来</span></span><br><span class="line">        <span class="keyword">val</span> flumeStream = <span class="type">FlumeUtils</span>.createStream(ssc, hostname, port.toInt)</span><br><span class="line">        flumeStream.map(x =&gt; <span class="keyword">new</span> <span class="type">String</span>(x.event.getBody.array()).trim)</span><br><span class="line">        .flatMap(_.split(<span class="string">" "</span>)).map((_, <span class="number">1</span>)).reduceByKey(_ + _).print()</span><br><span class="line"></span><br><span class="line">        ssc.start()</span><br><span class="line">        ssc.awaitTermination()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>提交集群运行方式</strong>（也可以在本地运行调试再打包到集群中，注意下文中的<strong>踩坑</strong>）</p>
<ol>
<li><p>Spark 的 jar 包运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spark-submit \</span><br><span class="line">--class com.imooc.spark.FlumePushWordCount \</span><br><span class="line">--master local[2] \</span><br><span class="line">--packages org.apache.spark:spark-streaming-flume_2.11:2.2.0 \</span><br><span class="line">/home/hadoop/lib/sparktrain-1.0.jar \</span><br><span class="line">hadoop000 41414</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 Flume</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--name simple-agent  \</span><br><span class="line">--conf $FLUME_HOME/conf  \</span><br><span class="line">--conf-file $FLUME_HOME/conf/flume_push_stream.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><ol>
<li>sink 的 IP 地址应该是 SparkStreaming 程序运行的那台机器的 IP 地址，如果这台机器在集群上，就要把程序打包上传集群运行（注：flume 所在的机器必须和程序运行的机器能 ping  通）</li>
<li>先启动 SparkStreaming 程序，再启动 flume</li>
</ol>
<h2 id="Pull-based-Approach-using-a-Custom-Sink（推荐使用）"><a href="#Pull-based-Approach-using-a-Custom-Sink（推荐使用）" class="headerlink" title="Pull-based Approach using a Custom Sink（推荐使用）"></a>Pull-based Approach using a Custom Sink（推荐使用）</h2><p><strong>基于 Pull 的方法自定义接收器</strong></p>
<p>这种方法不是运行 Flume 将数据直接推送到 Spark Streaming，而是运行自定义的 Flume 接收器</p>
<ul>
<li>Flume 将数据推入接收器，并且数据保持缓冲状态</li>
<li>Spark Streaming 使用可靠的 Flume 接收器和事务从接收器中提取数据。只有在 Spark Streaming 接收并复制了数据之后，事务才能成功</li>
</ul>
<p>与以前的方法相比，这确保了更强的可靠性和容错保证。但是，这需要将Flume配置为运行自定义接收器</p>
<h3 id="Flume-Agent-的编写：-1"><a href="#Flume-Agent-的编写：-1" class="headerlink" title="Flume Agent 的编写："></a>Flume Agent 的编写：</h3><p><strong>flume_pull_streaming.conf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">simple-agent.sources = netcat-source</span><br><span class="line">simple-agent.sinks = spark-sink</span><br><span class="line">simple-agent.channels = memory-channel</span><br><span class="line"></span><br><span class="line">simple-agent.sources.netcat-source.type = netcat</span><br><span class="line">simple-agent.sources.netcat-source.bind = hadoop000</span><br><span class="line">simple-agent.sources.netcat-source.port = 44444</span><br><span class="line"></span><br><span class="line">simple-agent.sinks.spark-sink.type = org.apache.spark.streaming.flume.sink.SparkSink</span><br><span class="line">simple-agent.sinks.spark-sink.hostname = hadoop000</span><br><span class="line">simple-agent.sinks.spark-sink.port = 41414</span><br><span class="line"></span><br><span class="line">simple-agent.channels.memory-channel.type = memory</span><br><span class="line"></span><br><span class="line">simple-agent.sources.netcat-source.channels = memory-channel</span><br><span class="line">simple-agent.sinks.spark-sink.channel = memory-channel</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flume-ng agent  \</span><br><span class="line">--name simple-agent   \</span><br><span class="line">--conf $FLUME_HOME/conf    \</span><br><span class="line">--conf-file $FLUME_HOME/conf/flume_pull_streaming.conf  \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>
<p><strong>Spark Streaming 代码</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author Chentyit</span></span><br><span class="line"><span class="comment"> * @Date 2019/10/2 12:10</span></span><br><span class="line"><span class="comment"> * @Description: Spark Streaming 整合 Flume - Pull</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FlumePullWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"FlumePushWordCount"</span>)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">        ssc.sparkContext.setLogLevel(<span class="string">"OFF"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的 IP 地址是 Flume 机器的地址</span></span><br><span class="line">        <span class="keyword">val</span> flumeStream = <span class="type">FlumeUtils</span>.createPollingStream(ssc, <span class="string">"192.168.10.120"</span>, <span class="number">41414</span>)</span><br><span class="line">        flumeStream.map(x =&gt; <span class="keyword">new</span> <span class="type">String</span>(x.event.getBody.array()).trim)</span><br><span class="line">        .flatMap(_.split(<span class="string">" "</span>)).map((_, <span class="number">1</span>)).reduceByKey(_ + _).print()</span><br><span class="line"></span><br><span class="line">        ssc.start()</span><br><span class="line">        ssc.awaitTermination()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="踩坑-1"><a href="#踩坑-1" class="headerlink" title="踩坑"></a>踩坑</h3><ol>
<li>先启动 FLume，再启动 SparkStreaming 程序</li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Flume</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>SparkStreaming 进阶</title>
    <url>/2019/09/28/SparkStreaming-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<ul>
<li>带状态的算子（UpdateStateByKey）</li>
<li>基于 window 的统计</li>
<li>实例测试</li>
</ul>
<a id="more"></a>
<h2 id="带状态的算子（UpdateStateByKey）"><a href="#带状态的算子（UpdateStateByKey）" class="headerlink" title="带状态的算子（UpdateStateByKey）"></a>带状态的算子（UpdateStateByKey）</h2><p>updateStateByKey 操作使您可以保持任意状态，同时用新信息连续更新它。要使用此功能，将必须执行两个步骤：（官网内容）</p>
<ol>
<li><strong>定义状态：</strong>状态可以是任意数据类型</li>
<li><strong>定义状态更新功能：</strong>使用功能指定如何使用输入流中的先前状态和新值来更新状态</li>
</ol>
<h2 id="基于-window-的统计"><a href="#基于-window-的统计" class="headerlink" title="基于 window 的统计"></a>基于 window 的统计</h2><p>Spark Streaming 还提供窗口化计算，使您可以在数据的滑动窗口上应用转换</p>
<p><img src="http://spark.apache.org/docs/2.2.0/img/streaming-dstream-window.png" alt="window"></p>
<p>如图所示，每当窗口在源 DStream 上滑动时，落入窗口内的源 RDD 就会合并并进行操作，以生成窗口 DStream 的 RDD</p>
<p>在这种特定情况下，该操作将应用于数据的最后 3 个时间单位，并以 2 个时间单位滑动</p>
<p>这表明任何窗口操作都需要指定两个参数</p>
<ul>
<li><strong>窗口长度：</strong>窗口的持续时间</li>
<li><strong>滑动间隔：</strong>进行窗口操作的间隔</li>
</ul>
<h2 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h2><h3 id="1-统计到目前为止累计出现的单词的个数（需要保持住以前的状态）"><a href="#1-统计到目前为止累计出现的单词的个数（需要保持住以前的状态）" class="headerlink" title="1. 统计到目前为止累计出现的单词的个数（需要保持住以前的状态）"></a>1. 统计到目前为止累计出现的单词的个数（需要保持住以前的状态）</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author Chentyit</span></span><br><span class="line"><span class="comment"> * @Date 2019/9/28 18:34</span></span><br><span class="line"><span class="comment"> * @Description: 使用 SparkStreaming 完成有状态统计</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StatefulWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把当前的数据去更新已有的或者是老的数据</span></span><br><span class="line"><span class="comment">     * @param currentValues 当前的</span></span><br><span class="line"><span class="comment">     * @param preValues 老的</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateFunction</span></span>(currentValues: <span class="type">Seq</span>[<span class="type">Int</span>], preValues: <span class="type">Option</span>[<span class="type">Int</span>]): <span class="type">Option</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">        <span class="keyword">val</span> current = currentValues.sum</span><br><span class="line">        <span class="keyword">val</span> pre = preValues.getOrElse(<span class="number">0</span>)</span><br><span class="line">        <span class="type">Some</span>(current + pre)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"StatefulWordCount"</span>).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">        ssc.sparkContext.setLogLevel(<span class="string">"OFF"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是用了 stateful 的算子，必须要设置 checkpoint</span></span><br><span class="line">        <span class="comment">// 在生产环境中，建议把 checkpoint 设置到 HDFS 的某个文件夹中</span></span><br><span class="line">        ssc.checkpoint(<span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"192.168.1.10"</span>, <span class="number">6789</span>)</span><br><span class="line">        <span class="keyword">val</span> result = lines.flatMap(_.split(<span class="string">" "</span>)).map((_,<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">val</span> state = result.updateStateByKey[<span class="type">Int</span>](updateFunction _)</span><br><span class="line">        state.print()</span><br><span class="line"></span><br><span class="line">        ssc.start()</span><br><span class="line">        ssc.awaitTermination()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-计算到目前为止累计出现的单词个数写入到-MySQL"><a href="#2-计算到目前为止累计出现的单词个数写入到-MySQL" class="headerlink" title="2. 计算到目前为止累计出现的单词个数写入到 MySQL"></a>2. 计算到目前为止累计出现的单词个数写入到 MySQL</h3><ul>
<li>使用 Spark Streaming 进行统计分析</li>
<li>Spark Streaming 统计结果写入到 MySQL</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author Chentyit</span></span><br><span class="line"><span class="comment"> * @Date 2019/9/28 18:34</span></span><br><span class="line"><span class="comment"> * @Description: 使用 SparkStreaming 完成有词频统计并将结果写入到 MySQL 数据库中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ForeachRDDApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 MySQL 的连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createConnection</span></span>(): <span class="type">Connection</span> = &#123;</span><br><span class="line">        <span class="type">Class</span>.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>)</span><br><span class="line">        <span class="type">DriverManager</span>.getConnection(<span class="string">"jdbc:mysql://localhost:3306/imoocbootscala?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai"</span>, <span class="string">"root"</span>, <span class="string">"Chentyit123456"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"StatefulWordCount"</span>).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">        ssc.sparkContext.setLogLevel(<span class="string">"OFF"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是用了 stateful 的算子，必须要设置 checkpoint</span></span><br><span class="line">        <span class="comment">// 在生产环境中，建议把 checkpoint 设置到 HDFS 的某个文件夹中</span></span><br><span class="line">        ssc.checkpoint(<span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"192.168.1.10"</span>, <span class="number">6789</span>)</span><br><span class="line">        <span class="keyword">val</span> result = lines.flatMap(_.split(<span class="string">" "</span>)).map((_, <span class="number">1</span>)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">        result.print()</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将结果写入到 MySQL</span></span><br><span class="line"><span class="comment">         * 这里的代码有两个问题：</span></span><br><span class="line"><span class="comment">         * 1. 对于已有的数据不会更新（改进方法：使用 Hbase 或者 Redis，再或者去数据库中查询，如果存在就更新，不存在就添加）</span></span><br><span class="line"><span class="comment">         * 2. 数据库连接没有使用连接池，会造成程序对资源的开销很大</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        result.foreachRDD(rdd =&gt; &#123;</span><br><span class="line">            rdd.foreachPartition(partitionOfRecords =&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> connection = createConnection()</span><br><span class="line">                partitionOfRecords.foreach(recode =&gt; &#123;</span><br><span class="line">                    <span class="keyword">val</span> sql = <span class="string">"insert into wordcount(word, wordcount) values('"</span> + recode._1 + <span class="string">"',"</span> + recode._2 + <span class="string">")"</span></span><br><span class="line">                    connection.createStatement().execute(sql)</span><br><span class="line">                &#125;)</span><br><span class="line">                connection.close()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        ssc.start()</span><br><span class="line">        ssc.awaitTermination()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-黑名单过滤"><a href="#3-黑名单过滤" class="headerlink" title="3. 黑名单过滤"></a>3. 黑名单过滤</h3><ul>
<li>transform 算子的使用</li>
<li>Spark Streaming 整合 RDD 进行操作</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author Chentyit</span></span><br><span class="line"><span class="comment"> * @Date 2019/9/28 19:41</span></span><br><span class="line"><span class="comment"> * @Description: 黑名单过滤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TransformApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"TransformApp"</span>)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">        ssc.sparkContext.setLogLevel(<span class="string">"OFF"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构建黑名单</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> blacks = <span class="type">List</span>(<span class="string">"zs"</span>, <span class="string">"ls"</span>)</span><br><span class="line">        <span class="keyword">val</span> blacksRDD = ssc.sparkContext.parallelize(blacks).map(x =&gt; (x, <span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"192.168.1.10"</span>, <span class="number">6789</span>)</span><br><span class="line">        lines.map(x =&gt; (x.split(<span class="string">","</span>)(<span class="number">1</span>), x)).transform(rdd =&gt; &#123;</span><br><span class="line">            rdd.leftOuterJoin(blacksRDD).filter(!_._2._2.getOrElse(<span class="literal">false</span>)).map(x=&gt;x._2._1)</span><br><span class="line">        &#125;).print()</span><br><span class="line"></span><br><span class="line">        ssc.start()</span><br><span class="line">        ssc.awaitTermination()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Spring-Streaming-整合-Spark-SQL"><a href="#4-Spring-Streaming-整合-Spark-SQL" class="headerlink" title="4. Spring Streaming 整合 Spark SQL"></a>4. Spring Streaming 整合 Spark SQL</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author Chentyit</span></span><br><span class="line"><span class="comment"> * @Date 2019/9/28 20:09</span></span><br><span class="line"><span class="comment"> * @Description: Spark Streaming 整合 Spark SQL 完成词频统计操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SqlNetworkWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"SqlNetworkWordCount"</span>)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">        ssc.sparkContext.setLogLevel(<span class="string">"OFF"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"192.168.1.10"</span>, <span class="number">6789</span>)</span><br><span class="line">        <span class="keyword">val</span> words = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert RDDs of the words DStream to DataFrame and run SQL query</span></span><br><span class="line">        words.foreachRDD &#123; (rdd: <span class="type">RDD</span>[<span class="type">String</span>], time: <span class="type">Time</span>) =&gt;</span><br><span class="line">            <span class="keyword">val</span> spark = <span class="type">SparkSessionSingleton</span>.getInstance(rdd.sparkContext.getConf)</span><br><span class="line">            <span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Convert RDD[String] to RDD[case class] to DataFrame</span></span><br><span class="line">            <span class="keyword">val</span> wordsDataFrame = rdd.map(w =&gt; <span class="type">Record</span>(w)).toDF()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Creates a temporary view using the DataFrame</span></span><br><span class="line">            wordsDataFrame.createOrReplaceTempView(<span class="string">"words"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Do word count on table using SQL and print it</span></span><br><span class="line">            <span class="keyword">val</span> wordCountsDataFrame =</span><br><span class="line">            spark.sql(<span class="string">"select word, count(*) as total from words group by word"</span>)</span><br><span class="line">            println(<span class="string">s"========= <span class="subst">$time</span> ========="</span>)</span><br><span class="line">            wordCountsDataFrame.show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ssc.start()</span><br><span class="line">        ssc.awaitTermination()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Case class for converting RDD to DataFrame */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span>(<span class="params">word: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">/**</span> <span class="title">Lazily</span> <span class="title">instantiated</span> <span class="title">singleton</span> <span class="title">instance</span> <span class="title">of</span> <span class="title">SparkSession</span> <span class="title">*/</span></span></span><br><span class="line"><span class="class">    <span class="title">object</span> <span class="title">SparkSessionSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个注解一般用于序列化的时候，标识某个字段不用被序列化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@transient</span> <span class="keyword">private</span> <span class="keyword">var</span> instance: <span class="type">SparkSession</span> = _</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getInstance</span></span>(sparkConf: <span class="type">SparkConf</span>): <span class="type">SparkSession</span> = &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="type">SparkSession</span></span><br><span class="line">                .builder</span><br><span class="line">                .config(sparkConf)</span><br><span class="line">                .getOrCreate()</span><br><span class="line">            &#125;</span><br><span class="line">            instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda四步安装多环境（鼠标点击安装）</title>
    <url>/2019/09/28/Anaconda%E5%9B%9B%E6%AD%A5%E5%AE%89%E8%A3%85%E5%A4%9A%E7%8E%AF%E5%A2%83%EF%BC%88%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E5%AE%89%E8%A3%85%EF%BC%89/</url>
    <content><![CDATA[<ol>
<li>打开 Anaconda 交互界面</li>
<li>点击 Environment</li>
<li>点击添加</li>
<li>点击完成</li>
</ol>
<a id="more"></a>
<p><img src="/2019/09/28/Anaconda四步安装多环境（鼠标点击安装）/1.png" alt="打开 Anaconda 交互界面"></p>
<p><img src="/2019/09/28/Anaconda四步安装多环境（鼠标点击安装）/2.png" alt="点击 Environment"></p>
<p><img src="/2019/09/28/Anaconda四步安装多环境（鼠标点击安装）/3.png" alt="点击添加"></p>
<p><img src="/2019/09/28/Anaconda四步安装多环境（鼠标点击安装）/4.png" alt="点击完成"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>SparkStreaming 核心</title>
    <url>/2019/09/27/SparkStreaming-%E6%A0%B8%E5%BF%83/</url>
    <content><![CDATA[<ul>
<li>核心概念</li>
<li>代码实验</li>
</ul>
<a id="more"></a>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p><a href="http://spark.apache.org/docs/2.2.0/streaming-programming-guide.html" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="StreamingContext"><a href="#StreamingContext" class="headerlink" title="StreamingContext"></a>StreamingContext</h3><p>要初始化 Spark Streaming 程序，必须创建 StreamingContext 对象，该对象是所有 Spark Streaming 功能的主要入口点</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(appName).setMaster(master)</span><br><span class="line"><span class="comment">// Seconds：必须根据应用程序的延迟要求和可用的群集资源来设置批处理间隔</span></span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p><strong>StreamingContext 源码</strong>构造方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a StreamingContext using an existing SparkContext.</span></span><br><span class="line"><span class="comment"> * @param sparkContext existing SparkContext</span></span><br><span class="line"><span class="comment"> * @param batchDuration the time interval at which streaming data will be divided into batches</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(sparkContext: <span class="type">SparkContext</span>, batchDuration: <span class="type">Duration</span>) = &#123;</span><br><span class="line">    <span class="keyword">this</span>(sparkContext, <span class="literal">null</span>, batchDuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a StreamingContext by providing the configuration necessary for a new SparkContext.</span></span><br><span class="line"><span class="comment"> * @param conf a org.apache.spark.SparkConf object specifying Spark parameters</span></span><br><span class="line"><span class="comment"> * @param batchDuration the time interval at which streaming data will be divided into batches</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(conf: <span class="type">SparkConf</span>, batchDuration: <span class="type">Duration</span>) = &#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="type">StreamingContext</span>.createNewSparkContext(conf), <span class="literal">null</span>, batchDuration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦 StreamingContext 定义好后，就可以做一些事情：（官网翻译过来的）</p>
<ol>
<li>通过创建输入 DStream 定义输入源</li>
<li>通过将转换和输出操作应用于 DStream 来定义流计算</li>
<li>开始使用 streamingContext.start() 接收数据并对其进行处理</li>
<li>等待处理使用 streamingContext.awaitTermination() </li>
<li>可以使用 streamingContext.stop() 手动停止处理</li>
</ol>
<p>要记住的要点：（官网翻译过来的）</p>
<ul>
<li>一旦启动上下文，就无法设置新的流计算或将其添加到该流计算中</li>
<li>上下文停止后，将无法重新启动</li>
<li>JVM 中只能同时激活一个 StreamingContext</li>
<li>StreamingContext 上的 stop() 也会停止 SparkContext，如要仅停止 StreamingContext，请将名为 stopSparkContext 的 stop() 的可选参数设置为 false</li>
<li>只要在创建下一个 StreamingContext 之前停止了上一个 StreamingContext（不停止 SparkContext），就可以重复使用 SparkContext 创建多个 StreamingContext</li>
</ul>
<h3 id="DStream（Discretized-Streams）"><a href="#DStream（Discretized-Streams）" class="headerlink" title="DStream（Discretized Streams）"></a>DStream（Discretized Streams）</h3><p>在内部，DStream 由一系列连续的 RDD 表示，这是 Spark 对不可变的分布式数据集的抽象</p>
<p>DStream中的每个RDD都包含来自特定间隔的数据，如下图所示</p>
<p><img src="http://spark.apache.org/docs/2.2.0/img/streaming-dstream.png" alt="DStream"></p>
<p>对 DStream 操作算子，比如 map / flatMap，其实底层会被翻译为对 DStream 中的每个 RDD 都做相同的工作，因为一个 DStream 是由不同批次的 RDD 所构成的</p>
<p><img src="http://spark.apache.org/docs/2.2.0/img/streaming-dstream-ops.png" alt="操作算子"></p>
<h3 id="Input-DStream"><a href="#Input-DStream" class="headerlink" title="Input DStream"></a>Input DStream</h3><p>Input DStream 是表示从流源接收的输入数据流的 DStream</p>
<p>每个输入 DStream （文件流除外） 都与一个Receiver对象（Scala doc，Java doc）相关联，该对象从源接收数据并将其存储在 Spark 的内存中以进行处理</p>
<p>在本地运行Spark Streaming程序时，请勿使用 “local” 或 “local [1]” 作为主URL。这两种方式均意味着仅一个线程将用于本地运行任务。如果您使用基于接收方的输入DStream（例如套接字，Kafka，Flume等），则将使用单个线程来运行接收方，而不会留下任何线程来处理接收到的数据。因此，在本地运行时，请始终使用 “local [n]” 作为主 URL，其中 n &gt; 要运行的接收器数</p>
<h2 id="代码实验"><a href="#代码实验" class="headerlink" title="代码实验"></a>代码实验</h2><ul>
<li><p>Spark Streaming 处理 socket 数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author Chentyit</span></span><br><span class="line"><span class="comment"> * @Date 2019/9/27 19:32</span></span><br><span class="line"><span class="comment"> * @Description: Spark Streaming 处理 Socket 数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">NetworkWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"NetworkWordCount"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 StreamingContext 需要两个参数：SparkConf 和 batch interval</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">        ssc.sparkContext.setLogLevel(<span class="string">"OFF"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"192.168.1.10"</span>, <span class="number">6789</span>)</span><br><span class="line">        <span class="keyword">val</span> result = lines.flatMap(_.split(<span class="string">" "</span>)).map((_, <span class="number">1</span>)).reduceByKey(_ + _)</span><br><span class="line">        result.print()</span><br><span class="line"></span><br><span class="line">        ssc.start()</span><br><span class="line">        ssc.awaitTermination()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spark Streaming 处理 HDFS 文件数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author Chentyit</span></span><br><span class="line"><span class="comment"> * @Date 2019/9/27 19:46</span></span><br><span class="line"><span class="comment"> * @Description: 使用 Spark Streaming 处理文件系统的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FileWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"FileWordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">    ssc.sparkContext.setLogLevel(<span class="string">"OFF"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> line = ssc.textFileStream(<span class="string">"E:\\test\\"</span>)</span><br><span class="line">    <span class="keyword">val</span> result = line.flatMap(_.split(<span class="string">" "</span>)).map((_, <span class="number">1</span>)).reduceByKey(_ + _)</span><br><span class="line">    result.print()</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>SparkStreaming入门</title>
    <url>/2019/09/26/SparkStreaming%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<ul>
<li>概述</li>
<li>应用场景</li>
<li>案例测试</li>
<li>工作原理</li>
</ul>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>将不同的数据源的数据经过 Spark Streaming 处理之后将结果输出到外部文件系统</p>
<p><strong>特点：</strong></p>
<ul>
<li>低延迟</li>
<li>能从错误中高效地恢复</li>
<li>能够运行在成百上千的节点</li>
<li>能够将批处理，机器学习，图计算等子框架和 Spark Streaming 综合起来使用</li>
</ul>
<p><img src="http://spark.apache.org/docs/2.2.0/img/streaming-flow.png" alt="streaming-flow"></p>
<p>输入进来的数据会被 Spark Streaming 处理成为 “批次”，然后由 Spark 引擎继续处理得到最终的数据流</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>实时金融欺诈检测</li>
<li>实时访问电子传感器的检测</li>
<li>电商行业信息推荐</li>
</ul>
<h2 id="SparkStreaming-例子测试"><a href="#SparkStreaming-例子测试" class="headerlink" title="SparkStreaming 例子测试"></a>SparkStreaming 例子测试</h2><ol>
<li><p>spark-submit 提交（词频分析）</p>
<p>启动命令（监听 hadoop000 的 9999 端口）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./spark-submit --master local[2] --class org.apache.spark.examples.streaming.NetworkWordCount --name NetworkWordCount /home/hadoop/app/spark-2.2.0-bin-2.6.0-cdh5.7.0/examples/jars/spark-examples_2.11-2.2.0.jar hadoop000 9999</span><br></pre></td></tr></table></figure>
<p>官方测试代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">NetworkWordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">System</span>.err.println(<span class="string">"Usage: NetworkWordCount &lt;hostname&gt; &lt;port&gt;"</span>)</span><br><span class="line">            <span class="type">System</span>.exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StreamingExamples</span>.setStreamingLogLevels()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"NetworkWordCount"</span>)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> lines = ssc.socketTextStream(args(<span class="number">0</span>), args(<span class="number">1</span>).toInt, <span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK_SER</span>)</span><br><span class="line">        <span class="keyword">val</span> words = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">        <span class="keyword">val</span> wordCounts = words.map(x =&gt; (x, <span class="number">1</span>)).reduceByKey(_ + _)</span><br><span class="line">        wordCounts.print()</span><br><span class="line">        ssc.start()</span><br><span class="line">        ssc.awaitTermination()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>spark-shell 提交（词频分析）</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sc, <span class="type">Seconds</span>(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"hadoop000"</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="keyword">val</span> words = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"><span class="keyword">val</span> wordCounts = words.map(x =&gt; (x, <span class="number">1</span>)).reduceByKey(_ + _)</span><br><span class="line">wordCounts.print()</span><br><span class="line">ssc.start()</span><br><span class="line">ssc.awaitTermination()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="粗粒度"><a href="#粗粒度" class="headerlink" title="粗粒度"></a>粗粒度</h3><p>Spark Streaming 接收到实时数据流，把数据按照指定的时间段切成一片片小的数据块，然后把小的数据块传给 Spark Engine 处理</p>
<h3 id="细粒度"><a href="#细粒度" class="headerlink" title="细粒度"></a>细粒度</h3><p><img src="/2019/09/26/SparkStreaming入门/细粒度.png" alt="细粒度"></p>
<ol>
<li>Spark 应用程序运行在 Driver 端，应用程序中有 StreamingContext 和 SparkContext</li>
<li>Driver 命令在 Executor 上启动接收器</li>
<li>接收器启动后，将收到的数据拆分成 block 并存放到内存中，如果设置多副本就拷贝到其他机器中</li>
<li>Receiver 将 block 的信息返回给 StreamingContext，一定时间周期后，通知 SparkContext 启动 Jobs</li>
<li>SparkContext 将 Jobs 分发到 Executor 上执行</li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式消息队列 Kafka</title>
    <url>/2019/09/25/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-Kafka/</url>
    <content><![CDATA[<ul>
<li>概述</li>
<li>下载</li>
<li>架构及核心概念</li>
<li>部署及使用</li>
<li>容错性测试</li>
<li>API 编程</li>
<li>Flume &amp; Kafka 整合</li>
<li>踩坑</li>
</ul>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="http://kafka.apache.org/" target="_blank" rel="noopener">官网</a></p>
<ul>
<li>将数据流变成一个消息系统</li>
<li>高效处理数据流（近乎实时处理）</li>
<li>安全，多副本存储于分布式系统中</li>
</ul>
<p><em>消息中间件：生产者和消费者</em></p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="http://kafka.apache.org/" target="_blank" rel="noopener">官网</a></p>
<p>建议 0.8.0 到 0.10.1</p>
<p>0.8.0 —— 看老师使用过</p>
<p>0.9.0 —— 实验环境运行成功</p>
<p>0.10.1 —— 学习环境运行成功</p>
<ul>
<li>配置环境变量就可以开始运行</li>
</ul>
<h2 id="架构及核心概念"><a href="#架构及核心概念" class="headerlink" title="架构及核心概念"></a>架构及核心概念</h2><h3 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h3><ul>
<li>producer：生产者 —— 生产馒头</li>
<li>consumer：消费者 —— 吃馒头</li>
<li>broker：篮子</li>
<li>topic：主题，相当于馒头的标签，标志消费者吃那个标签下的馒头</li>
</ul>
<h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><ul>
<li><p>Kafka is run as a cluster on one or more servers that can span multiple datacenters.</p>
<p>（Kafka在一个或多个可以跨越多个数据中心的服务器上作为集群运行）</p>
</li>
<li><p>The Kafka cluster stores streams of <em>records</em> in categories called <em>topics</em>.</p>
<p>（Kafka群集将记录流存储在称为主题的类别中）</p>
</li>
<li><p>Each record consists of a key, a value, and a timestamp.</p>
<p>（每个记录由一个键，一个值和一个时间戳组成）</p>
</li>
</ul>
<h3 id="四个核心-API"><a href="#四个核心-API" class="headerlink" title="四个核心 API"></a>四个核心 API</h3><ul>
<li><strong>Producer API</strong> 发布消息到 1 和或多个 topic</li>
<li><strong>Consumer API</strong> 订阅一个或多个 topic，并处理产生的消息</li>
<li><strong>Stream API</strong> 充当一个流处理器，从 1 个或多个 topic 消费输出流，产生一个输出流到 1 个或多个输出 topic，有效将输入流转换到输出流</li>
<li><strong>Connector API</strong> 允许侯建或运行可重复使用的生产者或消费者，将 topic 连接到现有的应用程序或数据系统。</li>
</ul>
<h3 id="主题和日志"><a href="#主题和日志" class="headerlink" title="主题和日志"></a>主题和日志</h3><p><strong>Topic</strong> 是发布的消息或者种子的名字。对于每个 Topic，Kafka 集群维护这一个分区的 log</p>
<p>每个分区都是一个有序不可变的队列，且可以持续添加<strong>（只是局部有序，全局无序，如果要全局有序就只能有一个分区）</strong></p>
<p>分区中以唯一的偏移量标记每个消息</p>
<p>消费者持有和操作的都是偏移值，好处是不会影响到其他消费者，也更加自由灵活读取消息</p>
<p><strong>分区设计目的</strong></p>
<ul>
<li>处理更多消息，不受单台服务器的限制</li>
<li>分区可以作为并行处理单元</li>
</ul>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>Log 的分区被分布式到集群中的多个服务器上，每个服务器处理它分到的分区。根据配置每个分区，还可以复制到其他服务器作为<strong>备份容错</strong>（下面有测试）</p>
<p> 每个分区有一个 leader，0 个或多个 follower，Leader 处理此分区的读写请求，follower 被动复制数据，如果 leader 宕机，follower 被推举为新 leader（下面测试有体现）</p>
<p>一个 leader 也有可能是其他分区的 follower，目的是为了负载均衡</p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>向某个 Topic 发布消息，也负责选择发布到 Topic 上的哪个分区</p>
<p>选择算法：轮流选择，权重选择等（由开发者决定）</p>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费模型有两种：<strong>队列</strong>和<strong>发布-订阅</strong></p>
<ul>
<li>队列：一组消费者从服务器读取消息，一条消息只有其中一个消费者处理</li>
<li>发布-订阅：消息被广播给所有消费者，接收到消息的消费者都可以处理此消息</li>
</ul>
<h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>Kafka 为消费者模型提供的单一消费者凑相关模型</p>
<p>所有消费者在一个组中就是队列模型</p>
<p>不在一个组中就是发布-订阅模型</p>
<h2 id="部署及使用"><a href="#部署及使用" class="headerlink" title="部署及使用"></a>部署及使用</h2><ul>
<li><p>单节点单 Broker 部署及使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置 $KAFKA_HOME/config/server.properties 下的文件</span><br><span class="line">broker.id=0</span><br><span class="line">listeners</span><br><span class="line">log.dirs（不能是tmp，重启之后会消失）</span><br><span class="line">zookeeper.connect</span><br><span class="line"></span><br><span class="line"># 启动 Kafka</span><br><span class="line">kafka-server-start.sh config/server.properties</span><br><span class="line"></span><br><span class="line"># 创建 topic</span><br><span class="line">kafka-topics.sh --create --zookeeper hadoop000:2181 --replication-factor 1 --partitions 1 --topic cty_topic</span><br><span class="line"></span><br><span class="line"># 查看所有 topic</span><br><span class="line">kafka-topics.sh --list --zookeeper hadoop000:2181</span><br><span class="line"></span><br><span class="line"># 发送信息（生产馒头）</span><br><span class="line">kafka-console-producer.sh --broker-list hadoop000:9092 --topic cty_topic</span><br><span class="line"></span><br><span class="line"># 消费消息（吃馒头）</span><br><span class="line"># 写 --from-beginning（从第一个馒头开始吃）</span><br><span class="line"># 不写就是从新蒸好的馒头开始吃</span><br><span class="line">kafka-console-consumer.sh --zookeeper hadoop000:2181 --topic cty_topic --from-beginning</span><br><span class="line"></span><br><span class="line"># 查看所有 topic 的详细信息</span><br><span class="line">kafka-topics.sh --describe --zookeeper hadoop000:2181</span><br><span class="line"># 查看指定 topic 的详细信息</span><br><span class="line">kafka-topics.sh --describe --zookeeper hadoop000:2181 --topic cty_topic</span><br></pre></td></tr></table></figure>
</li>
<li><p>单节点多 Broker 部署及使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是官网复制的</span><br><span class="line"># 在同一台主机上部署多 Broker（按需求改）</span><br><span class="line">config/server-1.properties:</span><br><span class="line">    broker.id=1</span><br><span class="line">    port=9093</span><br><span class="line">    log.dir=/tmp/kafka-logs-1</span><br><span class="line"></span><br><span class="line">config/server-2.properties:</span><br><span class="line">    broker.id=2</span><br><span class="line">    port=9094</span><br><span class="line">    log.dir=/tmp/kafka-logs-2</span><br><span class="line"></span><br><span class="line"># 启动多个 Broker</span><br><span class="line"># daemon（守护进程）</span><br><span class="line">kafka-server-start.sh -daemon config/server-1.properties &amp;</span><br><span class="line">kafka-server-start.sh -daemon config/server-2.properties &amp;</span><br><span class="line"></span><br><span class="line"># jps（这里是启动了三个）</span><br><span class="line">22915 Kafka</span><br><span class="line">23109 Jps</span><br><span class="line">22981 Kafka</span><br><span class="line">21829 QuorumPeerMain</span><br><span class="line">23048 Kafka</span><br><span class="line"></span><br><span class="line"># 创建 topic</span><br><span class="line">kafka-topics.sh --create --zookeeper hadoop000:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic-cty</span><br><span class="line"></span><br><span class="line"># 查看 topic 详细信息</span><br><span class="line">kafka-topics.sh --describe --zookeeper hadoop000:2181 --topic my-replicated-topic-cty</span><br><span class="line"># PartitionCount 分区数</span><br><span class="line"># ReplicationFactor 副本数</span><br><span class="line"># Leader 领导者</span><br><span class="line"># Replicas 副本顺序</span><br><span class="line"># Isr 存活节点</span><br><span class="line">Topic:my-replicated-topic-cty	PartitionCount:1	ReplicationFactor:3	Configs:</span><br><span class="line">	Topic: my-replicated-topic-cty	Partition: 0	Leader: 1	Replicas: 1,3,2	Isr: 1,3,2</span><br></pre></td></tr></table></figure>
</li>
<li><p>多节点多 Broker 部署及使用（使用方法和<strong>单节点多 Broker</strong> 一样只不过分发到其他机器上了）</p>
</li>
</ul>
<h2 id="容错性测试"><a href="#容错性测试" class="headerlink" title="容错性测试"></a>容错性测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 先删除一个 Broker 查看是否还能继续生产馒头和吃馒头</span><br><span class="line"># 使用 kill -9 pid 强制关闭一个 Broker</span><br><span class="line">[hadoop@hadoop000 kafka_2.11-0.9.0.0]$ jps -m</span><br><span class="line">22915 Kafka config/server-1.properties</span><br><span class="line">22981 Kafka config/server-2.properties</span><br><span class="line">23048 Kafka config/server-3.properties</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[hadoop@hadoop000 kafka_2.11-0.9.0.0]$ kull -9 22981</span><br><span class="line"></span><br><span class="line">[hadoop@hadoop000 kafka_2.11-0.9.0.0]$ jps -m</span><br><span class="line">22915 Kafka config/server-1.properties</span><br><span class="line">23048 Kafka config/server-3.properties</span><br><span class="line"></span><br><span class="line"># 查看 topic 的信息（还剩 1 和 3 存活，且能继续生产馒头和吃馒头）</span><br><span class="line">Topic:my-replicated-topic-cty	PartitionCount:1	ReplicationFactor:3	Configs:</span><br><span class="line">	Topic: my-replicated-topic-cty	Partition: 0	Leader: 1	Replicas: 1,3,2	Isr: 1,3</span><br><span class="line"></span><br><span class="line"># 让 Leader 嗝屁（还是能继续生产馒头和吃馒头）</span><br><span class="line"># 注意：主节点嗝屁后，消费者会去找新的主节点，找的过程中会有报错</span><br><span class="line"># 就是找不到蒸馒头的人了，等新人一来就又继续吃了</span><br><span class="line">Topic:my-replicated-topic-cty	PartitionCount:1	ReplicationFactor:3	Configs:</span><br><span class="line">	Topic: my-replicated-topic-cty	Partition: 0	Leader: 3	Replicas: 1,3,2	Isr: 3</span><br></pre></td></tr></table></figure>
<h2 id="API-编程"><a href="#API-编程" class="headerlink" title="API 编程"></a>API 编程</h2><p><strong>KafkaProperties.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/25 14:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 设置一些参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK = <span class="string">"192.168.43.169:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC = <span class="string">"cty_topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_LIST = <span class="string">"192.168.43.169:9092"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GROUP_ID = <span class="string">"test_group1"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>KafkaProducer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/25 14:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Kafka 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> Producer&lt;Integer, String&gt; producer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KafkaProducer</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.topic = topic;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于保存参数</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置参数</span></span><br><span class="line">        properties.put(<span class="string">"metadata.broker.list"</span>,KafkaProperties.BROKER_LIST);</span><br><span class="line">        properties.put(<span class="string">"serializer.class"</span>,<span class="string">"kafka.serializer.StringEncoder"</span>);</span><br><span class="line">        properties.put(<span class="string">"request.required.acks"</span>,<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化一个生产者</span></span><br><span class="line">        producer = <span class="keyword">new</span> Producer&lt;Integer, String&gt;(<span class="keyword">new</span> ProducerConfig(properties));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送的数据</span></span><br><span class="line">        <span class="keyword">int</span> messageNo = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 构建发送的数据</span></span><br><span class="line">            String message = <span class="string">"message_"</span> + messageNo;</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            producer.send(<span class="keyword">new</span> KeyedMessage&lt;Integer, String&gt;(topic, message));</span><br><span class="line">            <span class="comment">// 打印消息</span></span><br><span class="line">            System.out.println(<span class="string">"Sent: "</span> + message);</span><br><span class="line">            messageNo ++ ;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>KafkaConsumer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/25 15:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消费者（吃馒头）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KafkaConsumer</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.topic = topic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建连接器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ConsumerConnector <span class="title">createConnector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于保存参数</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置参数</span></span><br><span class="line">        <span class="comment">// 不设置 group.id 会报错</span></span><br><span class="line">        properties.put(<span class="string">"zookeeper.connect"</span>, KafkaProperties.ZK);</span><br><span class="line">        properties.put(<span class="string">"group.id"</span>, KafkaProperties.GROUP_ID);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个消费者</span></span><br><span class="line">        <span class="keyword">return</span> Consumer.createJavaConsumerConnector(<span class="keyword">new</span> ConsumerConfig(properties));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取一个消费者实例</span></span><br><span class="line">        ConsumerConnector consumer = createConnector();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存 topic</span></span><br><span class="line">        Map&lt;String, Integer&gt; topicCountMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        topicCountMap.put(topic, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个 String：topic</span></span><br><span class="line">        <span class="comment">// List&lt;KafkaStream&lt;byte[], byte[]&gt;&gt; 对应的数据流</span></span><br><span class="line">        Map&lt;String, List&lt;KafkaStream&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt;&gt; messageStream = consumer.createMessageStreams(topicCountMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取我们每次接受到的数据</span></span><br><span class="line">        KafkaStream&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; stream = messageStream.get(topic).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用迭代器获取数据</span></span><br><span class="line">        <span class="keyword">for</span> (kafka.message.MessageAndMetadata&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; messageAndMetadata : stream) &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(messageAndMetadata.message());</span><br><span class="line">            System.out.println(<span class="string">"rec:"</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>KafkaClientApp.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/25 15:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaClientApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动两个线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> KafkaProducer(KafkaProperties.TOPIC).start();</span><br><span class="line">        <span class="keyword">new</span> KafkaConsumer(KafkaProperties.TOPIC).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Flume-amp-Kafka-整合"><a href="#Flume-amp-Kafka-整合" class="headerlink" title="Flume &amp; Kafka 整合"></a>Flume &amp; Kafka 整合</h2><p><img src="/2019/09/25/分布式消息队列-Kafka/Flume&amp;Kafka.png" alt="Flume&amp;Kafka"></p>
<p><strong>avro-memory-kafka.conf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avro-memory-kafka.sources = avro-source</span><br><span class="line">avro-memory-kafka.sinks = kafka-sink</span><br><span class="line">avro-memory-kafka.channels = memory-channel</span><br><span class="line"></span><br><span class="line">avro-memory-kafka.sources.avro-source.type = avro</span><br><span class="line">avro-memory-kafka.sources.avro-source.bind = hadoop000</span><br><span class="line">avro-memory-kafka.sources.avro-source.port = 44444</span><br><span class="line"></span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.type = org.apache.flume.sink.kafka.KafkaSink</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.brokerList = hadoop000:9092</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.topic = cty_topic</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.batchSize = 5</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.requiredAcks = 1</span><br><span class="line"></span><br><span class="line">avro-memory-kafka.channels.memory-channel.type = memory</span><br><span class="line"></span><br><span class="line">avro-memory-kafka.sources.avro-source.channels = memory-channel</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.channel = memory-channel</span><br></pre></td></tr></table></figure>
<p><strong>avro-memory-logger.conf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avro-memory-logger.sources = avro-source</span><br><span class="line">avro-memory-logger.sinks = logger-sink</span><br><span class="line">avro-memory-logger.channels = memory-channel</span><br><span class="line"></span><br><span class="line">avro-memory-logger.sources.avro-source.type = avro</span><br><span class="line">avro-memory-logger.sources.avro-source.bind = hadoop000</span><br><span class="line">avro-memory-logger.sources.avro-source.port = 44444</span><br><span class="line"></span><br><span class="line">avro-memory-logger.sinks.logger-sink.type = logger</span><br><span class="line"></span><br><span class="line">avro-memory-logger.channels.memory-channel.type = memory</span><br><span class="line"></span><br><span class="line">avro-memory-logger.sources.avro-source.channels = memory-channel</span><br><span class="line">avro-memory-logger.sinks.logger-sink.channel = memory-channel</span><br></pre></td></tr></table></figure>
<p><strong>先启动 avro-memory-kafka.conf</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--name avro-memory-kafka  \</span><br><span class="line">--conf $FLUME_HOME/conf  \</span><br><span class="line">--conf-file $FLUME_HOME/conf/avro-memory-kafka.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>
<p><strong>再启动 exec-memory-avro</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--name exec-memory-avro  \</span><br><span class="line">--conf $FLUME_HOME/conf  \</span><br><span class="line">--conf-file $FLUME_HOME/conf/exec-memory-avro.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>
<p><strong>最后启动 Kafka</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>
<p><strong>在终端查看消费者信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-console-consumer.sh --zookeeper hadoop000:2181 --topic cty_topic</span><br></pre></td></tr></table></figure>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><ol>
<li><p>在 server.properties 中的 listeners 用于外网访问 Kafka 集群，如果需要在本地调试传消息到 Kafka 集群，就需要这个参数，而且 listeners 的参数必须规范，后面的 IPv4 地址必须要按照规范来，不能用主机名代替，不然外部无法连接，设置规范</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listeners=PLAINTEXT://192.168.43.169:9092</span><br></pre></td></tr></table></figure>
</li>
<li><p>Flume 下沉到 Kafka 需要看官网，下沉的版本号有要求，比如 flume1.6 只支持 kafka 0.9 以上版本</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式日志收集框架 Flume</title>
    <url>/2019/09/25/%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E6%A1%86%E6%9E%B6-Flume/</url>
    <content><![CDATA[<ul>
<li>Flume 概述</li>
<li>安装</li>
<li>Flume 架构及核心组件</li>
<li>Flume 配置文件描述</li>
<li>监控一个文件实时采集新增的数据输出到控制台</li>
<li>跨服务采集日志</li>
</ul>
<a id="more"></a>
<h2 id="Flume-概述"><a href="#Flume-概述" class="headerlink" title="Flume 概述"></a>Flume 概述</h2><p><a href="http://flume.apache.org/" target="_blank" rel="noopener">官网</a></p>
<p>FLume 是有 Cloudera 提供的一个<strong>分布式，高可靠，高可用</strong>的服务，用于分布式的海量日志的高效收集、聚合、移动系统</p>
<p>设计目标：可靠性，扩展性，管理性</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>安装 JDK</p>
</li>
<li><p>下载 flume 安装包</p>
</li>
<li><p>解压安装包</p>
</li>
<li><p>更改配置文件</p>
<p>修改 conf 下的 flume-env.sh.template 复制一份到 flume-env.sh 并修改文件中的 JAVA_HOME 为 jdk 的真实路径</p>
</li>
</ul>
<h2 id="Flume-架构及核心组件"><a href="#Flume-架构及核心组件" class="headerlink" title="Flume 架构及核心组件"></a>Flume 架构及核心组件</h2><ul>
<li><p>Source：收集</p>
<p>指定数据的来源</p>
</li>
<li><p>Channel：聚集</p>
<p>为数据提供一个临时缓存的地方</p>
</li>
<li><p>Sink：输出</p>
<p>从 Channel 中将数据读取出来，输出到指定位置</p>
</li>
</ul>
<h2 id="Flume-配置文件描述"><a href="#Flume-配置文件描述" class="headerlink" title="Flume 配置文件描述"></a>Flume 配置文件描述</h2><ul>
<li>a1：agent 名称</li>
<li>r1：source 的名称</li>
<li>k1：sink 的名称</li>
<li>c1：channle 的名称</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line"># 组件类型为 netcat</span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line"># 要绑定的主机名或IP地址</span><br><span class="line">a1.sources.r1.bind = hadoop000</span><br><span class="line"># 要绑定的端口号</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line"># 需要记录组件类型名称</span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line"># 组件类型名称，必须是内存</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"># 通道中存储的最大事件数</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line"># 每次通道从源或汇给接收器的最大事件数</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>
<p><strong>启动命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/flume-ng agent --name a1 --conf conf --conf-file conf/example.conf -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>
<p><strong>接收到的消息：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Event: &#123; headers:&#123;&#125; body: 68 65 6C 6C 6F 0D     hello. &#125;</span><br></pre></td></tr></table></figure>
<p>Event 是 Flume 数据传输的基本单元</p>
<p>Event = 可选的 header + byte array</p>
<h2 id="监控一个文件实时采集新增的数据输出到控制台"><a href="#监控一个文件实时采集新增的数据输出到控制台" class="headerlink" title="监控一个文件实时采集新增的数据输出到控制台"></a>监控一个文件实时采集新增的数据输出到控制台</h2><p><strong>Agent 选型：</strong>exec source + Memory Channel + Logger Sink</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line"># 组件类型名称为 exec </span><br><span class="line">a1.sources.r1.type = exec</span><br><span class="line">a1.sources.r1.command = tail -F /home/hadoop/data/data.log</span><br><span class="line">a1.sources.r1.shell = /bin/sh -c</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line"># 需要记录组件类型名称</span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line"># 组件类型名称，必须是内存</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"># 通道中存储的最大事件数</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line"># 每次通道从源或汇给接收器的最大事件数</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>
<h2 id="跨服务采集日志"><a href="#跨服务采集日志" class="headerlink" title="跨服务采集日志"></a>跨服务采集日志</h2><p><strong>技术选型：</strong></p>
<ul>
<li>exec source + memory channel + avro sink</li>
<li>avro source + memory channel + logger sink</li>
</ul>
<p><strong>exec-memory-avro.conf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec-memory-avro.sources = exec-source</span><br><span class="line">exec-memory-avro.sinks = avro-sink</span><br><span class="line">exec-memory-avro.channels = memory-channel</span><br><span class="line"></span><br><span class="line">exec-memory-avro.sources.exec-source.type = exec</span><br><span class="line">exec-memory-avro.sources.exec-source.command = tail -F /home/hadoop/data/data.log</span><br><span class="line">exec-memory-avro.sources.exec-source.shell = /bin/sh -c</span><br><span class="line"></span><br><span class="line">exec-memory-avro.sinks.avro-sink.type = avro</span><br><span class="line">exec-memory-avro.sinks.avro-sink.hostname = hadoop000</span><br><span class="line">exec-memory-avro.sinks.avro-sink.port = 44444</span><br><span class="line"></span><br><span class="line">exec-memory-avro.channels.memory-channel.type = memory</span><br><span class="line"></span><br><span class="line">exec-memory-avro.sources.exec-source.channels = memory-channel</span><br><span class="line">exec-memory-avro.sinks.avro-sink.channel = memory-channel</span><br></pre></td></tr></table></figure>
<p><strong>avro-memory-logger.conf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avro-memory-logger.sources = avro-source</span><br><span class="line">avro-memory-logger.sinks = logger-sink</span><br><span class="line">avro-memory-logger.channels = memory-channel</span><br><span class="line"></span><br><span class="line">avro-memory-logger.sources.avro-source.type = avro</span><br><span class="line">avro-memory-logger.sources.avro-source.bind = hadoop000</span><br><span class="line">avro-memory-logger.sources.avro-source.port = 44444</span><br><span class="line"></span><br><span class="line">avro-memory-logger.sinks.logger-sink.type = logger</span><br><span class="line"></span><br><span class="line">avro-memory-logger.channels.memory-channel.type = memory</span><br><span class="line"></span><br><span class="line">avro-memory-logger.sources.avro-source.channels = memory-channel</span><br><span class="line">avro-memory-logger.sinks.logger-sink.channel = memory-channel</span><br></pre></td></tr></table></figure>
<p><strong>先启动 avro-memory-logger</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--name avro-memory-logger  \</span><br><span class="line">--conf $FLUME_HOME/conf  \</span><br><span class="line">--conf-file $FLUME_HOME/conf/avro-memory-logger.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>
<p><strong>再启动 exec-memory-avro</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--name exec-memory-avro  \</span><br><span class="line">--conf $FLUME_HOME/conf  \</span><br><span class="line">--conf-file $FLUME_HOME/conf/exec-memory-avro.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Flume</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试题02</title>
    <url>/2019/09/24/Java%E9%9D%A2%E8%AF%95%E9%A2%9802/</url>
    <content><![CDATA[<ul>
<li>Java 多线程模块</li>
<li>Java 反射模块</li>
<li>Java 对象拷贝模块</li>
<li>Java 异常模块</li>
<li>网络模块</li>
<li>设计模式模块</li>
<li>Spring / Spring MVC 模块</li>
</ul>
<p>题库来源于 <a href="https://www.javazhiyin.com/42272.html" target="_blank" rel="noopener">Java知音</a></p>
<a id="more"></a>
<h2 id="Java多线程模块"><a href="#Java多线程模块" class="headerlink" title="Java多线程模块"></a>Java多线程模块</h2><h3 id="51-ThreadLocal-是什么？有哪些使用场景"><a href="#51-ThreadLocal-是什么？有哪些使用场景" class="headerlink" title="51. ThreadLocal 是什么？有哪些使用场景"></a>51. ThreadLocal 是什么？有哪些使用场景</h3><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本而不会影响其它线程所对应的的副本</p>
<p>ThreadLocal 使用场景：数据库连接和 session 管理等</p>
<h3 id="52-synchronized-底层实现原理"><a href="#52-synchronized-底层实现原理" class="headerlink" title="52. synchronized 底层实现原理"></a>52. synchronized 底层实现原理</h3><p>synchronized 是由一对 monitorenter / monitorexit 指令实现的，monitor 对象时同步的基本实现单元，在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。</p>
<p>Java 6 的时候，JVM 虚拟机提供了三种不同的 monitor 实现： 偏向锁，轻量级锁和重量级锁，用于改进其性能</p>
<h3 id="53-synchronized-和-volatile-的区别是什么？"><a href="#53-synchronized-和-volatile-的区别是什么？" class="headerlink" title="53.synchronized 和 volatile 的区别是什么？"></a>53.synchronized 和 volatile 的区别是什么？</h3><ul>
<li>volatile 是<strong>变量</strong>修饰符；synchronized 是修饰<strong>类、方法、代码块</strong></li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞</li>
</ul>
<h3 id="54-synchronized-和-Lock-有什么区别？"><a href="#54-synchronized-和-Lock-有什么区别？" class="headerlink" title="54. synchronized 和 Lock 有什么区别？"></a>54. synchronized 和 Lock 有什么区别？</h3><ul>
<li>synchronized 可以给类、方法、代码块加锁；Lock 只能给代码块加锁</li>
<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；Lock 需要自己加锁和释放锁，如果使用不当，没有 unLock() 释放锁，就会造成死锁</li>
<li>通过 Lock 可以指导有没有成功获取锁，synchronized 无法知道</li>
</ul>
<h3 id="55-synchronized-和-ReentrantLock-区别是什么？"><a href="#55-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="55. synchronized 和 ReentrantLock 区别是什么？"></a>55. synchronized 和 ReentrantLock 区别是什么？</h3><ul>
<li>ReentrantLock 使用起来比较灵活，但是必须有释放锁配合动作</li>
<li>ReentrantLock 必须手动获取与释放锁；synchronized 不需要手动释放和开启锁</li>
<li>ReentrantLock 只使用于代码块锁；synchronized 可用于修饰方法、代码块等</li>
<li>ReentrantLock 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化</li>
</ul>
<h3 id="56-atomic-原理"><a href="#56-atomic-原理" class="headerlink" title="56. atomic 原理"></a>56. atomic 原理</h3><p>atomic 主要利用 CAS（Compare And Swap）和 volatile 和 native 方法俩保证原子操作，从而避免 synchronized 的高开销，执行效率提升</p>
<h2 id="Java-反射模块"><a href="#Java-反射模块" class="headerlink" title="Java 反射模块"></a>Java 反射模块</h2><h3 id="57-什么是反射？"><a href="#57-什么是反射？" class="headerlink" title="57.什么是反射？"></a>57.什么是反射？</h3><p>反射是在运行状态中，对任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制</p>
<h3 id="58-什么是-Java-序列化？什么情况下需要序列化？"><a href="#58-什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="58. 什么是 Java 序列化？什么情况下需要序列化？"></a>58. 什么是 Java 序列化？什么情况下需要序列化？</h3><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来</p>
<ul>
<li>想把内存中的对象保存到一个文件中或者数据库中的时候</li>
<li>想用套接字在网络上传送对象的时候</li>
<li>想通过 RMI（远程方法调用）传输对象的时候</li>
</ul>
<h3 id="59-动态代理是什么？有哪些应用？"><a href="#59-动态代理是什么？有哪些应用？" class="headerlink" title="59. 动态代理是什么？有哪些应用？"></a>59. 动态代理是什么？有哪些应用？</h3><p>动态代理是运行时动态生成的代理类</p>
<p>动态代理的应用有 spring aop，hibernate 数据查询，RPC，Java 注解对象获取等</p>
<h3 id="60-怎么实现动态代理？"><a href="#60-怎么实现动态代理？" class="headerlink" title="60. 怎么实现动态代理？"></a>60. 怎么实现动态代理？</h3><p>JDK 原生动态代理和 cglib 动态代理：</p>
<ul>
<li>JDK 原生动态代理是基于接口实现的</li>
<li>cglib 是基于继承当前类的子类实现的</li>
</ul>
<h2 id="Java-对象拷贝模块"><a href="#Java-对象拷贝模块" class="headerlink" title="Java 对象拷贝模块"></a>Java 对象拷贝模块</h2><h3 id="61-为什么要试用克隆？"><a href="#61-为什么要试用克隆？" class="headerlink" title="61. 为什么要试用克隆？"></a>61. 为什么要试用克隆？</h3><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的 “状态” 就靠克隆方法了</p>
<h3 id="62-如何实现对象克隆？"><a href="#62-如何实现对象克隆？" class="headerlink" title="62. 如何实现对象克隆？"></a>62. 如何实现对象克隆？</h3><ul>
<li>实现 Cloneable 接口并重写 Object 类的 clone 方法</li>
<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆</li>
</ul>
<h3 id="63-深拷贝和浅拷贝的区别是什么？"><a href="#63-深拷贝和浅拷贝的区别是什么？" class="headerlink" title="63. 深拷贝和浅拷贝的区别是什么？"></a>63. 深拷贝和浅拷贝的区别是什么？</h3><ul>
<li>浅拷贝：当对象被复制时，复制他本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制</li>
<li>深拷贝：除了对象本身被复制外，对象所包含的所有成员变量也将复制</li>
</ul>
<h2 id="Java-Web-模块"><a href="#Java-Web-模块" class="headerlink" title="Java Web 模块"></a>Java Web 模块</h2><h3 id="64-JSP-和-servlet-有什么区别？"><a href="#64-JSP-和-servlet-有什么区别？" class="headerlink" title="64. JSP 和 servlet 有什么区别？"></a>64. JSP 和 servlet 有什么区别？</h3><p>JSP 是 servlet 技术的扩展，本质就是 servlet 的简易方式。servlet 和 JSP 最主要的不通点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表现层中的 html 中分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 侧重于控制逻辑。</p>
<h3 id="65-JSP-的-9-大内置对象"><a href="#65-JSP-的-9-大内置对象" class="headerlink" title="65. JSP 的 9 大内置对象"></a>65. JSP 的 9 大内置对象</h3><ul>
<li>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数</li>
<li>response：封装服务器对客户端的响应</li>
<li>pageContext：通过该对象可以获取其他对象</li>
<li>session：封装用户会话的对象</li>
<li>application：封装服务器运行环境的对象</li>
<li>out：输出服务器响应的输出流对象</li>
<li>config：Web 应用的配置对象</li>
<li>page：JSP 页面本身（相当于 Java 程序中的 this）</li>
<li>exception：封装页面抛出异常的对象</li>
</ul>
<h3 id="66-JSP-的-4-中作用域"><a href="#66-JSP-的-4-中作用域" class="headerlink" title="66. JSP 的 4 中作用域"></a>66. JSP 的 4 中作用域</h3><ul>
<li>page：代表与一个页面相关的对象和属性</li>
<li>request：代表与客户端发出的一个请求相关的对象和属性</li>
<li>session：代表与某个用户与服务器简历的一次会话相关的对象和属性</li>
<li>application：代表与整个 Web 应用程序相关的对象和属性</li>
</ul>
<h3 id="67-session-和-cookie-有什么区别-？"><a href="#67-session-和-cookie-有什么区别-？" class="headerlink" title="67. session 和 cookie 有什么区别 ？"></a>67. session 和 cookie 有什么区别 ？</h3><p><strong>session：</strong>是一种将会话状态保存到服务器端的技术</p>
<p><strong>cookie：</strong>是在 HTTP 协议下，Web 服务器保存在用户浏览器（客户端）上的小文本文件，可以包含有关用户信息。无论何时用户连接得到服务器，Web 站点都可以访问 Cookie 信息</p>
<ul>
<li><strong>存储位置不同：</strong>session 存储在服务器端；cookie 存储在浏览器端</li>
<li><strong>安全性不同：</strong>cookie 安全性一般，可以被伪造和修改</li>
<li><strong>容量和个数不同：</strong>cookie 有容量限制，每个站点下的 cookie 也有个数限制</li>
<li><strong>存储的多样性：</strong>session 可以存储在 Redis 中，数据库中，应用程序中；cookie 只能存储在浏览器中</li>
</ul>
<h3 id="68-session-工作原理"><a href="#68-session-工作原理" class="headerlink" title="68. session 工作原理"></a>68. session 工作原理</h3><p>session 是客户端登录完成之后，服务器会创建对应的 session，创建完成之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。</p>
<p>客户端每次访问服务器的时候，都会带着 sessionid，服务器拿到 session 之后，在内存中找到与之对应的 session 就可以正常工作了</p>
<h3 id="69-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#69-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="69. 如果客户端禁止 cookie 能实现 session 还能用吗？"></a>69. 如果客户端禁止 cookie 能实现 session 还能用吗？</h3><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用</p>
<h3 id="71-如何避免-SQL-注入？"><a href="#71-如何避免-SQL-注入？" class="headerlink" title="71. 如何避免 SQL 注入？"></a>71. 如何避免 SQL 注入？</h3><ul>
<li>使用预处理 PreparedStratement</li>
<li>使用正则表达式过滤掉字符中的特殊字符</li>
</ul>
<h3 id="72-什么是-XSS-攻击，如何避免？"><a href="#72-什么是-XSS-攻击，如何避免？" class="headerlink" title="72. 什么是 XSS 攻击，如何避免？"></a>72. 什么是 XSS 攻击，如何避免？</h3><p>XSS 攻击：跨站脚本攻击，是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里面插入恶意脚代码，当用户浏览该页面时，嵌入其中的脚本会被执行，从而达到恶意攻击用户的目的，比如盗取 cookie，破坏页面结构，重定向到其他网站等</p>
<p>预防 XSS 的核心是必须对输入的数据做过滤处理</p>
<h3 id="73-什么是-CSRF-攻击，如何避免？"><a href="#73-什么是-CSRF-攻击，如何避免？" class="headerlink" title="73. 什么是 CSRF 攻击，如何避免？"></a>73. 什么是 CSRF 攻击，如何避免？</h3><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求</p>
<p>防御手段：</p>
<ul>
<li>验证请求来源地址</li>
<li>关键操作添加验证码</li>
<li>在请求地址添加 token 并验证</li>
</ul>
<h2 id="Java-异常模块"><a href="#Java-异常模块" class="headerlink" title="Java 异常模块"></a>Java 异常模块</h2><h3 id="74-throw-和-throws-的区别"><a href="#74-throw-和-throws-的区别" class="headerlink" title="74. throw 和 throws 的区别"></a>74. throw 和 throws 的区别</h3><ul>
<li>throw：是真实抛出一个异常（语句的开头）</li>
<li>throws：是声明可能会抛出一个异常（方法声明的尾部）</li>
</ul>
<h3 id="75-final、finally、finalize-有什么区别？"><a href="#75-final、finally、finalize-有什么区别？" class="headerlink" title="75. final、finally、finalize 有什么区别？"></a>75. final、finally、finalize 有什么区别？</h3><ul>
<li>final：是修饰符，如果修饰类，此类不能别继承；如果修饰方法和变量，表示这个方法和变量不能被重写和覆盖</li>
<li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally部分存在，则一定会执行 finally 里面的代码</li>
<li>finalize：是 Object 的 protected 方法，子类可以覆盖该方法，以实现资源清理工作，GC 在回收对象之前调用该方法</li>
</ul>
<h3 id="76-try-catch-finally-中那个部分可以省略？"><a href="#76-try-catch-finally-中那个部分可以省略？" class="headerlink" title="76. try-catch-finally 中那个部分可以省略？"></a>76. try-catch-finally 中那个部分可以省略？</h3><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟着一个 catch 或者 finally</p>
<h3 id="77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p>finally 一定会执行成功，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行</p>
<h3 id="78-常见的异常类有哪些？"><a href="#78-常见的异常类有哪些？" class="headerlink" title="78. 常见的异常类有哪些？"></a>78. 常见的异常类有哪些？</h3><ul>
<li>NullPointerException <strong>空指针异常</strong></li>
<li>ClassNotFoundException <strong>指定类不存在</strong></li>
<li>NumberFormatException <strong>字符串转换为数字异常</strong></li>
<li>IndexOutOfBoundsException <strong>数组下标越界异常</strong></li>
<li>ClassCastException <strong>数据类型转换异常</strong></li>
<li>FileNotFoundException <strong>文件未找到异常</strong></li>
<li>NoSuchMethodException <strong>方法不存在异常</strong></li>
<li>IOException <strong>IO 异常</strong></li>
<li>SocketException <strong>Socket 异常</strong></li>
</ul>
<h2 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h2><h3 id="http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="http 响应码 301 和 302 代表的是什么？有什么区别？"></a>http 响应码 301 和 302 代表的是什么？有什么区别？</h3><ul>
<li>301：永久重定向；302：暂时重定向</li>
<li>301 对搜索引擎优化（SEO）更加有利；302 又被提示为网络拦截的风险</li>
</ul>
<h3 id="80-forward-和-redirect-的区别？"><a href="#80-forward-和-redirect-的区别？" class="headerlink" title="80. forward 和 redirect 的区别？"></a>80. forward 和 redirect 的区别？</h3><ul>
<li>forward 是转发和 redirect 是重定向</li>
<li>地址栏 url 显示：forward url 不会发生改变，redirect url 会发生改变</li>
<li>数据共享：forward 可以共享 request 里的数据，redirect 不能</li>
<li>效率：forward 比 redirect 效率高</li>
</ul>
<h3 id="81-简述-tcp-和-udp-的区别"><a href="#81-简述-tcp-和-udp-的区别" class="headerlink" title="81. 简述 tcp 和 udp 的区别"></a>81. 简述 tcp 和 udp 的区别</h3><p>tcp 和 udp 是 OSI 模型中的运输层中的协议，tcp 提供可靠的通信传输，而 udp 则常被用于广播，细节控制交给应用的通信传输，区别如下：</p>
<ul>
<li>tcp 面向连接；udp 面向非连接，即发送数据前不需要建立链接</li>
<li>tcp 提供可靠的服务（数据传输）；udp 无法保证</li>
<li>tcp 面向字节流；udp 面向报文</li>
<li>tcp 数据传输慢；udp 数据传输快</li>
</ul>
<h3 id="82-tcp-为什么要三次握手，两次握手不行吗？为什么？"><a href="#82-tcp-为什么要三次握手，两次握手不行吗？为什么？" class="headerlink" title="82. tcp 为什么要三次握手，两次握手不行吗？为什么？"></a>82. tcp 为什么要三次握手，两次握手不行吗？为什么？</h3><p>第一次握手：A 给 B 打电话说，你可以听到我吗？</p>
<p>第二次握手：B 收到 A 的信息，然后对 A 说：听得到你说话，你能听到我吗？</p>
<p>第三次握手：A 收到 B 的信息，然后说可以</p>
<p>在第三次捂手后，A 和 B 都确定了：我说话，你听得到，你说话，我听得到。就算是建立通信了</p>
<p>如果使用两次握手，name只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用了三次握手，服务器端没有收到来自客户端的在此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源</p>
<h3 id="83-说一下-tcp-粘包是怎么产生的"><a href="#83-说一下-tcp-粘包是怎么产生的" class="headerlink" title="83. 说一下 tcp 粘包是怎么产生的"></a>83. 说一下 tcp 粘包是怎么产生的</h3><p>tcp 粘包可能发生在发送端或者接收端：</p>
<ul>
<li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包</li>
<li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收</li>
</ul>
<h3 id="84-OSI-的七层模型都有哪些？"><a href="#84-OSI-的七层模型都有哪些？" class="headerlink" title="84. OSI 的七层模型都有哪些？"></a>84. OSI 的七层模型都有哪些？</h3><p>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输</p>
<p>数据链路层：负责建立和管理节点间的链路</p>
<p>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径</p>
<p>传输层：向用户提供可靠的端到端的查错和流量控制，保证报文的正确传输</p>
<p>会话层：向两个实体的表示层提供建立和使用练连接的方法</p>
<p>表示层：处理用户信息的表示问题，如编码，数据格式转换和加密解密等</p>
<p>应用层：直接向用户提供服务，完成用户希望在网络完成的各种工作</p>
<h3 id="85-get-和-post-请求有哪些区别？"><a href="#85-get-和-post-请求有哪些区别？" class="headerlink" title="85. get 和 post 请求有哪些区别？"></a>85. get 和 post 请求有哪些区别？</h3><p>get 请求会被浏览器主动缓存，而 post 不会</p>
<p>get 传递的参数有大小限制，而 post 没有</p>
<p>post 参数传输更安全，get 的参数会铭文限制在 url 上，post 不会</p>
<h2 id="设计模式模块"><a href="#设计模式模块" class="headerlink" title="设计模式模块"></a>设计模式模块</h2><h3 id="88-说一下常用设计模式"><a href="#88-说一下常用设计模式" class="headerlink" title="88. 说一下常用设计模式"></a>88. 说一下常用设计模式</h3><ul>
<li>单例模式：保证被创建一次，节省系统的开销</li>
<li>工厂模式（简单工厂，抽象工厂）：解耦代码</li>
<li>观察者模式：定义了对象之间的一对多依赖，当一个对象改变时，它的所有依赖者都会收到通知并自动更新</li>
<li>模板方法模式：定义了一个算法的骨架，将一些步骤延迟到子类中，模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤</li>
<li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类</li>
</ul>
<h3 id="89-简单工厂和抽象工厂有什么区别？"><a href="#89-简单工厂和抽象工厂有什么区别？" class="headerlink" title="89. 简单工厂和抽象工厂有什么区别？"></a>89. 简单工厂和抽象工厂有什么区别？</h3><p>简单工厂：用来生产同一级结构中的任意产品，对于新增的产品无能为力</p>
<p>工厂方法：用来生产同一级结构中的固定产品，支持增加任意产品</p>
<p>抽象工厂：用来生产不同产品族的全部产品，对于新增的产品无能为力；支持增加产品族</p>
<h2 id="Spring-Spring-MVC-模块"><a href="#Spring-Spring-MVC-模块" class="headerlink" title="Spring / Spring MVC 模块"></a>Spring / Spring MVC 模块</h2><h3 id="90-为什么要使用-spring？"><a href="#90-为什么要使用-spring？" class="headerlink" title="90. 为什么要使用 spring？"></a>90. 为什么要使用 spring？</h3><p>spring 提供 IOC 技术，容器会管理依赖的对象，从而不需要自己创建和管理对象，更轻松实现程序的解耦</p>
<p>spring 提供了事务的支持，使得事务操作更加方便</p>
<p>spring 提供了面向切面编程，这样可以更方便的处理某一类的问题</p>
<p>更方便的框架集成，可以集成其他的框架，比如 MyBatis 等</p>
<h3 id="91-解释一下什么是-AOP？"><a href="#91-解释一下什么是-AOP？" class="headerlink" title="91. 解释一下什么是 AOP？"></a>91. 解释一下什么是 AOP？</h3><p>AOP 是面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。</p>
<p>简单来说就是统一处理某一 “切面”（类）的问题的编程思想，比如处理日志、异常等</p>
<h3 id="92-解释一下什么是-IOC？"><a href="#92-解释一下什么是-IOC？" class="headerlink" title="92. 解释一下什么是 IOC？"></a>92. 解释一下什么是 IOC？</h3><p>IOC（Inversionof Control 控制反转）：是 spring 的核心，对弈 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象之间的关系</p>
<p>简单来说，控制指的是当前对象对内部成员的控制权</p>
<p>控制反转指的是，这种控制权不由当前对象管理了，由其他（类，第三方容器）来管理</p>
<h3 id="93-spring-有哪些主要模块？"><a href="#93-spring-有哪些主要模块？" class="headerlink" title="93. spring 有哪些主要模块？"></a>93. spring 有哪些主要模块？</h3><ul>
<li>spring core：框架的最基础部分，提供 IOC 和依赖注入的特性</li>
<li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法</li>
<li>spring dao：Data Access Object 提供了 JDBC 的抽象层</li>
<li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等</li>
<li>spring Web：提供了针对 Web 开发集成特性，例如文件上传，利用 Servlet Listeners 进行 IoC 容器初始化和针对 Web 的 ApplicationContext</li>
<li>spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现</li>
</ul>
<h3 id="94-spring-常用的注入方式有哪些？"><a href="#94-spring-常用的注入方式有哪些？" class="headerlink" title="94. spring 常用的注入方式有哪些？"></a>94. spring 常用的注入方式有哪些？</h3><ul>
<li>setter：属性注入</li>
<li>构造方法注入</li>
<li>注解方式注入</li>
</ul>
<h3 id="95-spring-中的-bean-是线程安全的吗？"><a href="#95-spring-中的-bean-是线程安全的吗？" class="headerlink" title="95. spring 中的 bean 是线程安全的吗？"></a>95. spring 中的 bean 是线程安全的吗？</h3><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度多行来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把 “singleton” 变更为 “prototype”，这样请求 bean 相当于 new Bean() 了，所以就可以保证线程安全了</p>
<p>有状态就是有数据存储功能</p>
<p>无状态就是不会保存数据</p>
<h3 id="96-spring-支持几种-bean-的作用域？"><a href="#96-spring-支持几种-bean-的作用域？" class="headerlink" title="96. spring 支持几种 bean 的作用域？"></a>96. spring 支持几种 bean 的作用域？</h3><ul>
<li>singleton：spring IoC 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值</li>
<li>prototype：每次从容器调用 bean 时都会创建一个新的实例，即每次 getBean() 相当于执行 new Bean() 操作（但是会造成很大的性能开销）</li>
<li>request：每次 http 请求都会创建一个 bean</li>
<li>session：同一个 http session 共享一个 bean 实例</li>
<li>global-seesion：用于 protlet 容器，因为每个 protlet 有单独的 session，globalsession 提供一个全局性的 http session</li>
</ul>
<h3 id="97-spring-自动装配-bean-有哪些方式？"><a href="#97-spring-自动装配-bean-有哪些方式？" class="headerlink" title="97. spring 自动装配 bean 有哪些方式？"></a>97. spring 自动装配 bean 有哪些方式？</h3><ul>
<li>no：默认值，表示没有自动装配</li>
<li>byName：它根据 bean 的名称注入对象依赖项</li>
<li>byType：它根据类型注入对象依赖项</li>
<li>构造函数：通过构造函数来注入依赖项，需要设置大量的参数</li>
<li>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配</li>
</ul>
<h3 id="98-spring-事务实现方式有哪些？"><a href="#98-spring-事务实现方式有哪些？" class="headerlink" title="98. spring 事务实现方式有哪些？"></a>98. spring 事务实现方式有哪些？</h3><p>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）</p>
<p>编码方式：提供编码形式的管理和维护事务</p>
<h3 id="99-说一下-spring-的事务隔离？"><a href="#99-说一下-spring-的事务隔离？" class="headerlink" title="99. 说一下 spring 的事务隔离？"></a>99. 说一下 spring 的事务隔离？</h3><p>spring 有五大隔离级别：</p>
<ul>
<li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库是什么就用什么</li>
<li>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读，脏读，不可重复读）</li>
<li>ISOATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读，不可重复读），SQL Server 的默认级别</li>
<li>ISOLATIONREPEATABLEREAD：课重复读，保证多次读取统一个数据时，其值都和事务开始时候的内容是一致，进制读取到别的事务未提交的数据（会造成幻读），MySQL 默认级别</li>
<li>ISOLATIO_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读，不可重复读，幻读</li>
</ul>
<p>脏读：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A</p>
<p>不可重复读：是指在一个事务内，多次读同一数据</p>
<p>幻读：指同一个事务内多次查询返回的结果集不一样。比如用一个事务 A 第一次查询的时候有 n 条记录，但是第二次同等条件下查询却有 n + 1 条记录。发送幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了</p>
<h3 id="100-说一下-spring-mvc-运行流程？"><a href="#100-说一下-spring-mvc-运行流程？" class="headerlink" title="100. 说一下 spring mvc 运行流程？"></a>100. 说一下 spring mvc 运行流程？</h3><ol>
<li>spring mvc 先将请求发送给 DispatcherServlet</li>
<li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller</li>
<li>DispatcherServlet 再把请求提交到对应的 Controller</li>
<li>Controller 进行业务逻辑处理后，会返回一个 ModelAndView</li>
<li>Dispathcher 查询一个或者多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li>
<li>视图对象负责渲染返回给客户端</li>
</ol>
<h3 id="101-spring-mvc-有哪些组件"><a href="#101-spring-mvc-有哪些组件" class="headerlink" title="101. spring mvc 有哪些组件"></a>101. spring mvc 有哪些组件</h3><ul>
<li><p>前端控制器 DispatcherServlet</p>
</li>
<li><p>映射控制器 HandlerMapping</p>
</li>
<li><p>处理器 Controller</p>
</li>
<li><p>模型和视图 ModelAndView</p>
</li>
<li><p>视图解析器 ViewResolver</p>
</li>
</ul>
<h3 id="102-RequestMapping-的作用是什么？"><a href="#102-RequestMapping-的作用是什么？" class="headerlink" title="102. @RequestMapping 的作用是什么？"></a>102. @RequestMapping 的作用是什么？</h3><p>将 http 请求映射到响应的类 / 方法上</p>
<h3 id="103-Autowired-的作用是什么？"><a href="#103-Autowired-的作用是什么？" class="headerlink" title="103. @Autowired 的作用是什么？"></a>103. @Autowired 的作用是什么？</h3><p>@Autowired 它可以对类成员变量，方法及构造函数进行标注，完成自动装配的工作，通过 @Autowired 的使用来消除 set  / get 方法</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试题01</title>
    <url>/2019/09/20/Java%E9%9D%A2%E8%AF%95%E9%A2%9801/</url>
    <content><![CDATA[<ul>
<li>Java 基础模块</li>
<li>Java 容器模块</li>
<li>Java多线程模块</li>
</ul>
<p>题库来源于 <a href="https://www.javazhiyin.com/42272.html" target="_blank" rel="noopener">Java知音</a></p>
<a id="more"></a>
<h2 id="Java-基础模块"><a href="#Java-基础模块" class="headerlink" title="Java 基础模块"></a>Java 基础模块</h2><h3 id="1-JDK-和-JRE-的区别"><a href="#1-JDK-和-JRE-的区别" class="headerlink" title="1. JDK 和 JRE 的区别"></a>1. JDK 和 JRE 的区别</h3><ul>
<li>JDK（Java Development Kit），Java 开发工具包，提供了 Java 开发环境和运行环境</li>
<li>JRE（Java Runtime Environment），Java 运行环境，为 Java 的运行提供了运行时所需要的环境</li>
</ul>
<p>JDK 包含了 JRE，同时包含了编译 Java 编码的编译器 Javac，包含了很多 Java 程序调试和分析的工具</p>
<h3 id="2-和-equals-的区别"><a href="#2-和-equals-的区别" class="headerlink" title="2. == 和 equals 的区别"></a>2. == 和 equals 的区别</h3><ul>
<li><p>==：对于基本类型和引用类型，效果是不同的</p>
<p>基本类型：比较值是否相同</p>
<p>引用类型：比较引用是否相同</p>
</li>
<li><p>equals：本质就是 ==，只不过 String 和 Integer 等类重写了 equals 方法，变成了值比较</p>
<p><strong>Object 中的 equals</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>String 中重写了 equals</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断两个对象的地址是否相同，相同直接返回 true，否则继续判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断另一个对象到底是不是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">// 转化为字符串类型</span></span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 判断两个字符串的长度</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 字符串长度相等就一个一个的判断字符串中每个字符是否相等</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true-吗？"><a href="#3-两个对象的-hashCode-相同，则-equals-也一定为-true-吗？" class="headerlink" title="3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？"></a>3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？</h3><p>两个对象的 hashCode 相同，equals() 不一定相同</p>
<p>hashCode 相同表示两个键值对的哈希值相同，哈希值相等并不代表键值对相等d</p>
<h3 id="4-final-在-Java-中有什么作用？"><a href="#4-final-在-Java-中有什么作用？" class="headerlink" title="4. final 在 Java 中有什么作用？"></a>4. final 在 Java 中有什么作用？</h3><ul>
<li>修饰的类叫做最终类</li>
<li>修饰的方法不能被重写</li>
<li>修饰的变量叫常量，常量必须初始化，初始化后值不能被修改</li>
</ul>
<h3 id="5-Java-中的-Math-round-1-5-等于多少？"><a href="#5-Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5. Java 中的 Math.round(-1, 5) 等于多少？"></a>5. Java 中的 Math.round(-1, 5) 等于多少？</h3><p>等于 -1，round() 是四舍五入（直接理解成向上取整）</p>
<h3 id="6-String-属于基础数据类型吗？"><a href="#6-String-属于基础数据类型吗？" class="headerlink" title="6. String 属于基础数据类型吗？"></a>6. String 属于基础数据类型吗？</h3><p>不属于，基础类型只有 8 种：bit，short，int，long，float，double，char，boolean</p>
<h3 id="7-Java-中操作字符串的都有哪些类？有什么区别？"><a href="#7-Java-中操作字符串的都有哪些类？有什么区别？" class="headerlink" title="7. Java 中操作字符串的都有哪些类？有什么区别？"></a>7. Java 中操作字符串的都有哪些类？有什么区别？</h3><ul>
<li>String</li>
<li>StringBuilder</li>
<li>StringBuffer</li>
</ul>
<p>StringBuilder 和 StringBuffer 都继承抽象列 AbstractStringBuilder</p>
<p>String 声明的是不可变的对象，每次操作都会生成新的对象，然后向指正指向新的对象</p>
<p>StringBuilder 和 StringBuffer 存储数据的字符数组没有被 final 修饰，值可以修改，AbstractStringBuilder 提供了一个自动扩容机制（默认初始长度为 16）长度不够的时候会自动扩容，扩展容量为原来的2倍加2，拼接字符串的效率比 Stirng 高</p>
<p>StringBuilder 执行效率高，但是线程不安全</p>
<p>StringBuffer 每个方法都用 synchronize 修饰，加锁和释放锁消耗资源，效率比 StringBuilder 低，但是线程安全</p>
<p>三者执行速度比较：StringBuilder &gt; StringBuffer &gt; String</p>
<h3 id="8-String-str-“i”-与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-“i”-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8. String str = “i” 与 String str = new String(“i”) 一样吗？"></a>8. String str = “i” 与 String str = new String(“i”) 一样吗？</h3><p>不一样，因为内存分配方式不一样</p>
<p><strong>String str = “i”：</strong>Java 虚拟机会将其分配到常量池中，如果池中有 “i” 就直接返回地址，没有就创建再返回地址</p>
<p><strong>String str = new String(“i”) ：</strong>直接在堆内存中开辟新空间</p>
<h3 id="9-字符串反转"><a href="#9-字符串反转" class="headerlink" title="9. 字符串反转"></a>9. 字符串反转</h3><p>使用 StringBuilder 或者 StringBuffer 的 reverse() 方法</p>
<h3 id="10-String-类的常用方法都有哪些？"><a href="#10-String-类的常用方法都有哪些？" class="headerlink" title="10. String 类的常用方法都有哪些？"></a>10. String 类的常用方法都有哪些？</h3><ul>
<li>indexOf()：返回指定字符的索引</li>
<li>charAt()：返回指定索引的字符</li>
<li>replace()：字符串替换</li>
<li>trim()：取出字符串两端空白</li>
<li>split()：分割字符串，返回一个分割后的字符串数组</li>
<li>getBytes()：返回字符串的 byte 类型数组</li>
<li>length()：返回字符串长度</li>
<li>toLowerCase()：将字符串转成小写字母</li>
<li>toUpperCase()：将字符串转成大小字母</li>
<li>substring()：截取字符串</li>
<li>equals()：字符串比较</li>
</ul>
<h3 id="11-抽象类必须有抽象方法吗？"><a href="#11-抽象类必须有抽象方法吗？" class="headerlink" title="11. 抽象类必须有抽象方法吗？"></a>11. 抽象类必须有抽象方法吗？</h3><p>不一定，但是包含抽象方法的<strong>类</strong>一定是抽象类</p>
<h3 id="12-普通类和抽象类有什么区别？"><a href="#12-普通类和抽象类有什么区别？" class="headerlink" title="12. 普通类和抽象类有什么区别？"></a>12. 普通类和抽象类有什么区别？</h3><ol>
<li>普通类不能有抽象方法，抽象类有抽象方法</li>
<li>抽象类不能被实例化，普通类可以</li>
<li>一个类继承抽象类，必须要重写抽象方法，如果不重写，说明子类也是抽象类</li>
</ol>
<h3 id="13-抽象类能用-final-修饰吗？"><a href="#13-抽象类能用-final-修饰吗？" class="headerlink" title="13. 抽象类能用 final 修饰吗？"></a>13. 抽象类能用 final 修饰吗？</h3><p>抽象类被定义就是用来被继承实现的，被 final 修饰的类不能被继承，所以 abstract 和 final 不能共存于一个类中，抽象类不能用 final 修饰</p>
<h3 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a>14. 接口和抽象类有什么区别？</h3><ul>
<li>结构：抽象类用 abstract 修饰；接口用 interface 修饰</li>
<li>继承：抽象类可以继承抽象类，实现接口，继承普通类（前提是被继承的类必须要有构造方法）；接口只能继承接口</li>
<li>实现：抽象类的子类使用 extends 继承；接口使用 implement 实现</li>
<li>构造方法：抽象类可以有构造方法；接口没有</li>
<li>实现数量：抽象类只能单继承；接口可以多实现</li>
<li>变量：抽象类中的变量可以是普通变量；接口里面的变量只能是公共静态变量</li>
<li>方法类型：抽象类中的方法可以有实现，也可以是抽象方法；接口的只能是抽象方法</li>
<li>访问修饰符：接口中的方法默认使用 public abstract；抽象类的方法可以使用 public 和 protected 修饰，如果用 private 就会报错</li>
</ul>
<p><strong>接口是设计的结果，抽象类是重构的结果</strong></p>
<h3 id="15-Java-中的-IO-流分为几种"><a href="#15-Java-中的-IO-流分为几种" class="headerlink" title="15. Java 中的 IO 流分为几种"></a>15. Java 中的 IO 流分为几种</h3><ul>
<li><p>按功能分：<strong>输入流</strong>和<strong>输出流</strong></p>
</li>
<li><p>按类型分：<strong>字节流</strong>和<strong>字符流</strong></p>
<p>区别是字节流按 8 位二进制字节为单位传输，字符流以 16 为二进制字符为单位传输</p>
</li>
</ul>
<h3 id="16-BIO、NIO-和-AIO-有什么区别？"><a href="#16-BIO、NIO-和-AIO-有什么区别？" class="headerlink" title="16. BIO、NIO 和 AIO 有什么区别？"></a>16. BIO、NIO 和 AIO 有什么区别？</h3><ul>
<li><strong>BIO：</strong>Block IO 同步阻塞式 IO，传统 IO，模式简单使用方便，并发处理能力低</li>
<li><strong>NIO：</strong>New IO 同步非阻塞式 IO，BIO 升级，客户端和服务端通过 Channel 通讯，实现多路复用</li>
<li><strong>AIO：</strong>Asynchronous IO 是 BIO 升级，也叫 NIO2，异步非阻塞 IO，异步 IO 的操作基于事件和回调机制</li>
</ul>
<h3 id="17-Files-的常用方法都有哪些"><a href="#17-Files-的常用方法都有哪些" class="headerlink" title="17. Files 的常用方法都有哪些"></a>17. Files 的常用方法都有哪些</h3><ul>
<li>Files.exists()：检测文件路径是否存在</li>
<li>Files.createFile()：创建文件</li>
<li>Files.createDirectory()：创建文件夹</li>
<li>Files.delete()：删除一个文件或目录</li>
<li>Files.copy()：复制文件</li>
<li>Files.move()：移动文件</li>
<li>Files.size()：查看文件个数</li>
<li>Files.read()：读取文件</li>
<li>Files.write()：写入文件</li>
</ul>
<h2 id="Java-容器模块"><a href="#Java-容器模块" class="headerlink" title="Java 容器模块"></a>Java 容器模块</h2><h3 id="18-Java-容器都有哪些？"><a href="#18-Java-容器都有哪些？" class="headerlink" title="18. Java 容器都有哪些？"></a>18. Java 容器都有哪些？</h3><p>Java 容器分为 Collection 和 Map 两大类：</p>
<ul>
<li>Collection：<ul>
<li>List</li>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector</li>
<li>Stack</li>
<li>Set</li>
<li>HashSet</li>
<li>LinkedHashSet</li>
<li>TreeSet</li>
</ul>
</li>
<li>Map:<ul>
<li>HashMap</li>
<li>LinkedHasMap</li>
<li>TreeMap</li>
<li>ConcurrentHashMap</li>
<li>Hashtable</li>
</ul>
</li>
</ul>
<h3 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19. Collection 和 Collections 有什么区别？"></a>19. Collection 和 Collections 有什么区别？</h3><p>Collection 是一个集合接口，提供了对集合对象进行基本操作的通用接口</p>
<p>Collections 是一个包装类，包含了很多静态方法，不能被实例化，是一个工具类，时间对集合的查找、排序、替换、线程安全化等操作</p>
<h3 id="20-List、Set、Map-之间的区别是什么？"><a href="#20-List、Set、Map-之间的区别是什么？" class="headerlink" title="20. List、Set、Map 之间的区别是什么？"></a>20. List、Set、Map 之间的区别是什么？</h3><p>List、Set、Map 的区别主要体现在连个方面：元素是否有序，是否允许元素重复</p>
<table>
<thead>
<tr>
<th><strong>比较</strong></th>
<th><strong>List</strong></th>
<th><strong>Set</strong></th>
<th><strong>Map</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>继承接口</td>
<td>Collection</td>
<td>Collection</td>
<td></td>
</tr>
<tr>
<td>常见实现类</td>
<td>AbstractList(其常用子类有ArrayList、LinkedList、Vector)</td>
<td>AbstractSet(其常用子类有HashSet、LinkedHashSet、TreeSet)</td>
<td>HashMap、HashTable</td>
</tr>
<tr>
<td>常见方法</td>
<td>add( )、remove( )、clear( )、get( )、contains( )、size( )</td>
<td>add( )、remove( )、clear( )、contains( )、size( )</td>
<td>put( )、get( )、remove( )、clear( )、containsKey( )、containsValue( )、keySet( )、values( )、size( )</td>
</tr>
<tr>
<td>元素</td>
<td>可重复</td>
<td>不可重复(用<code>equals()</code>判断)</td>
<td>不可重复</td>
</tr>
<tr>
<td>顺序</td>
<td>有序</td>
<td>无序(实际上由HashCode决定)</td>
<td></td>
</tr>
<tr>
<td>线程安全</td>
<td>Vector线程安全</td>
<td></td>
<td>Hashtable线程安全</td>
</tr>
</tbody>
</table>
<h3 id="21-HashMap-和-Hashtable-有什么区别？"><a href="#21-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="21. HashMap 和 Hashtable 有什么区别？"></a>21. HashMap 和 Hashtable 有什么区别？</h3><p>HashMap 是继承自 AbstractMap 类，HashTable 是继承自 Dictionary 类，不过他们都实现了 map，Cloneable（可复制），Serializable（可序列化）三个接口</p>
<p>HashTable 比 HashMap 多提供了 elments() 和 contains() 两个方法</p>
<p><strong>底层结构：</strong></p>
<ul>
<li>HashMap：底层是哈希表数据结构，是线程不同步的，可以存储 null-null 键值对，替代了 HashTable，正因为可以存储 null-null 键值对，当使用 get 获取到 value 的值为 null 时，无法判断是不存在 key，还是这个 key 本身就是 null，所以不能通过 get 来判断 HashMap 中是否存在某个键，应该使用 containsKey() 方法来判断</li>
<li>Hashtable：底层是哈希表结构，是线程同步的，只支持 key-value 键值对</li>
</ul>
<p><strong>容量以及扩容：</strong></p>
<ul>
<li>Hashtable：初始容量是 11，每次扩充为原来的 2n + 1</li>
<li>HashMap：初始容量为 16，每次扩容为 2n</li>
</ul>
<p><strong>存储结构的哈希值：</strong></p>
<ul>
<li>HashTable：直接使用对象的 hasCode，hashCode 是 JDK 根据对象的地址或者字符串或者数字算出来的 int 类型的额数值（<a href="https://www.cnblogs.com/williamjie/p/9099141.html" target="_blank" rel="noopener">知识点链接</a>）</li>
<li>HashMap：哈希表 + 链表（<strong>可能会转化为红黑树</strong>）</li>
</ul>
<h3 id="22-如何决定使用-HashMap-还是-TreeMap？"><a href="#22-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="22. 如何决定使用 HashMap 还是 TreeMap？"></a>22. 如何决定使用 HashMap 还是 TreeMap？</h3><ul>
<li>HashMap：在 Map 中插入、删除、定位一个元素这类操作</li>
<li>TreeMap：对一个 key 集合进行有序遍历</li>
</ul>
<h3 id="23-HashMap-实现原理"><a href="#23-HashMap-实现原理" class="headerlink" title="23. HashMap 实现原理"></a>23. HashMap 实现原理</h3><p>HashMap 基于 Hash 算法实现，通过 put(key, value) 存储，get(key) 来获取</p>
<p>当传入 key 值时，HashMap 会根据 key.hashCode()  计算出 hash 值，根据 hash 值将 value 保存在 buket 里，如果哈希值相同（哈希冲突），当 hash 冲突个数比较小的时候，就用链表，多的话自动转化为红黑树</p>
<h3 id="24-HashSet-实现原理"><a href="#24-HashSet-实现原理" class="headerlink" title="24. HashSet 实现原理"></a>24. HashSet 实现原理</h3><p>HashSet 基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存元素，相关操作直接调用底层 HashMap 的相关方法实现，HashSet 不允许有重复值出现</p>
<h3 id="25-ArrayList-和-LinkedList-的区别是什么？"><a href="#25-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="25. ArrayList 和 LinkedList 的区别是什么？"></a>25. ArrayList 和 LinkedList 的区别是什么？</h3><p><strong>数据结构实现：</strong></p>
<ul>
<li>ArrayList：是动态数组的数据结构实现</li>
<li>LinkedList：是双向链表的数据结构实现</li>
</ul>
<p><strong>随机访问效率：</strong></p>
<p>ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储结构，每次访问的时间复杂度都是  O(n)</p>
<p><strong>删除和增加效率：</strong></p>
<p>在非首尾的增加和删除操作，LinkedList 比 ArrayList 效率高，因为 ArrayList 增加后删除操作要移动被操作位置以后的元素</p>
<p><strong>总结：</strong></p>
<p>频繁读取使用 ArrayList，频繁更改使用 LinkedList</p>
<h3 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26. 如何实现数组和 List 之间的转换？"></a>26. 如何实现数组和 List 之间的转换？</h3><p>数组转 List：使用 <strong>Arrays.asList(array)</strong> 进行转化</p>
<p>List 转数组：使用 List 自带的 <strong>toArray()</strong> 方法</p>
<h3 id="27-ArrayList-和-Vector-的区别是什么？"><a href="#27-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="27.ArrayList 和 Vector 的区别是什么？"></a>27.ArrayList 和 Vector 的区别是什么？</h3><p><strong>线程安全：</strong></p>
<ul>
<li>Vector 使用了 Synchronized 来实现线程同步，线程是安全的</li>
<li>ArrayList 是非线程安全的</li>
</ul>
<p><strong>性能：</strong></p>
<p>ArrayList 性能要优于 Vector</p>
<p><strong>扩容：</strong></p>
<p>ArrayList 和 Vector 都会根据实际的需要动态调整容量，Vector 会增加 1 倍，ArrayList 会增加 50%</p>
<h3 id="28-Array-和-ArrayList-有什么区别？"><a href="#28-Array-和-ArrayList-有什么区别？" class="headerlink" title="28. Array 和 ArrayList 有什么区别？"></a>28. Array 和 ArrayList 有什么区别？</h3><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象</p>
<p>Array 有固定大小，ArrayList 可以自动扩展</p>
<p>ArrayList 的内置方法比 Array 多</p>
<h3 id="29-在-Queue-中-poll-和-remove-有什么区别？"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="29. 在 Queue 中 poll() 和 remove() 有什么区别？"></a>29. 在 Queue 中 poll() 和 remove() 有什么区别？</h3><p><strong>相同点：</strong>都是返回第一个元素，并在队列中删除返回的对象</p>
<p><strong>不同点：</strong>如果没有元素，remove() 会直接抛出 NoSuchElementException 异常，poll() 会返回 null</p>
<h3 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30. 哪些集合类是线程安全的？"></a>30. 哪些集合类是线程安全的？</h3><p>线程安全：Vector，Hashtable，Stack</p>
<p>线程不安全：HashMap（在 JDK 1.5 后，Java.util.concurrent 并发包中有了对应的安全类 ConcurrentHashMap）</p>
<h3 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31. 迭代器 Iterator 是什么？"></a>31. 迭代器 Iterator 是什么？</h3><p>Iterator 接口提供任何 Collection 的接口，可以从一个 Collection 中使用迭代器方法来获取迭代器实例</p>
<p>迭代器取代了 Java 集合框架中的 Enumeration，允许调用者在迭代过程中移除元素</p>
<h3 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32. Iterator 怎么使用？有什么特点？"></a>32. Iterator 怎么使用？有什么特点？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    String obj = it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：更加安全，可以确保在当前遍历的集合元素被更改的时候，会抛出 ConcurrentModificationException 异常</p>
<h3 id="33-Iterator-和-Listlterator"><a href="#33-Iterator-和-Listlterator" class="headerlink" title="33. Iterator 和 Listlterator"></a>33. Iterator 和 Listlterator</h3><ul>
<li>Iterator 可以遍历 Set 和 List 集合，ListIterator 只能遍历 List</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历</li>
<li>ListIterator 实现 Iterator，然后添加了一些额外的功能，比如添加，替换，获取前后节点索引</li>
</ul>
<h3 id="34-怎么确保一个集合不能被修改"><a href="#34-怎么确保一个集合不能被修改" class="headerlink" title="34. 怎么确保一个集合不能被修改"></a>34. 怎么确保一个集合不能被修改</h3><p>可以使用 Collection.unmodifiableCollection(Collection c) 方法来创建一个只读集合，一旦发生改变，就会抛出 Java.lang.UnsupportedOperationException 异常</p>
<h2 id="Java-多线程模块"><a href="#Java-多线程模块" class="headerlink" title="Java 多线程模块"></a>Java 多线程模块</h2><h3 id="35-并行和并发有什么区别？"><a href="#35-并行和并发有什么区别？" class="headerlink" title="35. 并行和并发有什么区别？"></a>35. 并行和并发有什么区别？</h3><p><strong>并行：</strong>多个处理器或多核处理器同时处理多个任务</p>
<p><strong>并发：</strong>多个任务在同一个 CPU 核上，按细分的时间片轮流执行，从逻辑上看是同时执行的</p>
<h3 id="36-线程和进程的区别？"><a href="#36-线程和进程的区别？" class="headerlink" title="36. 线程和进程的区别？"></a>36. 线程和进程的区别？</h3><p>一个程序至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度</p>
<h3 id="37-守护线程是什么？"><a href="#37-守护线程是什么？" class="headerlink" title="37. 守护线程是什么？"></a>37. 守护线程是什么？</h3><p>守护线程是运行在后台的一种特殊进程，独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件</p>
<p>在 Java 中的垃圾回收线程就是特殊的守护线程</p>
<h3 id="38-线程有几种实现方式？"><a href="#38-线程有几种实现方式？" class="headerlink" title="38. 线程有几种实现方式？"></a>38. 线程有几种实现方式？</h3><ol>
<li>继承 Thread 类</li>
<li>实现 Runnable 接口</li>
<li>实现 Callable 接口，通过 FutureTask 包装器来创建 Thread 线程</li>
<li>通过线程池创建线程，使用线程池接口 ExecutorService 结合 Callable、Future 事件有返回结果的多线程</li>
</ol>
<p>前两种 <strong>无返回值</strong>：重写 run 方法，run 方法返回值 void</p>
<p>后两种 <strong>有返回值</strong>：通过 Callable 接口，要实现 call 方法，这个方法返回值为 Object，可以保存返回结果</p>
<h3 id="39-Runnable-和-Callable-有什么区别？"><a href="#39-Runnable-和-Callable-有什么区别？" class="headerlink" title="39. Runnable 和 Callable 有什么区别？"></a>39. Runnable 和 Callable 有什么区别？</h3><p>Runnable 没有返回值，Callable 有返回值，Callable 可以看作是 Runnable 的补充</p>
<h3 id="40-线程有哪些状态？"><a href="#40-线程有哪些状态？" class="headerlink" title="40. 线程有哪些状态？"></a>40. 线程有哪些状态？</h3><ol>
<li>初始：新创建了一个线程对象，但还没有调用 start() 方法</li>
<li>运行：Java 线程中将就绪（ready）和运行中（running）两种状态统称为 ”运行“，线程对象创建后，其他线程调用了该对象的 start() 方法，该对象的线程位于可运行线程池中，等待被线程调用选中，获取 CPU 资源，此时处于就绪状态（ready）。就绪状态的线程在获得 CPU 时间片后变为运行状态（running）</li>
<li>阻塞：表示线程阻塞于锁</li>
<li>等待：进入该状态的线程需要等待其他线程做出一些特定的动作（通知或中断）</li>
<li>超时等待：不同于 waiting，它可以在指定时间后自行返回</li>
<li>终止：表示该线程已经执行完毕</li>
</ol>
<h3 id="41-sleep-和-wait-有什么区别？"><a href="#41-sleep-和-wait-有什么区别？" class="headerlink" title="41. sleep() 和 wait() 有什么区别？"></a>41. sleep() 和 wait() 有什么区别？</h3><ul>
<li>类不同：sleep 来自Thread，wait 来自Object</li>
<li>释放锁：sleep 不释放锁，wait 释放锁</li>
<li>用法不同：sleep 时间到会自动回复，wait 可以使用 notify() 或 notifyAll() 直接唤醒</li>
</ul>
<h3 id="42-notify-和-notifyAll-有什么区别？"><a href="#42-notify-和-notifyAll-有什么区别？" class="headerlink" title="42. notify() 和 notifyAll() 有什么区别？"></a>42. notify() 和 notifyAll() 有什么区别？</h3><p>notifyAll() 会唤醒所有线程，notify() 只会唤醒一个线程</p>
<p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，不成功则留在锁池等待锁被释放后重新竞争</p>
<p>notify() 只能唤醒一个线程，具体唤醒哪一个线程，由虚拟机控制</p>
<h3 id="43-线程的-run-和-start-有什么区别"><a href="#43-线程的-run-和-start-有什么区别" class="headerlink" title="43.线程的 run() 和 start() 有什么区别"></a>43.线程的 run() 和 start() 有什么区别</h3><p>start() 用于启动线程，run() 用于执行线程的运行时代码</p>
<p>run() 可以重复调用，而 start() 执行嗲用一次</p>
<h3 id="44-线程池创建方式"><a href="#44-线程池创建方式" class="headerlink" title="44. 线程池创建方式"></a>44. 线程池创建方式</h3><p>最核心的是最后一种：</p>
<ul>
<li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li>
<li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li>
<li>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li>
<li>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li>
<li>newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li>
<li>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li>
<li><strong>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</strong></li>
</ul>
<h3 id="45-线程池都有哪些状态"><a href="#45-线程池都有哪些状态" class="headerlink" title="45. 线程池都有哪些状态"></a>45. 线程池都有哪些状态</h3><ul>
<li>RUNNING：接收新任务，处理等待队列中的任务</li>
<li>SHUTDOWN：不接收新的任务提交，会处理继续等待队列中的任务</li>
<li>STOP：不接收新的任务提交，不再处理等待队列中的任务，中断正在执行的线程</li>
<li>TIDYING：所有任务都销毁了，workCount 为 0，线程池的状态转化为 TIDYING 时，会执行钩子方法 terminated()</li>
<li>TERMINATED：terminated() 方法结束后的状态</li>
</ul>
<h3 id="46-线程池中-submit-和-execute-方法有什么区别？"><a href="#46-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="46. 线程池中 submit() 和 execute() 方法有什么区别？"></a>46. 线程池中 submit() 和 execute() 方法有什么区别？</h3><ul>
<li>execute()：只能执行 Runnable 类型的任务</li>
<li>submit()：可以执行 Runnable 和 Callable 类型的任务</li>
</ul>
<h3 id="47-在-Java-程序中怎么保证多线程的运行安全？"><a href="#47-在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="47. 在 Java 程序中怎么保证多线程的运行安全？"></a>47. 在 Java 程序中怎么保证多线程的运行安全？</h3><ol>
<li>使用安全类，java.util.concurrent 的类</li>
<li>使用自动锁 synchronized</li>
<li>使用手动锁 Lock</li>
</ol>
<h3 id="48-多线程中-synchronized-锁升级的原理是什么？"><a href="#48-多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="48. 多线程中 synchronized 锁升级的原理是什么？"></a>48. 多线程中 synchronized 锁升级的原理是什么？</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p><strong>锁的升级的目的：</strong>锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h3 id="49-什么是死锁？"><a href="#49-什么是死锁？" class="headerlink" title="49. 什么是死锁？"></a>49. 什么是死锁？</h3><p>当线程 A 独占锁 a，并尝试去获取独占锁 b 的同时，线程 B 独占锁 b，并尝试获取独占锁 a 的情况，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象</p>
<h3 id="50-怎么防止死锁？"><a href="#50-怎么防止死锁？" class="headerlink" title="50. 怎么防止死锁？"></a>50. 怎么防止死锁？</h3><ul>
<li>尽量使用 tryLock(long timeout, TimeUnit unit) 的方法（ReentrantLock、ReetrantReadWriteLock），设置超时时间，超时可以退出防止死锁</li>
<li>尽量使用 Java.util.concurrent 并发类代替自己手写锁</li>
<li>尽量降低锁的使用力度</li>
<li>尽量不要几个功能使用同一把锁</li>
<li>尽量减少同步代码块</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java知识点day02(常用关键字)</title>
    <url>/2019/09/19/Java%E7%9F%A5%E8%AF%86%E7%82%B9day02-%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="修饰："><a href="#修饰：" class="headerlink" title="修饰："></a>修饰：</h3><p>类的变量，方法，方法块</p>
<ul>
<li><strong>修饰变量时：</strong>如果该变量时 public 时，则可以使用 <strong>类名.修饰变量名</strong> 调用该变量，static 修饰的变量可能会有线程安全的问题，当 static 修饰了共享的变量，在现场交互中就有可能造成安全问题，解决办法：<ol>
<li>将被修饰的对象换成线程安全的对象</li>
<li>手动加锁</li>
</ol>
</li>
<li><strong>修饰方法时：</strong>表示该方法与类无关，任何类都可以直接访问，但是被 static 修饰的方法只能调用被 static 修饰的变量，static 修饰的方法没有线程问题，方法中的局部变量保存在栈中，每个栈都是隔离的，不会有问题</li>
<li><strong>修饰方法块：</strong>静态代码块，加载 .class 到内存中的时候，先初始化 static 的代码块，常常用于初始化一些值</li>
</ul>
<h3 id="父类和子类加载顺序："><a href="#父类和子类加载顺序：" class="headerlink" title="父类和子类加载顺序："></a>父类和子类加载顺序：</h3><ol>
<li>父类静态变量初始化</li>
<li>父类静态代码块初始化</li>
<li>子类静态变量初始化</li>
<li>子类静态代码块初始化</li>
<li>父类构造方法</li>
<li>子类构造方法</li>
</ol>
<h3 id="规律："><a href="#规律：" class="headerlink" title="规律："></a>规律：</h3><ul>
<li><strong>父类的静态变量和静态代码块比子类优先初始化</strong></li>
<li><strong>静态变量和静态代码块比类构造器优先初始化</strong></li>
</ul>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>定义：不变的，不可改变的</p>
<h3 id="修饰：-1"><a href="#修饰：-1" class="headerlink" title="修饰："></a>修饰：</h3><ul>
<li><strong>类：</strong>表示该类是无法被继承的</li>
<li><strong>方法：</strong>表示该方法是无法被重写（Override）</li>
<li><strong>变量：</strong>内存地址不可改变，且在声明的时候初始化就必须要完成</li>
</ul>
<p>被 final 的修饰的对象，对象的内存地址不可以更改，但是对象中的内容可以更改</p>
<h2 id="try-amp-catch-amp-finally"><a href="#try-amp-catch-amp-finally" class="headerlink" title="try &amp; catch &amp; finally"></a>try &amp; catch &amp; finally</h2><p>用于捕捉异常的一套流程</p>
<ul>
<li>try：用来确定代码指定的范围</li>
<li>catch：捕捉可能有可能会发生的异常</li>
<li>finally：用来执行一定要执行的代码块，无论有没有异常发生，总要执行 finally 语句，为程序提供了一个统一的出口，使程序能正常退出</li>
</ul>
<p>如果 catch 中发生了异常，finally 还会继续执行，finally 中的代码执行完成后，才会抛出 catch 中的异常</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>用来修饰某个共享变量，意思是当前共享变量的值被修改后，会及时通知到其他线程上，其他线程就能知道当前共享的变量已经被修改了</p>
<h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>用来修饰类变量，意思是当前变量是无需进行序列化的，在序列化时，就会忽略该变量</p>
<h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>一般用在接口的方法上，意思是对于该接口，实现类无需强制实现，但自己必须有默认实现</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java知识点day01(String &amp; Long)</title>
    <url>/2019/09/18/Java%E7%9F%A5%E8%AF%86%E7%82%B9day01-String-Long/</url>
    <content><![CDATA[<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![second_hello](D:\Blog\myblog\source\_posts\Java知识点day01-String-Long\second_hello.png)![second_hello](D:\Blog\myblog\source\_posts\Java知识点day01-String-Long\second_hello.png)<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"hello"</span>;</span><br><span class="line">    str = <span class="string">"hello"</span>;</span><br><span class="line">    str = <span class="string">"world"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次 hello</p>
<p><img src="/2019/09/18/Java知识点day01-String-Long/first_hello.png" alt="first_hello"></p>
<p>第二次 hello</p>
<p><img src="/2019/09/18/Java知识点day01-String-Long/second_hello.png" alt="second_hello"></p>
<p>第三次 world</p>
<p><img src="/2019/09/18/Java知识点day01-String-Long/third_world.png" alt="third_world"></p>
<p>可以看出，str 对象并没有变化，但是指向的内存地址改变了</p>
<p><strong>原因</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>String 类被 <strong>final 修饰</strong>，不可以被继承</li>
<li>value[] 也被 final 修饰，说明这个是一个常量数组，一旦被赋值，<strong>内存地址</strong>就不可以再修改</li>
<li>value[] 被声明为<strong>私有属性</strong>，外部无法访问到，也没有 set / get 方法</li>
</ol>
<p>所以针对于当前 String 的对象锁做的操作都是无法影响到 value[]，也就是当前对象指向的那个值，比如 replace，split，substring 等等都无法影响到当前值，只有把生成的新值返回给对象才会有效（其实是在字符串常量池中重新生成了一个新的字符串而已，原来的字符串也还在）</p>
<h3 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h3><p><strong>原因</strong></p>
<ol>
<li>当前所用的编码集不包含当前语言的编码</li>
<li>二进制转化操作时，并没有强制规定字符编码</li>
</ol>
<h3 id="相等判断"><a href="#相等判断" class="headerlink" title="相等判断"></a>相等判断</h3><p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断两个对象的地址是否相同，相同直接返回 true，否则继续判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断另一个对象到底是不是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">// 转化为字符串类型</span></span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 判断两个字符串的长度</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 字符串长度相等就一个一个的判断字符串中每个字符是否相等</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>建议使用谷歌的第三方工具包 Guava，里面提供了一系列方法，操作类似于 Scala 语言，不过多说明</p>
<h2 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h2><p>Long 类型有缓存，他实现了一种缓存机制，缓存了从 -128 到 127 内所有的 Lang 值，也就是说如果使用这个范围内的值，直接冲缓存中拿</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LongCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存，范围从 -128 到 127，+1 是因为还有 0</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> Long[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，Jvm 加载类的时候优先初始化这部分代码</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Long(i - <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Long 时，推荐使用 ValueOf 方法，因为 ValueOf 会从缓存中去拿，如果命中缓存，会减小资源的开销</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper安装和Hadoop安装</title>
    <url>/2019/09/15/Zookeeper%E5%AE%89%E8%A3%85%E5%92%8CHadoop%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Zookeeper-安装"><a href="#Zookeeper-安装" class="headerlink" title="Zookeeper 安装"></a>Zookeeper 安装</h2><p><strong>关闭防火墙！！！</strong></p>
<h3 id="下载-JDK-1-8-版本"><a href="#下载-JDK-1-8-版本" class="headerlink" title="下载 JDK 1.8 版本"></a>下载 JDK 1.8 版本</h3><h3 id="下载-Zookeeper-安装包"><a href="#下载-Zookeeper-安装包" class="headerlink" title="下载 Zookeeper 安装包"></a>下载 Zookeeper 安装包</h3><p><a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">下载链接</a></p>
<h3 id="解压到-Linux-的路径下（一般是-usr-local-）"><a href="#解压到-Linux-的路径下（一般是-usr-local-）" class="headerlink" title="解压到 Linux 的路径下（一般是 /usr/local ）"></a>解压到 Linux 的路径下（一般是 /usr/local ）</h3><h3 id="配置-Linux-环境变量"><a href="#配置-Linux-环境变量" class="headerlink" title="配置 Linux 环境变量"></a>配置 Linux 环境变量</h3><p>配置 JAVA_HOME 和 ZOOKEERER_HOME</p>
<h3 id="配置-Zookeeper-单节点"><a href="#配置-Zookeeper-单节点" class="headerlink" title="配置  Zookeeper 单节点"></a>配置  Zookeeper 单节点</h3><ol>
<li><p>在 zookeeper 文件夹下创建 data 文件夹和 logs 文件夹，用于存放数据和日志</p>
</li>
<li><p>进入 conf 中，将 zoo_sample.cfg 复制一份并重命名为 zoo.cfg</p>
</li>
<li><p>配置 zoo.fg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">dataLogDir=/usr/local/zookeeper*/logs</span><br><span class="line">dataDir=/usr/local/zookeeper*/data</span><br><span class="line">clientPort=2181</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置完成后即可开启单节点模式</p>
</li>
</ol>
<h3 id="配置-Zookeeper-多节点模式（分布式）"><a href="#配置-Zookeeper-多节点模式（分布式）" class="headerlink" title="配置 Zookeeper 多节点模式（分布式）"></a>配置 Zookeeper 多节点模式（分布式）</h3><ol>
<li><p>先多搞几台虚拟机（具体多少台开心就好，最好 3 台起步，之后用 scp 复制文件到其他虚拟机）</p>
</li>
<li><p>配置 hosts 文件</p>
</li>
<li><p>配置 ssh 免密登录</p>
</li>
<li><p>给所有虚拟机搞上 JDK 和 Zookeeper</p>
</li>
<li><p>每台虚拟机的 Zookeeper 的目录下创建 data 和 logs 目录</p>
</li>
<li><p>配置 zoo.cfg（和单节点一样搞出来的）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">dataDir=/var/lib/zookeeper</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line"><span class="meta">#</span> 主机名、心跳端口、数据端口</span><br><span class="line">server.1=zoo1:2888:3888</span><br><span class="line">server.2=zoo2:2888:3888</span><br><span class="line">server.3=zoo3:2888:3888</span><br></pre></td></tr></table></figure>
</li>
<li><p>给每个节点加上 myid（myid 是放到 zookeeper 配置的 dataDir 的路径下的）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iweb5 ： echo '1'&gt;/usr/local/zookeeper/data/myid</span><br><span class="line">iweb6 ： echo '2'&gt;/usr/local/zookeeper/data/myid</span><br><span class="line">iweb7 ： echo '3'&gt;/usr/local/zookeeper/data/myid</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后就可以启动集群了</p>
</li>
</ol>
<h2 id="Hadoop-安装"><a href="#Hadoop-安装" class="headerlink" title="Hadoop 安装"></a>Hadoop 安装</h2><p><strong>关闭防火墙！！！</strong></p>
<p>这玩意儿环境配置老费劲了</p>
<p>直接跳过单节点模式，要是 hadoop 玩单节点就没有必要搞集群了</p>
<p><strong>PS：</strong>Hadoop 是在 Zookeeper 环境配置好了的基础上安装的</p>
<h3 id="JDK-环境变量-SSH-免密-hosts-文件配置"><a href="#JDK-环境变量-SSH-免密-hosts-文件配置" class="headerlink" title="JDK || 环境变量 || SSH 免密 || hosts 文件配置"></a>JDK || 环境变量 || SSH 免密 || hosts 文件配置</h3><p>这里要把 HADOOP_HOME 配置进去，添加到 PATH 里面的时候要把 /bin 和 /sbin 都配置进去</p>
<h3 id="架设虚拟机（实验用的两台，加上-Zookeeper-一共-5-台）"><a href="#架设虚拟机（实验用的两台，加上-Zookeeper-一共-5-台）" class="headerlink" title="架设虚拟机（实验用的两台，加上 Zookeeper 一共 5 台）"></a>架设虚拟机（实验用的两台，加上 Zookeeper 一共 5 台）</h3><h3 id="开始配置-Hadoop"><a href="#开始配置-Hadoop" class="headerlink" title="开始配置 Hadoop"></a>开始配置 Hadoop</h3><ol>
<li><p>先配置 hadoop*/etc/hadoop/hadoop-env.sh，将里面的 ${JAVA_HOME} 改成当前 JAVA_HOME 的路径</p>
</li>
<li><p>配置 hadoop*/etc/hadoop/core-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定hdfs的ns为ns --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultF S<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 指定hadoop临时目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop-2.8.4/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定zookeeper地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>ha.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bigdata1:2181,bigdata2:2181,bigdata3:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 hadoop*/etc/hadoop/hdfs-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定HDFS副本的数量默认3个 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定hdfs的nameservices为ns，需要和core-site.xml中的保持一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.nameservices<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ns下面有两个NameNode，分别是nn1，nn2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.namenodes.ns<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>nn1,nn2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- nn1的RPC通信地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bigdata5:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- namenode-1的http通信地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.ns.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bigdata5:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- namenode-2的RPC通信地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bigdata6:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- namenode-2的http通信地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.ns.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bigdata6:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定NameNode的元数据在JournalNode上的存放位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>qjournal://bigdata1:8485;bigdata2:8485;bigdata3:8485/ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定JournalNode在本地磁盘存放数据的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.journalnode.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop-2.8.4/journaldata<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启NameNode失败自动切换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置失败自动切换实现方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.proxy.provider.ns<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置隔离机制方法，多个机制用换行分割，即每个机制暂用一行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.methods<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            sshfence</span><br><span class="line">            shell(/bin/true)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用sshfence隔离机制时需要ssh免登陆 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.ssh.private-key-files<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/.ssh/id_rsa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置sshfence隔离机制超时时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.ssh.connect-timeout<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>30000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 hadoop*/etc/hadoop/mapred-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定mr框架为yarn方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 hadoop*/etc/hadoop/yarn-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启RM高可用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定RM的cluster id --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.cluster-id<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yrc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定RM的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.rm-ids<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>rm1,rm2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 分别指定RM的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname.rm1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bigdata5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname.rm2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bigdata6<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定zk集群地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.zk-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bigdata1:2181,bigdata2:2181,bigdata3:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoopMaster:8032<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoopMaster:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoopMaster:8031<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="同步配置"><a href="#同步配置" class="headerlink" title="同步配置"></a>同步配置</h3><p>通过 scp 命令将 hadoop*/ 发送给所有主机</p>
<h3 id="集群启动准备工作（所有命令官方文档都有）"><a href="#集群启动准备工作（所有命令官方文档都有）" class="headerlink" title="集群启动准备工作（所有命令官方文档都有）"></a>集群启动准备工作（所有命令官方文档都有）</h3><ol>
<li><p>在 Zookeeper 的主机上启动 journalnode</p>
<p>（这里我必须要说一句，一定要先启动 journalnode，我就是忘记要启动 journalnode，最后耗费了我一个多小时才启动成功）</p>
</li>
<li><p>格式化 namenode （在 active 主机上执行）</p>
<p>hdfs namenode -format</p>
</li>
<li><p>格式化 zkfc（在 active 主机上执行）</p>
<p>hdfs zkfc -formatZK</p>
</li>
<li><p>启动 active 上的 namenode</p>
<p>hadoop-daemon.sh start namenode</p>
</li>
<li><p>在 standby 执行</p>
<p>hdfs namenode -bootstrapStandby</p>
</li>
<li><p>手动启动以下程序</p>
<p>[ hdfs ]</p>
<ul>
<li>namenode</li>
<li>zkfc</li>
<li>datanode</li>
</ul>
<p>[ yarn ]</p>
<ul>
<li>resourcemanager</li>
<li>nodemanager</li>
</ul>
</li>
<li><p>启动 Web 客户端查看信息</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper概念</title>
    <url>/2019/09/15/Zookeeper%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>分布式协调服务，为其他的分布式程序提供协调服务</p>
<p>本身就是分布式程序</p>
<p>提供的服务包含：</p>
<ul>
<li>主从协调</li>
<li>服务器节点动态上下线</li>
<li>统一配置管理</li>
<li>分布式共享锁</li>
<li>统一名称服务</li>
</ul>
<p>底层其实只包含两层服务</p>
<ul>
<li><strong>管理</strong>（存储和读取）用户程序提交的<strong>数据</strong></li>
<li>为用户程序<strong>提供</strong>数据节点<strong>监听服务</strong></li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>一个 leader，多个 follower 组成的集群</li>
<li>全局数据一致：每个 ZK 服务器的数据都是一致的，无论哪个客户端连接到 ZK，获得的数据都是一样的</li>
<li>分布式读写：更新请求转发，由 leader 实施</li>
<li>顺序执行：来自同一个客户的更新请求按照发送顺序执行</li>
<li>数据更新原子性：要么成功，要么失败</li>
<li>实时性：在一定时间范围内，客户端能得到最新的数据</li>
</ol>
<p><img src="/2019/09/15/Zookeeper概念/zkservice.jpg" alt="zkservice"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol>
<li>层次化结构，和文件系统差不多</li>
<li>每个节点叫做 znode，并且有唯一路径标识</li>
<li>每个 znode 可以包含数据和子节点（EPHEMERAL 不能有子节点，因为是短暂节点，连接断开后会自己删除）</li>
<li>客户端可以在节点上设置监视器</li>
</ol>
<h2 id="Znode-节点类型"><a href="#Znode-节点类型" class="headerlink" title="Znode 节点类型"></a>Znode 节点类型</h2><ul>
<li>有两种节点类型<ol>
<li>短暂（EPHEMERAL）断开连接自己删除</li>
<li>持久（PERSISTENT）断开连接不删除</li>
</ol>
</li>
<li>org.apache.zookeeper.CreateMode中定义了<strong>四种节点类型</strong><ol>
<li>PERSISTENT：永久节点</li>
<li>EPHEMERAL：临时节点</li>
<li>PERSISTENT_SEQUENTIAL：永久节点、序列化</li>
<li>EPHEMERAL_SEQUENTIAL：临时节点、序列化</li>
</ol>
</li>
<li>创建 znode 是设置顺序表示，znode 名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护，设置顺序是为了对所有事件进行全局排序，客户端就可以通过顺序推断事件的顺序</li>
</ul>
<h2 id="分布式共享锁"><a href="#分布式共享锁" class="headerlink" title="分布式共享锁"></a>分布式共享锁</h2><p><strong>作用：</strong>做到一次只有指定个数的客户端访问服务器的某些资源</p>
<p>实现步骤：</p>
<ol>
<li>客户端上线就向 ZK 注册，创建一把锁</li>
<li>判断是否只有一个客户端在工作，是则该客户端处理业务</li>
<li>获取父节点下注册的所有锁，判断自己是否是注册号码最小的，是则处理业务</li>
</ol>
<p><strong>当业务处理完成后必须要释放锁</strong></p>
<h2 id="ZooKeeper-中的时间"><a href="#ZooKeeper-中的时间" class="headerlink" title="ZooKeeper 中的时间"></a>ZooKeeper 中的时间</h2><ul>
<li><p>Zxid</p>
<p>致使 ZooKeeper 节点状态改变的每一个操作都将使节点接收到一个 zxid 格式的时间戳，并且<strong>这个时间戳全局有序</strong>。</p>
<ul>
<li>cZxid：是节点的<strong>创建时间</strong>所对应的 Zxid 格式时间戳。</li>
<li>mZxid：是节点的<strong>修改时间</strong>所对应的 Zxid 格式时间戳，与其子节点无关。</li>
<li>pZxid：<strong>该节点的子节点</strong>（或该节点）的最近一次 创建 / 删除 的修改时间所对应的 cZxid 格式时间戳（注：只与 本节点 / 该节点的子节点，有关；<strong>与孙子节点无关</strong></li>
</ul>
</li>
<li><p>版本号</p>
<p>对节点的每一个操作都将致使这个节点的版本号增加。每个节点维护着三个版本号，他们分别为：</p>
<ul>
<li>version 节点数据版本号</li>
<li>cversion 子节点版本号</li>
<li>aversion 节点所拥有的 ACL 版本号</li>
</ul>
</li>
</ul>
<h2 id="Zookeeper-投票机制"><a href="#Zookeeper-投票机制" class="headerlink" title="Zookeeper 投票机制"></a>Zookeeper 投票机制</h2><p>用例子比较直观（配置 3 台机器）：</p>
<p>每台机器的 “票” 结构：（myid，zxid）</p>
<ul>
<li><p>情况一</p>
<p>T1（1，0）    T2（2，0）    T3（3，0）</p>
<p>T1 启动给自己投一票</p>
<p>T2 启动给自己投一票，收到 T1 的票，并将自己的票发给 T1</p>
<p>—— 判断（如果 zxid 相同，则 myid 大的作为 leader）T2 作为 leader</p>
<p>T3 启动已经有 leader 了，不再参与选举直接指定 T2 作为leader</p>
</li>
<li><p>情况二</p>
<p>T1 （1，3）    T2（2，10）    T3（3，5）</p>
<p>T2 作为 leader 然后嗝屁了</p>
<p>T1 和 T3 选举</p>
<p>—— 判断（如果 zxid 不同，则直接判断 zxid，和 myid 无关）T3 作为 leader</p>
<p>T2 重新上线后由于 T3 已经是 leader，直接指定 T3 为 leader</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus高级操作</title>
    <url>/2019/09/11/MyBatis-Plus%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="推荐视频"><a href="#推荐视频" class="headerlink" title="推荐视频"></a>推荐视频</h2><p><a href="https://www.imooc.com/learn/1130" target="_blank" rel="noopener">MyBatis 入门教程</a></p>
<p><a href="https://www.imooc.com/learn/1171" target="_blank" rel="noopener">MyBatis 进阶教程</a></p>
<a id="more"></a>
<h2 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>修改某一行的数据中的某一列的标志值，用值来表示是否已经 <strong>“逻辑删除”</strong> 并不是真的在表中真正的删除这条数据</p>
<ol>
<li><p>先在 application.yml 中配置标志值</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line"><span class="attr">  global-config:</span></span><br><span class="line"><span class="attr">    db-config:</span></span><br><span class="line">      <span class="comment"># 未删除的值</span></span><br><span class="line"><span class="attr">      logic-not-delete-value:</span> <span class="number">0</span></span><br><span class="line">      <span class="comment"># 已删除的值</span></span><br><span class="line"><span class="attr">      logic-delete-value:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建配置类 MyBatisPlusConfiguration.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 mybatis-plus 3.1.0 以上的版本中不再需要添加这一步</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISqlInjector <span class="title">sqlInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogicSqlInjector();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在实体类中添加注解 @TableLogic</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"user_pro"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Long managerId;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="meta">@TableField</span>(select = <span class="keyword">false</span>, value = <span class="string">"deleted"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p>这些方法在使用的时候都会自己在后面添加一个 and deleted = 0，表示只操作删除标志位为 0（未删除） 的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.mp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.chentyit.mp2.dao.UserMapper;</span><br><span class="line"><span class="keyword">import</span> cn.chentyit.mp2.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11 09:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogicDelete</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会把删除标志位置 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = userMapper.deleteById(<span class="number">1094592041087729666L</span>);</span><br><span class="line">        System.out.println(<span class="string">"影响行数："</span> + rows);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只查询出删除标志位为 0 的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只更新标志位为 0 的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setAge(<span class="number">26</span>);</span><br><span class="line">        user.setId(<span class="number">1088248166370832385L</span>);</span><br><span class="line">        <span class="keyword">int</span> rows = userMapper.updateById(user);</span><br><span class="line">        System.out.println(<span class="string">"影响行数："</span> + rows);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h2><h3 id="介绍：-1"><a href="#介绍：-1" class="headerlink" title="介绍："></a>介绍：</h3><p>自动填充值以及一些额外的数据</p>
<h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><ol>
<li><p>先在实体类中添加注解 @TableField(fill = FieldFill.INSERT) 和 @TableField(fill = FieldFill.UPDATE)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"user_pro"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long managerId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField</span>(fill = FieldFill.INSERT)</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField</span>(fill = FieldFill.UPDATE)</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="meta">@TableField</span>(select = <span class="keyword">false</span>, value = <span class="string">"deleted"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现 MetaObjectHandler 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11 10:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在插入的时候填充</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断数据库中是否有这个列</span></span><br><span class="line">        <span class="keyword">boolean</span> hasSetter = metaObject.hasSetter(<span class="string">"createTime1"</span>);</span><br><span class="line">        <span class="comment">// 如果有就向这个列插入数据</span></span><br><span class="line">        <span class="comment">// 如果没有就不插</span></span><br><span class="line">        <span class="keyword">if</span> (hasSetter) &#123;</span><br><span class="line">            setInsertFieldValByName(<span class="string">"createTime"</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在更新的时候填充</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否已经设置了值</span></span><br><span class="line">        Object val = getFieldValByName(<span class="string">"updateTime"</span>, metaObject);</span><br><span class="line">        <span class="comment">// 如果设置了就不进行自动填充</span></span><br><span class="line">        <span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</span><br><span class="line">            setUpdateFieldValByName(<span class="string">"updateTime"</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11 10:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"陈天翼"</span>);</span><br><span class="line">        user.setAge(<span class="number">21</span>);</span><br><span class="line">        user.setEmail(<span class="string">"chentyit@qq.com"</span>);</span><br><span class="line">        user.setManagerId(<span class="number">1088248166370832385L</span>);</span><br><span class="line">        <span class="keyword">int</span> rows = userMapper.insert(user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"影响行数："</span> + rows);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setAge(<span class="number">27</span>);</span><br><span class="line">        user.setId(<span class="number">1171615225418350594L</span>);</span><br><span class="line">        <span class="keyword">int</span> rows = userMapper.updateById(user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"影响行数："</span> + rows);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="乐观锁插件"><a href="#乐观锁插件" class="headerlink" title="乐观锁插件"></a>乐观锁插件</h2><p>（注：多写的情况下使用悲观锁，多读的场景使用乐观锁）</p>
<h3 id="介绍：-2"><a href="#介绍：-2" class="headerlink" title="介绍："></a>介绍：</h3><p>取出记录时，获取当前 version</p>
<p>更新时，带上这个 version</p>
<p>版本正确更新成功，错误更新失败</p>
<h3 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h3><ol>
<li><p>添加插件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加乐观锁插件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在实体类中的版本属性上面添加 @Verison</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"user_pro"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ****</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ****</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11 11:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果使用条件构造器 则添加构造器不能复用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> version = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setEmail(<span class="string">"chentyit2@qq.com"</span>);</span><br><span class="line">        user.setId(<span class="number">1171617683297271809L</span>);</span><br><span class="line">        user.setVersion(version);</span><br><span class="line">        <span class="keyword">int</span> rows = userMapper.updateById(user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"影响行数："</span> + rows);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="性能分析插件"><a href="#性能分析插件" class="headerlink" title="性能分析插件"></a>性能分析插件</h2><h3 id="介绍：-3"><a href="#介绍：-3" class="headerlink" title="介绍："></a>介绍：</h3><p>输出每条 SQL 语句的执行时间，只在测试和开发环境使用，因为开销很大</p>
<h3 id="使用：-2"><a href="#使用：-2" class="headerlink" title="使用："></a>使用：</h3><ol>
<li><p>在配置类中添加性能分析插件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ******</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加性能分析插件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(&#123;<span class="string">"dev"</span>, <span class="string">"test"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PerformanceInterceptor <span class="title">performanceInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PerformanceInterceptor performanceInterceptor = <span class="keyword">new</span> PerformanceInterceptor();</span><br><span class="line">        <span class="comment">// 格式化 SQL 语句</span></span><br><span class="line">        performanceInterceptor.setFormat(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 设置执行最大时间</span></span><br><span class="line">        performanceInterceptor.setMaxTime(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> performanceInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 JVM 参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示使用开发环境</span></span><br><span class="line">-Dspring.profiles.active=dev</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="执行-SQL-分析打印"><a href="#执行-SQL-分析打印" class="headerlink" title="执行 SQL 分析打印"></a>执行 SQL 分析打印</h3><ol>
<li><p>先添加依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.p6spy.engine.spy.P6SpyDriver</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">jdbc:p6spy:mysql://127.0.0.1:3306/mp?characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=Asia/Shanghai</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加配置文件 spy.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.log=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory</span><br><span class="line"># 自定义日志打印</span><br><span class="line">logMessageFormat=com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger</span><br><span class="line"># 日志输出到控制台</span><br><span class="line">appender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger</span><br><span class="line"># 使用日志系统记录 sql</span><br><span class="line">#appender=com.p6spy.engine.spy.appender.Slf4JLogger</span><br><span class="line"># 设置 p6spy driver 代理</span><br><span class="line">deregisterdrivers=true</span><br><span class="line"># 取消JDBC URL前缀</span><br><span class="line">useprefix=true</span><br><span class="line"># 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.</span><br><span class="line">excludecategories=info,debug,result,batch,resultset</span><br><span class="line"># 日期格式</span><br><span class="line">dateformat=yyyy-MM-dd HH:mm:ss</span><br><span class="line"># 实际驱动可多个</span><br><span class="line">#driverlist=org.h2.Driver</span><br><span class="line"># 是否开启慢SQL记录</span><br><span class="line">outagedetection=true</span><br><span class="line"># 慢SQL记录标准 2 秒</span><br><span class="line">outagedetectioninterval=2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="修改日志输出路径"><a href="#修改日志输出路径" class="headerlink" title="修改日志输出路径"></a>修改日志输出路径</h3><ol>
<li><p>先修改配置文件 spy.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 日志输出到控制台</span><br><span class="line"># appender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger</span><br></pre></td></tr></table></figure>
</li>
<li><p>再添加参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logfile=log.log</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>日志就会打印到 log.log 文件里面了</p>
<h2 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h2><h3 id="介绍：-4"><a href="#介绍：-4" class="headerlink" title="介绍："></a>介绍：</h3><p>多个用户间使用同一套程序，但每个用户之间实现数据隔离</p>
<h3 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h3><ol>
<li><p>添加分页插件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11 09:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// **********</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加分页插件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PaginationInterceptor paginationInterceptor = <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ISqlParser&gt; sqlParserList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        TenantSqlParser tenantSqlParser = <span class="keyword">new</span> TenantSqlParser();</span><br><span class="line">        tenantSqlParser.setTenantHandler(<span class="keyword">new</span> TenantHandler() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 添加租户信息的值</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Expression <span class="title">getTenantId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> LongValue(<span class="number">1088248166370832385L</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 哪个字段添加信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getTenantIdColumn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"manager_id"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 是否向某个表中添加租户信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> tableName</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> true 表示过滤掉，不增加； false 表示不过滤，添加租户信息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doTableFilter</span><span class="params">(String tableName)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"user_pro"</span>.equals(tableName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        sqlParserList.add(tenantSqlParser);</span><br><span class="line">        paginationInterceptor.setSqlParserList(sqlParserList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特定-SQL-过滤"><a href="#特定-SQL-过滤" class="headerlink" title="特定 SQL 过滤"></a>特定 SQL 过滤</h3><ul>
<li><p>方法一：在上面的代码中添加以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">paginationInterceptor.setSqlParserFilter(<span class="keyword">new</span> ISqlParserFilter() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 是否执行过滤</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> false 代表不增加过滤信息；true 代表增加过滤信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        MappedStatement ms = SqlParserHelper.getMappedStatement(metaObject);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"cn.chentyit.mp2.dao.UserMapper.selectById"</span>.equals(ms.getId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：在 Mapper 的自定义方法上添加注解 @SqlParser(filter = true)，在查询的时候不需要添加租户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11 09:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SqlParser</span>(filter = <span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user_pro $&#123;ew.customSqlSegment&#125;"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">mySelectList</span><span class="params">(@Param(Constants.WRAPPER)</span>Wrapper&lt;User&gt; wrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="动态表名-SQL-解析器"><a href="#动态表名-SQL-解析器" class="headerlink" title="动态表名 SQL 解析器"></a>动态表名 SQL 解析器</h2><h3 id="介绍：-5"><a href="#介绍：-5" class="headerlink" title="介绍："></a>介绍：</h3><p>分表存储</p>
<h3 id="使用：-3"><a href="#使用：-3" class="headerlink" title="使用："></a>使用：</h3><ol>
<li><p>添加动态表名插件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11 09:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; myTableName = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ******************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加分页插件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PaginationInterceptor paginationInterceptor = <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ISqlParser&gt; sqlParserList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置动态表名</span></span><br><span class="line">        DynamicTableNameParser dynamicTableNameParser =  <span class="keyword">new</span> DynamicTableNameParser();</span><br><span class="line">        Map&lt;String, ITableNameHandler&gt; tableNameHandlerMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 返回值为 MyBatisPlusConfiguration.myTableName.set("user_2019"); 设置的表名</span></span><br><span class="line">        tableNameHandlerMap.put(<span class="string">"user_pro"</span>, (metaObject, sql, tableName) -&gt; myTableName.get());</span><br><span class="line">        dynamicTableNameParser.setTableNameHandlerMap(tableNameHandlerMap);</span><br><span class="line">        sqlParserList.add(dynamicTableNameParser);</span><br><span class="line"></span><br><span class="line">        paginationInterceptor.setSqlParserList(sqlParserList);</span><br><span class="line">        paginationInterceptor.setSqlParserFilter(<span class="keyword">new</span> ISqlParserFilter() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 是否执行过滤</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> false 代表不增加过滤信息；true 代表增加过滤信息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">                MappedStatement ms = SqlParserHelper.getMappedStatement(metaObject);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"cn.chentyit.mp2.dao.UserMapper.selectById"</span>.equals(ms.getId())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在代码中调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置表名</span></span><br><span class="line">    MyBatisPlusConfiguration.myTableName.set(<span class="string">"user_2019"</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="SQL-注入器"><a href="#SQL-注入器" class="headerlink" title="SQL 注入器"></a>SQL 注入器</h2><h3 id="介绍：-6"><a href="#介绍：-6" class="headerlink" title="介绍："></a>介绍：</h3><p>自定义 SQL</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p>创建定义方法的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11 14:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteAllMethod</span> <span class="keyword">extends</span> <span class="title">AbstractMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappedStatement <span class="title">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指定的 SQL</span></span><br><span class="line">        String sql = <span class="string">"delete from "</span> + tableInfo.getTableName();</span><br><span class="line">        <span class="comment">// mapper 接口方法名</span></span><br><span class="line">        String method = <span class="string">"deleteAll"</span>;</span><br><span class="line"></span><br><span class="line">        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> addDeleteMappedStatement(mapperClass, method, sqlSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建注入器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11 14:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlInjector</span> <span class="keyword">extends</span> <span class="title">DefaultSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        List&lt;AbstractMethod&gt; methodList = <span class="keyword">super</span>.getMethodList(mapperClass);</span><br><span class="line">        methodList.add(<span class="keyword">new</span> DeleteAllMethod());</span><br><span class="line">        <span class="keyword">return</span> methodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Mapper 中加入自定义方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11 15:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Chentyit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11 09:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">MyMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SqlParser</span>(filter = <span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user_pro $&#123;ew.customSqlSegment&#125;"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">mySelectList</span><span class="params">(@Param(Constants.WRAPPER)</span>Wrapper&lt;User&gt; wrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MyBatis-Plus</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala 操作外部数据</title>
    <url>/2019/09/10/Scala-%E6%93%8D%E4%BD%9C%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<ul>
<li>操作文件 &amp;&amp; 网络数据</li>
<li>操作XML</li>
<li>操作 MySQL</li>
</ul>
<a id="more"></a>
<h2 id="操作文件-amp-amp-网络数据"><a href="#操作文件-amp-amp-网络数据" class="headerlink" title="操作文件 &amp;&amp; 网络数据"></a>操作文件 &amp;&amp; 网络数据</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter09</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FileApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> file = <span class="type">Source</span>.fromFile(<span class="string">"E:\\test\\data.txt"</span>)(scala.io.<span class="type">Codec</span>.<span class="type">UTF8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按行读</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">readLine</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            <span class="keyword">for</span> (line &lt;- file.getLines()) &#123;</span><br><span class="line">                println(line)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//    readLine()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照字符读</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">readChar</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            <span class="keyword">for</span> (ele &lt;- file) &#123;</span><br><span class="line">                println(ele)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// readChar()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取网络文件</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">readNet</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            <span class="keyword">val</span> file = <span class="type">Source</span>.fromURL(<span class="string">"http://www.chentyit.com"</span>)</span><br><span class="line">            <span class="keyword">for</span> (line &lt;- file.getLines()) &#123;</span><br><span class="line">                println(line)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        readNet()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="操作XML"><a href="#操作XML" class="headerlink" title="操作XML"></a>操作XML</h2><h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><p>test.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">symbols</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">symbol</span> <span class="attr">ticker</span>=<span class="string">"AAPL"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">units</span>&gt;</span>200<span class="tag">&lt;/<span class="name">units</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">symbol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">units</span>&gt;</span>200<span class="tag">&lt;/<span class="name">units</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">symbol</span> <span class="attr">ticker</span>=<span class="string">"IBM"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">units</span>&gt;</span>400<span class="tag">&lt;/<span class="name">units</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">symbol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">symbols</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>XMLApp.scala</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter09</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.&#123;<span class="type">FileInputStream</span>, <span class="type">InputStreamReader</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.xml.<span class="type">XML</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">XMLApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadXML</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">//    val xml = XML.load(this.getClass.getClassLoader.getResource("test.xml"))</span></span><br><span class="line">        <span class="comment">//    println(xml)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    val xml = XML.load(new FileInputStream("E:\\Program\\IDEA-workplace\\Scala\\scalatrain\\src\\main\\resources\\test.xml"))</span></span><br><span class="line">        <span class="comment">//    print(xml)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> xml = <span class="type">XML</span>.load(<span class="keyword">new</span> <span class="type">InputStreamReader</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"E:\\Program\\IDEA-workplace\\Scala\\scalatrain\\src\\main\\resources\\test.xml"</span>)))</span><br><span class="line">        print(xml)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        loadXML()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><p>pk.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fix</span> <span class="attr">major</span>=<span class="string">"4"</span> <span class="attr">minor</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"BeginString"</span> <span class="attr">required</span>=<span class="string">"Y"</span>&gt;</span>FIX4.2<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"MsgType"</span> <span class="attr">required</span>=<span class="string">"Y"</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">trailer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"Signature"</span> <span class="attr">required</span>=<span class="string">"N"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"CheckSum"</span> <span class="attr">required</span>=<span class="string">"Y"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trailer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">messages</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">message</span> <span class="attr">name</span>=<span class="string">"Logon"</span> <span class="attr">msgtype</span>=<span class="string">"A"</span> <span class="attr">msgcat</span>=<span class="string">"admin"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"ResetSeqNumFlag"</span> <span class="attr">required</span>=<span class="string">"N"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"MaxMessageSize"</span> <span class="attr">required</span>=<span class="string">"N"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">group</span> <span class="attr">name</span>=<span class="string">"NoMsgTypes"</span> <span class="attr">required</span>=<span class="string">"N"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"RefMsgType"</span> <span class="attr">required</span>=<span class="string">"N"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"MsgDirection"</span> <span class="attr">required</span>=<span class="string">"N"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">message</span> <span class="attr">name</span>=<span class="string">"ResendRequest"</span> <span class="attr">msgtype</span>=<span class="string">"2"</span> <span class="attr">msgcat</span>=<span class="string">"admin"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"BeginSeqNo"</span> <span class="attr">required</span>=<span class="string">"Y"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"EndSeqNo"</span> <span class="attr">required</span>=<span class="string">"Y"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">messages</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fields</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">number</span>=<span class="string">"1"</span> <span class="attr">name</span>=<span class="string">"TradingEntityId"</span> <span class="attr">type</span>=<span class="string">"STRING"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">number</span>=<span class="string">"4"</span> <span class="attr">name</span>=<span class="string">"AdvSide"</span> <span class="attr">type</span>=<span class="string">"STRING"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span> <span class="attr">enum</span>=<span class="string">"X"</span> <span class="attr">description</span>=<span class="string">"CROSS"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span> <span class="attr">enum</span>=<span class="string">"T"</span> <span class="attr">description</span>=<span class="string">"TRADE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">number</span>=<span class="string">"5"</span> <span class="attr">name</span>=<span class="string">"AdvTransType"</span> <span class="attr">type</span>=<span class="string">"STRING"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span> <span class="attr">enum</span>=<span class="string">"N"</span> <span class="attr">description</span>=<span class="string">"NEW"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fields</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fix</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>XMLApp.scala</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter09</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.&#123;<span class="type">FileInputStream</span>, <span class="type">InputStreamReader</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.xml.<span class="type">XML</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">XMLApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readXMLAttr</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> xml = <span class="type">XML</span>.load(<span class="keyword">this</span>.getClass.getClassLoader.getResource(<span class="string">"pk.xml"</span>))</span><br><span class="line">        <span class="comment">//    println(xml)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到 &lt;header&gt; 下的 &lt;field&gt;</span></span><br><span class="line">        <span class="comment">//    val headerField = xml \ "header" \ "field"</span></span><br><span class="line">        <span class="comment">//    println(headerField)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到所有的 &lt;field&gt;</span></span><br><span class="line">        <span class="comment">//    val fields = xml \\ "field"</span></span><br><span class="line">        <span class="comment">//    for (field &lt;- fields) &#123;</span></span><br><span class="line">        <span class="comment">//      println(field)</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到 /header/field/name</span></span><br><span class="line">        <span class="comment">//    val fieldAttributes = (xml \ "header" \ "field").map(_ \ "@name")</span></span><br><span class="line">        <span class="comment">//    val fieldAttributes = (xml \ "header" \ "field" \\ "@name")</span></span><br><span class="line">        <span class="comment">//    for (filedAttribute &lt;- fieldAttributes) &#123;</span></span><br><span class="line">        <span class="comment">//      println(filedAttribute)</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到 name="Logon" 的 message</span></span><br><span class="line">        <span class="comment">//    val filters = (xml \\ "message").filter(_.attribute("name").exists(_.text.equals("Logon")))</span></span><br><span class="line">        <span class="comment">//    val filters = (xml \\ "message").filter(x =&gt; (x \ "@name").text.equals("Logon"))</span></span><br><span class="line">        <span class="comment">//    for (filter &lt;- filters) &#123;</span></span><br><span class="line">        <span class="comment">//      println(filter)</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到 header/field/name</span></span><br><span class="line">        (xml \ <span class="string">"header"</span> \ <span class="string">"field"</span>).map(x =&gt;(x \ <span class="string">"@name"</span>, x.text, x \ <span class="string">"@required"</span>)).foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        readXMLAttr()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="操作-MySQL"><a href="#操作-MySQL" class="headerlink" title="操作 MySQL"></a>操作 MySQL</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter09</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.&#123;<span class="type">Connection</span>, <span class="type">DriverManager</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MySQLApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> url = <span class="string">"jdbc:mysql://127.0.0.1:3306/mysql?characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=Asia/Shanghai"</span></span><br><span class="line">        <span class="keyword">val</span> userName = <span class="string">"root"</span></span><br><span class="line">        <span class="keyword">val</span> password = <span class="string">"Chentyit123456"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> connection: <span class="type">Connection</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 返回运行时的一个 class 类型</span></span><br><span class="line">            <span class="comment">// 不写也可以，但是建议写上</span></span><br><span class="line">            classOf[com.mysql.cj.jdbc.<span class="type">Driver</span>]</span><br><span class="line">            connection = <span class="type">DriverManager</span>.getConnection(url, userName, password)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 Statement，执行查询语句</span></span><br><span class="line">            <span class="keyword">val</span> statement = connection.createStatement()</span><br><span class="line">            <span class="keyword">val</span> resultSet = statement.executeQuery(<span class="string">"select host, user from user"</span>)</span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="keyword">val</span> host = resultSet.getString(<span class="string">"host"</span>)</span><br><span class="line">                <span class="keyword">val</span> user = resultSet.getString(<span class="string">"user"</span>)</span><br><span class="line"></span><br><span class="line">                println(<span class="string">s"<span class="subst">$host</span>, <span class="subst">$user</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; e.printStackTrace()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                connection.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala隐式转换</title>
    <url>/2019/09/10/Scala%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为一个已存在的类添加一个新的方法</p>
<p>Java：动态代理</p>
<p>Scala：隐式转换</p>
<a id="more"></a>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传一个简单的对象进来 (man)</span></span><br><span class="line"><span class="comment"> * 返回一个牛逼的对象回去 (SuperMan)</span></span><br><span class="line"><span class="comment"> * 然后简单对象就有了牛逼对象的方法了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">man2superman</span></span>(man: <span class="type">Man</span>): <span class="type">SuperMan</span> = <span class="keyword">new</span> <span class="type">SuperMan</span>(man.name)</span><br></pre></td></tr></table></figure>
<h2 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter08</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.<span class="type">File</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************* 人变超人 *********************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>() = &#123;</span><br><span class="line">    println(<span class="string">s"man[ <span class="subst">$name</span> ] eat ......"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fly</span></span>() = &#123;</span><br><span class="line">    println(<span class="string">s"superman[ <span class="subst">$name</span> ] fly ......"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************* 给 Scala 的文件对象添加 read 操作 *********************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichFile</span>(<span class="params">file: <span class="type">File</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">read</span></span>() = &#123;</span><br><span class="line">    <span class="type">Source</span>.fromFile(file.getAbsoluteFile).mkString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义隐式转换函数</span></span><br><span class="line">  <span class="comment">//  implicit def man2superman(man: Man): SuperMan = new SuperMan(man.name)</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  val man = new Man("cty")</span></span><br><span class="line">  <span class="comment">//  man.eat()</span></span><br><span class="line">  <span class="comment">//  man.fly()</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">file2RichFile</span></span>(file: <span class="type">File</span>): <span class="type">RichFile</span> = <span class="keyword">new</span> <span class="type">RichFile</span>(file)</span><br><span class="line">  <span class="keyword">val</span> file = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">"E:\\test\\data.txt"</span>)</span><br><span class="line">  println(file.read())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例二（切面封装）"><a href="#实例二（切面封装）" class="headerlink" title="实例二（切面封装）"></a>实例二（切面封装）</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.scala06</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.<span class="type">File</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************* 比较器的扩展 *******************/</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">trait</span> <span class="title">UserOrdering</span> <span class="keyword">extends</span> <span class="title">Ordering</span>[<span class="type">User</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">User</span>, y: <span class="type">User</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    x.age - y.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************* 对文件的读写的扩展 *******************/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichFile</span>(<span class="params">file: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">read</span></span>: <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="type">Source</span>.fromFile(file).mkString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(file: <span class="type">String</span>): <span class="type">File</span> = <span class="keyword">new</span> <span class="type">File</span>(file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************* 隐式函数 切面封装 *******************/</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 隐式对象</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">object</span> <span class="title">UserOrder</span> <span class="keyword">extends</span> <span class="title">UserOrdering</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">//</span> <span class="title">隐式函数</span></span></span><br><span class="line"><span class="class">  <span class="title">implicit</span> <span class="title">def</span> <span class="title">double2Int</span>(<span class="params">x: <span class="type">Double</span></span>) </span>= x.toInt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 File 转成 RichFile</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">file2RichFIle</span></span>(file: <span class="type">File</span>) = <span class="keyword">new</span> <span class="type">RichFile</span>(file.getAbsolutePath)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入切面封装的对象</span></span><br><span class="line"><span class="keyword">import</span> cn.chentyit.scala06.<span class="type">ImplicitContext</span>._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="type">List</span>(<span class="number">23</span>, <span class="number">43</span>, <span class="number">5</span>, <span class="number">42</span>).sorted)</span><br><span class="line"></span><br><span class="line">    println(<span class="type">List</span>(<span class="type">User</span>(<span class="string">"jack"</span>, <span class="number">20</span>), <span class="type">User</span>(<span class="string">"tom"</span>, <span class="number">18</span>)).sorted)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> i: <span class="type">Int</span> = <span class="number">100.9</span></span><br><span class="line">    println(i)</span><br><span class="line"></span><br><span class="line">    println(<span class="type">File</span>(<span class="string">"E:\\test\\data.txt"</span>).read)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="隐式参数（不建议使用）"><a href="#隐式参数（不建议使用）" class="headerlink" title="隐式参数（不建议使用）"></a>隐式参数（不建议使用）</h2><p>介绍：指的是在函数或者方法中，定义一个用 implicit 修饰的参数，此时 Scala 会尝试找到一个指定类型的，用 implicit 修饰的对象，即隐式值，并注入参数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter08</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置隐式参数的函数在没有传参的情况下会寻找作用域（方法，对象，伴生对象）中存在的一个隐式值并传入</span></span><br><span class="line"><span class="comment"> * 如果传参就直接将参数传递过去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitArgsApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> test = <span class="string">"test"</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">testParam</span></span>(<span class="keyword">implicit</span> name: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(name + <span class="string">"~~~~~~~~~~~~~~~~~~~~"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  implicit val name = "implicit_name"</span></span><br><span class="line">  <span class="comment">// 编译器会传一个已存在的隐式参数进入函数</span></span><br><span class="line">  <span class="comment">//  testParam</span></span><br><span class="line">  <span class="comment">//  testParam("cty")</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  implicit val s1 = "s1"</span></span><br><span class="line">  <span class="comment">//  implicit val s2 = "s2"</span></span><br><span class="line">  <span class="comment">// 编译器不知道应该传哪一个隐式参数进去 会报错</span></span><br><span class="line">  <span class="comment">//  testParam</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="隐式类"><a href="#隐式类" class="headerlink" title="隐式类"></a>隐式类</h2><p>介绍：对类增加 implicit 限定的类，其作用主要是对类的加强</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter08</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitClassApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorInt</span>(<span class="params">x: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(a: <span class="type">Int</span>) = a + x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorStr</span>(<span class="params">str: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(a: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">      <span class="keyword">var</span> i = str.toInt</span><br><span class="line">      <span class="keyword">return</span> i + a</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  println(<span class="number">1.</span>add(<span class="number">3</span>))</span><br><span class="line">  println(<span class="string">"12"</span>.add(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala函数高级操作</title>
    <url>/2019/09/10/Scala%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<ul>
<li>字符串高级操作</li>
<li>匿名函数</li>
<li>Curry 函数</li>
<li>高阶函数</li>
<li>综合例子</li>
<li>偏函数</li>
</ul>
<a id="more"></a>
<h2 id="字符串高级操作"><a href="#字符串高级操作" class="headerlink" title="字符串高级操作"></a>字符串高级操作</h2><h3 id="插入变量"><a href="#插入变量" class="headerlink" title="插入变量"></a>插入变量</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter07</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StringApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">"Hello"</span></span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"PK"</span></span><br><span class="line">    <span class="keyword">val</span> team = <span class="string">"AC Milan"</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">s"<span class="subst">$s</span> <span class="subst">$name</span> <span class="subst">$team</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter07</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StringApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> b =</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">          | 这是一个多行字符串</span></span><br><span class="line"><span class="string">          | Hello world</span></span><br><span class="line"><span class="string">          | Chentyit</span></span><br><span class="line"><span class="string">          |"</span><span class="string">""</span>.stripMargin</span><br><span class="line">    println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter07</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匿名函数：函数可以匿名，也可以不匿名</span></span><br><span class="line"><span class="comment"> * (参数名：参数类型) =&gt; 函数体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FunctoinApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> m1 = (x: <span class="type">Int</span>) =&gt; x + <span class="number">1</span></span><br><span class="line">  println(m1(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span> </span>= (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y</span><br><span class="line">  println(add(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Curry-函数"><a href="#Curry-函数" class="headerlink" title="Curry 函数"></a>Curry 函数</h2><h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter07</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CurryApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = x + y</span><br><span class="line">    println(sum(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原来接收两个参数的函数，转换成两个</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum2</span></span>(x: <span class="type">Int</span>)(y: <span class="type">Int</span>) = x + y</span><br><span class="line">    println(sum2(<span class="number">10</span>)(<span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.scala02</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun1</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> =&gt; <span class="type">Int</span> = &#123;</span><br><span class="line">        y: <span class="type">Int</span> =&gt; &#123;</span><br><span class="line">            println(<span class="string">s"<span class="subst">$x</span>, <span class="subst">$y</span>"</span>)</span><br><span class="line">            x + y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun2</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        x + y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * fn3 可以分步调用</span></span><br><span class="line"><span class="comment">   * fn2 不可以分步调用</span></span><br><span class="line"><span class="comment">   * fn1 可读性差</span></span><br><span class="line"><span class="comment">   * @param x</span></span><br><span class="line"><span class="comment">   * @param y</span></span><br><span class="line"><span class="comment">   * @return</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun3</span></span>(x: <span class="type">Int</span>)(y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        x + y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> re1 = fun1(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">val</span> re2 = re1(<span class="number">3</span>)</span><br><span class="line">        println(re2)</span><br><span class="line"></span><br><span class="line">        println(fun3(<span class="number">2</span>)(<span class="number">3</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="map-amp-amp-filter"><a href="#map-amp-amp-filter" class="headerlink" title="map &amp;&amp; filter"></a>map &amp;&amp; filter</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter07</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HighFuncApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> l = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map：逐个去操作集合中的每个元素</span></span><br><span class="line">    println(l.map((x: <span class="type">Int</span>) =&gt; x * <span class="number">2</span>))</span><br><span class="line">    println(l.map(x =&gt; x * <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下划线代表当前的元素</span></span><br><span class="line">    println(l.map(_ * <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤出符合条件的元素</span></span><br><span class="line">    println(l.map(_ * <span class="number">2</span>).filter(_ &gt; <span class="number">8</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reduce-amp-amp-fold"><a href="#reduce-amp-amp-fold" class="headerlink" title="reduce &amp;&amp; fold"></a>reduce &amp;&amp; fold</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter07</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HighFuncApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> l = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将两两相邻的元素相减</span></span><br><span class="line">    println(l.reduce(_ - _))</span><br><span class="line">    <span class="comment">// 从左边开始</span></span><br><span class="line">    <span class="comment">// 左边一个元素减右边一个</span></span><br><span class="line">    <span class="comment">// 得到的新值再去和右边的值组合再相减</span></span><br><span class="line">    println(l.reduceLeft(_ - _))</span><br><span class="line">    <span class="comment">// 和上面一样，只是组合方向不同</span></span><br><span class="line">    println(l.reduceRight(_ - _))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和 reduce 一样</span></span><br><span class="line">    <span class="comment">// 但是在计算开始会给一个初值和第一个参与计算的元素组合</span></span><br><span class="line">    println(l.fold(<span class="number">0</span>)(_ - _))</span><br><span class="line">    println(l.foldLeft(<span class="number">0</span>)(_ - _))</span><br><span class="line">    println(l.foldRight(<span class="number">0</span>)(_ - _))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flatten-amp-amp-flatMap"><a href="#flatten-amp-amp-flatMap" class="headerlink" title="flatten &amp;&amp; flatMap"></a>flatten &amp;&amp; flatMap</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter07</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HighFuncApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> f = <span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>), <span class="type">List</span>(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">    <span class="comment">// 将集合 “拍扁”</span></span><br><span class="line">    println(f.flatten)</span><br><span class="line">    <span class="comment">// 操作集合中的元素</span></span><br><span class="line">    println(f.map(_.map(_ * <span class="number">2</span>)))</span><br><span class="line">    <span class="comment">// 操作集合中的元素并 “拍扁”</span></span><br><span class="line">    <span class="comment">// 可以理解为 flat + map</span></span><br><span class="line">    println(f.flatMap(_.map(_ * <span class="number">2</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="type">List</span>(<span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>), <span class="type">List</span>(<span class="number">6</span>, <span class="number">8</span>), <span class="type">List</span>(<span class="number">10</span>, <span class="number">12</span>))</span><br><span class="line"><span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<h2 id="综合例子"><a href="#综合例子" class="headerlink" title="综合例子"></a>综合例子</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter07</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HighFuncApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> txt = <span class="type">Source</span>.fromFile(<span class="string">"E:\\test\\data.txt"</span>).mkString</span><br><span class="line">    <span class="keyword">val</span> l = <span class="type">List</span>(txt)</span><br><span class="line">    <span class="comment">// mapValues 作用：</span></span><br><span class="line">    <span class="comment">// Key 保持不变，与新的 Value 一起组成新的元素</span></span><br><span class="line">    <span class="comment">// 该函数只适用于 K-V 对的元素</span></span><br><span class="line">    l.flatMap(_.split(<span class="string">","</span>)).map(x =&gt; (x, <span class="number">1</span>)).groupBy(_._1).mapValues(_.size).foreach(println)</span><br><span class="line">    <span class="comment">// 两种方法结果相同</span></span><br><span class="line">    l.flatMap(_.split(<span class="string">","</span>)).map(x =&gt; (x, <span class="number">1</span>)).groupBy(_._1).map(x =&gt; (x._1, x._2.size)).foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试文件内容：（data.txt)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello,hello,world,hello</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">(world,<span class="number">1</span>)</span><br><span class="line">(hello,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><h3 id="实例一-1"><a href="#实例一-1" class="headerlink" title="实例一"></a>实例一</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.chentyit.chapter07</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Random</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 偏函数：</span></span><br><span class="line"><span class="comment"> * 被包在花括号内没有 match 的一组 case 语句</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PartitalFunctionApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> names = <span class="type">Array</span>(<span class="string">"Akiho Yoshizawa"</span>, <span class="string">"YuiHatano"</span>, <span class="string">"Aoi Sola"</span>)</span><br><span class="line">    <span class="keyword">val</span> name = names(<span class="type">Random</span>.nextInt(names.length))</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A 是输入参数类型</span></span><br><span class="line"><span class="comment">   * B 是输出参数类型</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayChinese</span></span>: <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"Akiho Yoshizawa"</span> =&gt; <span class="string">"aaa"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"YuiHatano"</span> =&gt; <span class="string">"bbb"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"Aoi Sola"</span> =&gt; <span class="string">"ccc"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(sayChinese(<span class="string">"Akiho Yoshizawa"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例二-1"><a href="#实例二-1" class="headerlink" title="实例二"></a>实例二</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chentyit.scala2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> l = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">"one"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将集合中的数据加 10</span></span><br><span class="line">        <span class="comment">// l.map(&#123; case x: Int =&gt; x + 10 &#125;)</span></span><br><span class="line">        println(l.collect(&#123; <span class="keyword">case</span> x: <span class="type">Int</span> =&gt; x + <span class="number">10</span> &#125;))</span><br><span class="line">        <span class="keyword">val</span> fn1 = <span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">            <span class="comment">// 判断数据是否合法</span></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">Any</span>): <span class="type">Boolean</span> = x.isInstanceOf[<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理数据的方式</span></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Any</span>): <span class="type">Int</span> = x.asInstanceOf[<span class="type">Int</span>] + <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(l.collect(fn1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例三"><a href="#实例三" class="headerlink" title="实例三"></a>实例三</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chentyit.scala2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> l = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">"one"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> fn2: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">            <span class="keyword">case</span> x: <span class="type">Int</span> =&gt; x + <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(l.collect(fn2))</span><br><span class="line"></span><br><span class="line">        println(l.collect(&#123; <span class="keyword">case</span> x: <span class="type">Int</span> =&gt; x + <span class="number">10</span> &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例四"><a href="#实例四" class="headerlink" title="实例四"></a>实例四</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chentyit.scala2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> strNum = <span class="type">List</span>(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fnx1</span></span>: <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"one"</span> =&gt; <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fnx2</span></span>: <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"two"</span> =&gt; <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fnx3</span></span>: <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">Int</span>] = &#123;</span><br><span class="line">            <span class="keyword">case</span> _ =&gt; <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fnxx</span> </span>= fnx1 orElse fnx2 orElse fnx3</span><br><span class="line"></span><br><span class="line">        println(strNum.collect(fnxx))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy(一)</title>
    <url>/2019/09/08/Scrapy-%E4%B8%80/</url>
    <content><![CDATA[<ul>
<li>介绍</li>
<li>使用</li>
<li>pipline</li>
<li>logging</li>
</ul>
<a id="more"></a>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Scrapy 是一个未来爬取网站数据，提取结构性数据而编写的应用框架</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy startproject mySpider</span><br></pre></td></tr></table></figure>
<h3 id="创建爬取模块"><a href="#创建爬取模块" class="headerlink" title="创建爬取模块"></a>创建爬取模块</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy genspider itcast "itcast.cn"</span><br></pre></td></tr></table></figure>
<h3 id="启动开始爬取"><a href="#启动开始爬取" class="headerlink" title="启动开始爬取"></a>启动开始爬取</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy crawl itcast</span><br></pre></td></tr></table></figure>
<p><strong>代码块：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItcastSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    <span class="comment"># 爬虫名</span></span><br><span class="line">    name = <span class="string">'itcast'</span></span><br><span class="line">    <span class="comment"># 允许爬取的范围</span></span><br><span class="line">    allowed_domains = [<span class="string">'itcast.cn'</span>]</span><br><span class="line">    <span class="comment"># 最开始请求的 url 地址</span></span><br><span class="line">    start_urls = [<span class="string">'http://www.itcast.cn/channel/teacher.shtml'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="comment"># 处理 start_urls 地址对应的响应</span></span><br><span class="line">        <span class="comment"># ret1 = response.xpath("//div[@class='tea_con']//h3/text()").extract()</span></span><br><span class="line">        <span class="comment"># print(ret1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分组</span></span><br><span class="line">        li_list = response.xpath(<span class="string">"//div[@class='tea_con']//li"</span>)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">            item = &#123;&#125;</span><br><span class="line">            item[<span class="string">"name"</span>] = li.xpath(<span class="string">".//h3/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">"title"</span>] = li.xpath(<span class="string">".//h4/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            print(item)</span><br></pre></td></tr></table></figure>
<h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>pipeline 中保存数据</p>
<h2 id="pipline"><a href="#pipline" class="headerlink" title="pipline"></a>pipline</h2><p>pipline 可以有多个，原因：</p>
<ol>
<li>可能会有多个 Spider，不同的 pipline 处理不同的 item 的内容</li>
<li>一个 spider 的内容可能要做不同的操作，比如存入不同的数据库中</li>
</ol>
<p>注意：</p>
<ol>
<li>pipline 的权重越小，优先级越高</li>
<li>pipline 中 process_item 方法名不能修改为其他的名称</li>
</ol>
<h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><h3 id="Scrapy-项目中使用"><a href="#Scrapy-项目中使用" class="headerlink" title="Scrapy 项目中使用"></a>Scrapy 项目中使用</h3><p><strong>在 setting.py 里面设置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置日志级别</span><br><span class="line">LOG_LEVEL = &quot;WARNING&quot;</span><br><span class="line"></span><br><span class="line"># 设置日志保存路径</span><br><span class="line">LOG_FILE = &quot;./log.log&quot;</span><br></pre></td></tr></table></figure>
<p><strong>在代码中调用：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="comment"># 先调用 logging 模块</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 python 文件名加载到 logging 中</span></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItcastSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'itcast'</span></span><br><span class="line">    allowed_domains = [<span class="string">'itcast.cn'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://www.itcast.cn/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            item = &#123;&#125;</span><br><span class="line">            item[<span class="string">"come_from"</span>] = <span class="string">"itcast"</span></span><br><span class="line">            <span class="comment"># 将信息按照等级打印出来</span></span><br><span class="line">            logger.warning(item)</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>
<h3 id="在一般项目用使用"><a href="#在一般项目用使用" class="headerlink" title="在一般项目用使用"></a>在一般项目用使用</h3><p><strong><em>单独测试 logging 模块</em>：</strong></p>
<p><strong>log_a.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志的输出样式</span></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    format=<span class="string">'%(levelname)s [%(filename)s] '</span></span><br><span class="line">                           <span class="string">'[%(lineno)d] : %(message)s'</span></span><br><span class="line">                           <span class="string">' - %(asctime)s'</span>, datefmt=<span class="string">'[%d/%b/%Y %H:%M:%S]'</span>)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    logger.info(<span class="string">"this is a info log"</span>)</span><br><span class="line">    logger.info(<span class="string">"this is a info log 1"</span>)</span><br></pre></td></tr></table></figure>
<p>在 log_b.py 中调用 log_a.py 中的 logging</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> log_a <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    logger.warning(<span class="string">"this is log_b 1"</span>)</span><br><span class="line">    logger.warning(<span class="string">"this is log_b 2"</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase 安装</title>
    <url>/2019/09/01/HBase-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="下载-HBase-的安装包"><a href="#下载-HBase-的安装包" class="headerlink" title="下载 HBase 的安装包"></a>下载 HBase 的安装包</h2><p>下载的是 2.0.6 版本</p>
<h2 id="解压安装包"><a href="#解压安装包" class="headerlink" title="解压安装包"></a>解压安装包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf hdfs-*** -C /usr/local</span><br></pre></td></tr></table></figure>
<h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export HBASE_HOME="/usr/local/hbase-2.0.6"</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;HBASE_HOME&#125;/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><h3 id="修改-conf-下的-hbase-env-sh"><a href="#修改-conf-下的-hbase-env-sh" class="headerlink" title="修改 /conf 下的 hbase-env.sh"></a>修改 /conf 下的 hbase-env.sh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk8</span><br><span class="line"><span class="meta">#</span> 使用自己的 Zookeeper 不使用 HBase 自带的 ZK</span><br><span class="line">export HBASE_MANAGES_ZK=false</span><br></pre></td></tr></table></figure>
<h3 id="修改-conf-下的-hbase-site-xml"><a href="#修改-conf-下的-hbase-site-xml" class="headerlink" title="修改 /conf 下的 hbase-site.xml"></a>修改 /conf 下的 hbase-site.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里不设置这个也可以，但是要在下面写上端口号，设置了也不会发生冲突 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.clientPort<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>bigdata1:2181,bigdata2:2181,bigdata3:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可以不配置，如果要配置，需要和zookeeper配置文件zoo.cfg中的dataDir指定的路径相同 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/zookeeper/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置 HDFS 的命名空间  --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注意：这里要和 hadoop 里面的 core-site.xml 里面配置的 HDFS 命名空间名称相同  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://ns/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置为分布式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="把-hadoop-的配置文件-core-site-xml-和-hdfs-site-xml-复制到-hbase-的配置文件目录下"><a href="#把-hadoop-的配置文件-core-site-xml-和-hdfs-site-xml-复制到-hbase-的配置文件目录下" class="headerlink" title="把 hadoop 的配置文件 core-site.xml 和 hdfs-site.xml 复制到 hbase 的配置文件目录下"></a>把 hadoop 的配置文件 core-site.xml 和 hdfs-site.xml 复制到 hbase 的配置文件目录下</h3><p>网上大多数教程都没有这一步，但是加上也没有报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp hadoop-2.8.4/etc/hadoop/core-site.xml hbase-2.0.6/conf/</span><br><span class="line">cp hadoop-2.8.4/etc/hadoop/hdfs-site.xml hbase-2.0.6/conf/</span><br></pre></td></tr></table></figure>
<h3 id="修改-regionservers-文件"><a href="#修改-regionservers-文件" class="headerlink" title="修改 regionservers 文件"></a>修改 regionservers 文件</h3><p>在 regionservers 文件中添加节点（先把里面的 localhost 删掉）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim regionservers</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加如下内容（按自己要求修改）</span><br><span class="line">bigdata1</span><br><span class="line">bigdata2</span><br><span class="line">bigdata3</span><br></pre></td></tr></table></figure>
<h3 id="添加并修改-backup-masters文件"><a href="#添加并修改-backup-masters文件" class="headerlink" title="添加并修改 backup-masters文件"></a>添加并修改 backup-masters文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim backup-masters</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加如下内容（按自己要求修改）</span><br><span class="line"><span class="meta">#</span> 这个是备用的 master 节点（防止当前 master 嗝屁后 HBase 集群也跟着嗝屁）</span><br><span class="line">bigdata6</span><br></pre></td></tr></table></figure>
<h2 id="将-HBase-文件全部分发到集群的其他节点"><a href="#将-HBase-文件全部分发到集群的其他节点" class="headerlink" title="将 HBase 文件全部分发到集群的其他节点"></a>将 HBase 文件全部分发到集群的其他节点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r /etc/local/hbase-*** hostname:/etc/local</span><br></pre></td></tr></table></figure>
<h2 id="同步时间（特别注意！！！）"><a href="#同步时间（特别注意！！！）" class="headerlink" title="同步时间（特别注意！！！）"></a>同步时间（<em>特别注意！！！</em>）</h2><p><strong>如果不同步时间，将无法启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 没有的话就用 yum 安装后再同步</span><br><span class="line">ntpdate -u ntp.api.bz</span><br></pre></td></tr></table></figure>
<h2 id="启动-Zookeeper-amp-HDFS-amp-YARN"><a href="#启动-Zookeeper-amp-HDFS-amp-YARN" class="headerlink" title="启动 Zookeeper &amp; HDFS &amp; YARN"></a>启动 Zookeeper &amp; HDFS &amp; YARN</h2><p>启动后检查一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zkServer.sh start</span><br><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
<h2 id="启动-HBase"><a href="#启动-HBase" class="headerlink" title="启动 HBase"></a>启动 HBase</h2><p>(在集群的哪台机器启动，哪台就是当前的 Master)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure>
<h2 id="观察启动状态"><a href="#观察启动状态" class="headerlink" title="观察启动状态"></a>观察启动状态</h2><p>在浏览器输入 <a href="http://hostname:16010" target="_blank" rel="noopener">http://hostname:16010</a> 可以按到 HBase 的节点状态（hostname 是启动 Hbase 的那台机器名）</p>
<p><img src="/2019/09/01/HBase-安装/hbase_web.png" alt="hbase_web"></p>
<p>在命令行输入 jps 查看进程（HRegionServer 和 HMaster 是否启动）</p>
<p><img src="/2019/09/01/HBase-安装/hbase_jps.png" alt="hbase_jps"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Flume 跨服务器拉取日志</title>
    <url>/2019/08/25/Flume-%E8%B7%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%89%E5%8F%96%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="Flume-跨服务器拉取日志"><a href="#Flume-跨服务器拉取日志" class="headerlink" title="Flume 跨服务器拉取日志"></a>Flume 跨服务器拉取日志</h2><h3 id="思路介绍"><a href="#思路介绍" class="headerlink" title="思路介绍"></a>思路介绍</h3><ol>
<li>在实际开发中，网站应该不会运行装有 Hadoop 以及相关服务的集群上，所以需要一台新的服务器来运行网站的环境以免发生环境冲突或者端口占用的错误</li>
<li>分服务器的 Nginx 生成日志文件 access.log（存放到任何目录）</li>
<li>分服务器的 Flume 监听 access.log 文件的变化，并将 access.log 文件里面的信息拉取下沉到汇总服务器</li>
<li>汇总服务器获取到分服务器下沉的日志信息，然后再一步下沉到 HDFS 中</li>
<li>如果以上思路成立就存在 Flume 汇总服务器以及 Flume 分服务器（我自己命名的），汇总服务器接收分服务器下沉过来的数据，然后再下沉到 HDFS 中，最后在用 MR + HIVE + Sqoop + MySQL 完成工作流</li>
</ol>
<h3 id="分服务器的-Flume-配置文件"><a href="#分服务器的-Flume-配置文件" class="headerlink" title="分服务器的 Flume 配置文件"></a>分服务器的 Flume 配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a1.sources = r1</span><br><span class="line">a1.channels = c1</span><br><span class="line">a1.sinks = k1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>define sources</span><br><span class="line">a1.sources.r1.type = TAILDIR</span><br><span class="line">a1.sources.r1.positionFile = /usr/local/flume-1.8.0/bigdata8/taildir_position.json</span><br><span class="line">a1.sources.r1.command =tail -f /test/log.txt</span><br><span class="line">a1.sources.r1.filegroups = f1</span><br><span class="line">a1.sources.r1.filegroups.f1 = /root/web/access.log</span><br><span class="line">a1.sources.r1.headers.f1.headerKey1 = value1</span><br><span class="line">a1.sources.r1.fileHeader = true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>define channels</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>define sink</span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = 192.168.11.37</span><br><span class="line">a1.sinks.k1.port =44444</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>bind sources and sink to channel </span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>
<h3 id="汇总服务器的-Flume-配置文件"><a href="#汇总服务器的-Flume-配置文件" class="headerlink" title="汇总服务器的 Flume 配置文件"></a>汇总服务器的 Flume 配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a2.sources = r2</span><br><span class="line">a2.channels = c2</span><br><span class="line">a2.sinks = k2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>define sources</span><br><span class="line">a2.sources.r2.type = avro</span><br><span class="line">a2.sources.r2.bind = 0.0.0.0</span><br><span class="line">a2.sources.r2.port = 44444</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>define channels</span><br><span class="line">a2.channels.c2.type = memory</span><br><span class="line">a2.channels.c2.capacity = 10000</span><br><span class="line">a2.channels.c2.transactionCapacity = 10000</span><br><span class="line">a2.channels.c2.byteCapacityBufferPercentage = 20</span><br><span class="line">a2.channels.c2.byteCapacity = 800000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>define sink</span><br><span class="line">a2.sinks.k2.type = hdfs</span><br><span class="line">a2.sinks.k2.channel = c1</span><br><span class="line">a2.sinks.k2.hdfs.path = /weblog/flume/events/%y-%m-%d/%H%M%S</span><br><span class="line">a2.sinks.k2.hdfs.filePrefix = events-</span><br><span class="line"><span class="meta">#</span>一定要加上</span><br><span class="line">a2.sinks.k2.hdfs.useLocalTimeStamp = true</span><br><span class="line">a2.sinks.k2.hdfs.round = true</span><br><span class="line">a2.sinks.k2.hdfs.roundValue = 10</span><br><span class="line">a2.sinks.k2.hdfs.roundUnit = minute</span><br><span class="line"><span class="meta">#</span>生成的文件类型，默认是Sequencefile，可用DataStream，则为普通文本</span><br><span class="line">a2.sinks.k2.hdfs.fileType = DataStream</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>bind sources and sink to channel </span><br><span class="line">a2.sources.r2.channels = c2</span><br><span class="line">a2.sinks.k2.channel = c2</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在分服务器中将下沉（sink）的 type 设置为 avro，并设置下沉的目标服务器的 IP 地址</p>
<p>在汇总服务器中将源（source）的 type 设置成为 arvo</p>
<p>启动的时候<strong>先启动汇总服务器再启动分服务器</strong></p>
<p>这里注意：<strong>不要在 a2.sources.r2.bind 后面写 localhost 要直接写符合 IPv4 格式的 IP 地址</strong>，我试过很多次就是这里出了问题</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Flume</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive(一)</title>
    <url>/2019/08/20/Hive-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><p><strong>Hive 数据仓库</strong>：用于存储数据，都是历史数据，不可变的数据，不能改，不能删，对于 hive 而言，增加的是文件</p>
<p><strong>关系型数据库</strong>：用于存储数据，注重业务逻辑，可以进行增删改查</p>
<p>hive 保存了元数据信息，是一个元数据管理工具，是一个驱动，hive 解析 sql 语句，将其翻译成为 MR 的运算程序，同时保存了与元数据信息</p>
<h1 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h1><h2 id="1-JDK-安装"><a href="#1-JDK-安装" class="headerlink" title="1. JDK 安装"></a>1. JDK 安装</h2><h2 id="2-Hadoop-安装"><a href="#2-Hadoop-安装" class="headerlink" title="2. Hadoop 安装"></a>2. Hadoop 安装</h2><h2 id="3-MySQL-安装"><a href="#3-MySQL-安装" class="headerlink" title="3. MySQL 安装"></a>3. MySQL 安装</h2><h2 id="4-开始安装-Hive"><a href="#4-开始安装-Hive" class="headerlink" title="4. 开始安装 Hive"></a>4. 开始安装 Hive</h2><ul>
<li><p>解压到 /usr/local</p>
</li>
<li><p>配置环境变量到 /etc/profile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HIVE_HOME="/usr/local/hive1.2.2"</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置元数据库信息</p>
<p>在 hive*/conf/ 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp hive-default.xml.template hive-site.xml</span><br></pre></td></tr></table></figure>
<p>在 hive-site.xml 中添加以下文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://bigdata7:3306/hive?createDatabaseIfNotExist=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>JDBC connect string for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Driver class name for a JDBC metastore<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>username to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>Chentyit123456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>password to use against metastore database<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>system:java.io.tmpdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hive1.2.2/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>system:user.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将 MySQL 的连接 jar 包拷贝到 $HIVE_HOME/lib 目录下</strong></p>
<p>这里如果数据库是 5.5 以上版本的 MySQL，选择版本高一点的 5.1.*.jar 连接包，如果是 8.0.0 的就直接使用 8 的连接包</p>
</li>
<li><p><strong>拷贝 hive 的 lib 目录中 jline.2.12.jar 的 jar 包替换掉 hadoop 中的包</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;HADOOP_HOME&#125;/share/hadoop/yarn/lib/jline-0.9.94.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 Hive</p>
<ol>
<li><p>直接使用 hive 命令</p>
</li>
<li><p>先打开服务端，再打开客户端连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive --service hiveserver2&gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">beeline -u jdbc:hive2://主机名:10000 -n root</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h1 id="Hive-命令"><a href="#Hive-命令" class="headerlink" title="Hive 命令"></a>Hive 命令</h1><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> chentyit;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> chentyit <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> chentyit;</span><br></pre></td></tr></table></figure>
<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span> <span class="keyword">like</span> <span class="string">'chenty.*'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查看某一个数据库的详细信息"><a href="#查看某一个数据库的详细信息" class="headerlink" title="查看某一个数据库的详细信息"></a>查看某一个数据库的详细信息</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">describe</span> <span class="keyword">database</span> chentyit;</span><br></pre></td></tr></table></figure>
<h3 id="删除非空数据库"><a href="#删除非空数据库" class="headerlink" title="删除非空数据库"></a>删除非空数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> chentyit <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure>
<h3 id="创建数据库时，指定数据库位置（这个位置是在-hdfs-上的）"><a href="#创建数据库时，指定数据库位置（这个位置是在-hdfs-上的）" class="headerlink" title="创建数据库时，指定数据库位置（这个位置是在 hdfs 上的）"></a>创建数据库时，指定数据库位置（这个位置是在 hdfs 上的）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> chentyit_p location <span class="string">'/home/database/'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/20/Hive-一/chentyit_p.png" alt="chentyit_p"></p>
<h3 id="创建数据库的时候希望能够给数据库增加一些描述性东西"><a href="#创建数据库的时候希望能够给数据库增加一些描述性东西" class="headerlink" title="创建数据库的时候希望能够给数据库增加一些描述性东西"></a>创建数据库的时候希望能够给数据库增加一些描述性东西</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> chentyit_c <span class="keyword">comment</span> <span class="string">'my database'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/20/Hive-一/chentyit_c.png" alt="chentyit_c"></p>
<h3 id="创建数据库的时候，需要为数据库增加属性信息，可以使用-with-dbproperties-信息"><a href="#创建数据库的时候，需要为数据库增加属性信息，可以使用-with-dbproperties-信息" class="headerlink" title="创建数据库的时候，需要为数据库增加属性信息，可以使用 with dbproperties 信息"></a>创建数据库的时候，需要为数据库增加属性信息，可以使用 with dbproperties 信息</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> chentyit_d <span class="keyword">with</span> dbproperties(<span class="string">'createor'</span>=<span class="string">'chenty'</span>,<span class="string">'date'</span>=<span class="string">'2019-08-19'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="修改数据库的属性信息"><a href="#修改数据库的属性信息" class="headerlink" title="修改数据库的属性信息"></a>修改数据库的属性信息</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> chentyit_d <span class="keyword">set</span> dbproperties(<span class="string">'edited-by'</span>=<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="如果要使用自己已经存在的数据库"><a href="#如果要使用自己已经存在的数据库" class="headerlink" title="如果要使用自己已经存在的数据库"></a>如果要使用自己已经存在的数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> chentyit;</span><br></pre></td></tr></table></figure>
<h3 id="查看当前数据库下的所有表"><a href="#查看当前数据库下的所有表" class="headerlink" title="查看当前数据库下的所有表"></a>查看当前数据库下的所有表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>
<h3 id="创建表（默认是内部表）"><a href="#创建表（默认是内部表）" class="headerlink" title="创建表（默认是内部表）"></a>创建表（默认是内部表）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info(<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">name</span> <span class="keyword">string</span>) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="创建一个表，该表和已有的某一个表的结构一样（复制表结构）"><a href="#创建一个表，该表和已有的某一个表的结构一样（复制表结构）" class="headerlink" title="创建一个表，该表和已有的某一个表的结构一样（复制表结构）"></a>创建一个表，该表和已有的某一个表的结构一样（复制表结构）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> emp <span class="keyword">like</span> emp1;</span><br></pre></td></tr></table></figure>
<h3 id="删除一个已经存在的表"><a href="#删除一个已经存在的表" class="headerlink" title="删除一个已经存在的表"></a>删除一个已经存在的表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> emp1;</span><br></pre></td></tr></table></figure>
<h3 id="修改一个表明，重命名"><a href="#修改一个表明，重命名" class="headerlink" title="修改一个表明，重命名"></a>修改一个表明，重命名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_info <span class="keyword">rename</span> <span class="keyword">to</span> emp_info;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/20/Hive-一/rename_table.png" alt="rename_table"></p>
<h3 id="将hdfs上面的文件信息导入到hive表中"><a href="#将hdfs上面的文件信息导入到hive表中" class="headerlink" title="将hdfs上面的文件信息导入到hive表中"></a>将hdfs上面的文件信息导入到hive表中</h3><p>/home/bigdata 代表文件在在 HDFS 上位置</p>
<p>使用改命令时一定要注意数据与数据之间在 txt 文件编辑的时候一定要 Tab 间隔</p>
<p>导入后 HDFS 里面的数据没了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> inpath <span class="string">'/home/database'</span> <span class="keyword">into</span> <span class="keyword">table</span> emp_info;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/20/Hive-一/load_from_hdfs.png" alt="load_from_hdfs"></p>
<h3 id="给某一个表增加某一列的信息"><a href="#给某一个表增加某一列的信息" class="headerlink" title="给某一个表增加某一列的信息"></a>给某一个表增加某一列的信息</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp_info <span class="keyword">add</span> <span class="keyword">columns</span>(job <span class="keyword">string</span>);</span><br></pre></td></tr></table></figure>
<h3 id="修改某一个表的某一列的信息"><a href="#修改某一个表的某一列的信息" class="headerlink" title="修改某一个表的某一列的信息"></a>修改某一个表的某一列的信息</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp_info <span class="keyword">change</span> <span class="keyword">column</span> job cjob <span class="built_in">int</span> <span class="keyword">comment</span> <span class="string">'job_id'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/20/Hive-一/alter_column.png" alt="alter_column"></p>
<h3 id="替换表中的某一个列"><a href="#替换表中的某一个列" class="headerlink" title="替换表中的某一个列"></a>替换表中的某一个列</h3><p>这里注意，这里的 replace 不是替换一列，而是把<strong>所有列</strong>重新<strong>改写</strong>成<strong>括号里面的新列</strong></p>
<p>举个例子：原列是（a, b, c) 用下列命令后就变成了 （job, dept）而 a，b，c 三列不见了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp_info <span class="keyword">replace</span> <span class="keyword">columns</span>(job <span class="built_in">int</span>, dept <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure>
<h3 id="修改表中某一列的属性"><a href="#修改表中某一列的属性" class="headerlink" title="修改表中某一列的属性"></a>修改表中某一列的属性</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab_name <span class="keyword">set</span> tblproperties(<span class="string">'value'</span>=<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Hive-成批向某一表插入数据"><a href="#Hive-成批向某一表插入数据" class="headerlink" title="Hive 成批向某一表插入数据"></a>Hive 成批向某一表插入数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> emp_info_b <span class="keyword">select</span> * <span class="keyword">from</span> emp_info;</span><br></pre></td></tr></table></figure>
<h3 id="将查询结果保留到一个新表中去"><a href="#将查询结果保留到一个新表中去" class="headerlink" title="将查询结果保留到一个新表中去"></a>将查询结果保留到一个新表中去</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_info_c <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp_info_b;</span><br></pre></td></tr></table></figure>
<h3 id="将查询结果保存到指定的文件目录（可以是本地，也可以-HDFS）"><a href="#将查询结果保存到指定的文件目录（可以是本地，也可以-HDFS）" class="headerlink" title="将查询结果保存到指定的文件目录（可以是本地，也可以 HDFS）"></a>将查询结果保存到指定的文件目录（可以是本地，也可以 HDFS）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">local</span> <span class="keyword">directory</span> <span class="string">'/home/hadoop/test'</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp_info;</span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">directory</span> <span class="string">'/aaa/bbb/'</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp_info;</span><br></pre></td></tr></table></figure>
<h3 id="两表内连"><a href="#两表内连" class="headerlink" title="两表内连"></a>两表内连</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp_info a <span class="keyword">join</span> emp_info b <span class="keyword">on</span> a.id = b.id;</span><br></pre></td></tr></table></figure>
<h3 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h3><p><strong>普通表和分区表区别：有大量数据增加的需要建分区表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu(<span class="keyword">id</span> <span class="built_in">INT</span>, age <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="keyword">STRING</span>)</span><br><span class="line">partitioned <span class="keyword">by</span>(p_date <span class="keyword">STRING</span>) </span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>
<p>分区表加载数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'本地文件路径'</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> stu <span class="keyword">partition</span> (pubdate=<span class="string">'2010-08-22'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="创建一个带桶的表"><a href="#创建一个带桶的表" class="headerlink" title="创建一个带桶的表"></a>创建一个带桶的表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bucket_stu (<span class="keyword">id</span> <span class="built_in">int</span> ,age <span class="built_in">int</span> ,<span class="keyword">name</span> <span class="keyword">string</span>)</span><br><span class="line">partitioned <span class="keyword">by</span> (p_date <span class="keyword">string</span>)</span><br><span class="line">clustered <span class="keyword">by</span> (<span class="keyword">id</span>) sorted <span class="keyword">by</span>(<span class="keyword">id</span>) <span class="keyword">into</span> <span class="number">3</span> buckets</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>分桶前要设置</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.enforce.bucketing = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>向桶中添加数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> bucket_stu <span class="keyword">partition</span>(p_date=<span class="string">'0817'</span>) <span class="keyword">select</span> <span class="keyword">id</span>,age,<span class="keyword">name</span> <span class="keyword">from</span> stu <span class="keyword">where</span> p_date=<span class="string">'0817'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="数据块抽样（tablesample-函数）"><a href="#数据块抽样（tablesample-函数）" class="headerlink" title="数据块抽样（tablesample() 函数）"></a>数据块抽样（tablesample() 函数）</h3><ol>
<li><p>tablesample(n percent) </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> xxx_new <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">tablesample</span>(<span class="number">10</span> <span class="keyword">percent</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>tablesample(n M) 指定抽样数据的大小，单位为M</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> xxx_new <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">tablesample</span>(n M);</span><br></pre></td></tr></table></figure>
</li>
<li><p>tablesample(n rows) —— 默认map的数量是2 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> xxx_new <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">tablesample</span>(n <span class="keyword">rows</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="分桶抽样"><a href="#分桶抽样" class="headerlink" title="分桶抽样"></a>分桶抽样</h3><p>hive 中分桶其实就是根据某一个字段 Hash 取模，放入指定数据的桶中，比如将表 table_1 按照 ID 分成 100 个桶，其算法是 hash(id) % 100，这样，hash(id) % 100 = 0 的数据被放到第一个桶中，hash(id) % 100 = 1 的记录被放到第二个桶中。创建分桶表的关键语句为：CLUSTER BY 语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">TABLESAMPLE (BUCKET x OUT OF y [ON colname])</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_01 <span class="keyword">tablesample</span>(<span class="keyword">bucket</span> <span class="number">1</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">10</span> <span class="keyword">on</span> <span class="keyword">rand</span>());</span><br></pre></td></tr></table></figure>
<p>其中 x 是要抽样的桶编号，桶编号从 1 开始，colname 表示抽样的列，y 表示桶的数量。 </p>
<h3 id="随机抽样（rand-函数）"><a href="#随机抽样（rand-函数）" class="headerlink" title="随机抽样（rand() 函数）"></a>随机抽样（rand() 函数）</h3><ol>
<li><p>使用 rand() 函数进行随机抽样，limit 关键字限制抽样返回的数据，其中 rand 函数前的 distribute 和 sort 关键字可以保证数据在 mapper 和 reducer 阶段是随机分布的（Map的个数由自己设置的个数决定）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">col</span>=xxx <span class="keyword">distribute</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">sort</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 order 关键词 (hive 会把 map 的个数设置回 1）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">col</span>=xxx <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx安装</title>
    <url>/2019/08/17/Nginx%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="安装必要的-C-等插件"><a href="#安装必要的-C-等插件" class="headerlink" title="安装必要的 C++ 等插件"></a>安装必要的 C++ 等插件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y gcc gcc-c++ automake autoconf libtool make</span><br></pre></td></tr></table></figure>
<h2 id="安装-PCRE"><a href="#安装-PCRE" class="headerlink" title="安装 PCRE"></a>安装 PCRE</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf pcre2-10.33.tar.gz -C /usr/local/</span><br><span class="line">cd /usr/local/pcre2-10.33/</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="安装-zlib"><a href="#安装-zlib" class="headerlink" title="安装 zlib"></a>安装 zlib</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class="line">cd zlib-1.2.11/</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h2 id="安装-OpenSSL"><a href="#安装-OpenSSL" class="headerlink" title="安装 OpenSSL"></a>安装 OpenSSL</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure>
<h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.8.1.tar.gz -C /usr/local/</span><br><span class="line">cd /usr/local/nginx-1.8.1/</span><br><span class="line">./configure --prefix=/usr/local/nginx/</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="meta">#</span> 启动需要到 Nginx 的目录下</span><br><span class="line">sbin/nginx -c conf/nginx.conf</span><br><span class="line"><span class="meta">#</span> 查看是否启动成功（80 端口启动)</span><br><span class="line">netstat -ntlp</span><br></pre></td></tr></table></figure>
<h2 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    # index  index.html index.htm;</span><br><span class="line">    proxy_pass http://chentyit.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后重新加载一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/nginx -s reload</span><br></pre></td></tr></table></figure>
<p><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">具体配置方式见官网</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop常见错误集</title>
    <url>/2019/08/13/Hadoop%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E9%9B%86/</url>
    <content><![CDATA[<p><img src="/2019/08/13/Hadoop常见错误集/garrett-patz-1504925-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/Ilu1Vv6EYds?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Garrett Patz</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Hadoop集群从节点出现错误（Connection-refused）"><a href="#Hadoop集群从节点出现错误（Connection-refused）" class="headerlink" title="Hadoop集群从节点出现错误（Connection refused）"></a>Hadoop集群从节点出现错误（Connection refused）</h2><p><img src="/2019/08/13/Hadoop常见错误集/Hadoop集群从节点出现错误.png" alt="Hadoop集群从节点出现错误"></p>
<h3 id="错误原因："><a href="#错误原因：" class="headerlink" title="错误原因："></a>错误原因：</h3><p>Hadoop 集群 yarn-site.xml 配置错误：</p>
<p>默认情况下 yarn ResourceManager 相关服务IP地址指向的是0.0.0.0。</p>
<p>而在服务器中，0.0.0.0 指的是本机网络地址，那么 NodeManager 就会在本机找 ResourceManager 相关服务，而 slave 节点上并没有这些服务，这些服务在 ResourceManager Master 节点上。所以针对 Hadoop 集群配置 yare-site.xml 某些配置项不能使用默认配置。</p>
<p>注意：hadoop 伪分布式可以使用默认配置，因为所有服务都在本地运行</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>修改<strong>所有节点上</strong>yare-site.xml配置文件，在该文件中配置ResourceManager Master节点所在地址即可解决问题。详细配置信息如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoopMaster:8032<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoopMaster:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoopMaster:8031<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="MR本地提交集群运行"><a href="#MR本地提交集群运行" class="headerlink" title="MR本地提交集群运行"></a>MR本地提交集群运行</h2><p><img src="/2019/08/13/Hadoop常见错误集/MR本地提交集群运行错误.png" alt="MR本地提交集群运行错误"></p>
<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>无法加载 core-site.xml 配置文件，没法找到 hdfs://ns 的路径，直接指定默认本地路径</p>
<h3 id="错误原因：-1"><a href="#错误原因：-1" class="headerlink" title="错误原因："></a>错误原因：</h3><p>Maven 打包时没有将 XML 文件打包，所以运行程序时无法加载到 core-site.xml 文件</p>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>在 pom.xml 文件的 <code>&lt;build&gt;&lt;/build&gt;</code> 添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再重新打包运行即可</p>
<h2 id="Unable-to-initialize-MapOutputCollector-org-apache-hadoop-mapred-MapTask-MapOutputBuffer"><a href="#Unable-to-initialize-MapOutputCollector-org-apache-hadoop-mapred-MapTask-MapOutputBuffer" class="headerlink" title="Unable to initialize MapOutputCollector org.apache.hadoop.mapred.MapTask$MapOutputBuffer"></a>Unable to initialize MapOutputCollector org.apache.hadoop.mapred.MapTask$MapOutputBuffer</h2><p><img src="/2019/08/13/Hadoop常见错误集/NoSuchMethodException.png" alt="NoSuchMethodException"></p>
<p>这个问题我花了很久时间，代码改了三次才运行成功</p>
<p>最后发现是因为 Mapper 和 Reducer 的传入值有问题，总结下来就是 Mapper 和 Reducer 的入参和出参的类型<strong>必须要使用 Hadoop 封装的类型，或者按照 Hadoop 要求封装的类型</strong>（自行封装的类，除了要实现 WritableComparable 接口，而且自定义类还必须要有<strong>无参构造方法</strong>），Hadoop 已封装类型如下：</p>
<p><img src="/2019/08/13/Hadoop常见错误集/Mapper和Reducer参数.png" alt="Mapper和Reducer参数"></p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>开发问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题274（H指数）</title>
    <url>/2019/07/27/LeetCode%E5%88%B7%E9%A2%98274%EF%BC%88H%E6%8C%87%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。</span><br><span class="line"></span><br><span class="line">h 指数的定义: “h 代表“高引用次数”（high citations）</span><br><span class="line">一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。</span><br><span class="line">（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/h-index</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入: citations = [3,0,6,1,5]<br>输出: 3<br>解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。</p>
</blockquote>
<p><strong>思路（借鉴官网的题解）：</strong></p>
<ol>
<li><p>h 值意味着一个标准，将数组按照题目要求分成两个部分（我刚开始理解成这个标准是通过计算得到的，在阅读题解后发现，降序数组中，这种标准只是一个属性而已，也就是能通过数组规律直接找到）</p>
</li>
<li><p>将数组降序排列</p>
</li>
<li><p>找到 h 值，h 值就是 arr[i] == i 时的 值，将数值作图可以表示为（图片来源于<a href="https://pic.leetcode-cn.com/Figures/274_H_index.svg" target="_blank" rel="noopener">LeetCode 274题解</a>）：</p>
<p><img src="/2019/07/27/LeetCode刷题274（H指数）/274_H_index.png" alt="274_H_index"></p>
</li>
<li><p>h 值是 arr[i] &gt; i 的临界值，只要记录索引 i，就可以求出 h 值</p>
</li>
</ol>
<h2 id="Java-语言实现"><a href="#Java-语言实现" class="headerlink" title="Java 语言实现"></a>Java 语言实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = arr[left];</span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序标准为降序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; arr[i]) &#123;</span><br><span class="line">                arr[index] = arr[i];</span><br><span class="line">                arr[i] = arr[++index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = value;</span><br><span class="line"></span><br><span class="line">        qsort(arr, left, index - <span class="number">1</span>);</span><br><span class="line">        qsort(arr, index + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解题主体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对数组进行降序排序</span></span><br><span class="line">        qsort(citations, <span class="number">0</span>, citations.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录 h 值</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; citations.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只要满足引用值 arr[i] 大于 i值</span></span><br><span class="line">            <span class="comment">// 即可求出 h 值</span></span><br><span class="line">            <span class="keyword">if</span> (citations[i] &gt; i) &#123;</span><br><span class="line">                h++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Golang-语言实现"><a href="#Golang-语言实现" class="headerlink" title="Golang 语言实现"></a>Golang 语言实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">qsort</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    value := arr[left]</span><br><span class="line">    index := left</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序标准为降序</span></span><br><span class="line">    <span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; arr[i] &#123;</span><br><span class="line">            arr[index] = arr[i]</span><br><span class="line">            arr[i] = arr[index + <span class="number">1</span>]</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[index] = value</span><br><span class="line"></span><br><span class="line">    qsort(arr, left, index - <span class="number">1</span>)</span><br><span class="line">    qsort(arr, index + <span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解题主体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hIndex</span><span class="params">(citations []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数组进行降序排序</span></span><br><span class="line">    qsort(citations, <span class="number">0</span>, <span class="built_in">len</span>(citations) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 h 值</span></span><br><span class="line">    num := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> citations &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要满足引用值 arr[i] 大于 i值</span></span><br><span class="line">        <span class="comment">// 即可求出 h 值</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; value &#123;</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题1122（数组的相对排序）</title>
    <url>/2019/07/25/LeetCode%E5%88%B7%E9%A2%981122%EF%BC%88%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你两个数组，arr1 和 arr2，</span><br><span class="line"></span><br><span class="line">arr2 中的元素各不相同</span><br><span class="line">arr2 中的每个元素都出现在 arr1 中</span><br><span class="line">对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同</span><br><span class="line">未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/relative-sort-array</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：arr1 = [2, 3, 1, 3, 2, 4, 6, 7, 9, 2, 19], arr2 = [2, 1, 4, 3, 9, 6]<br>输出：[2, 2, 2, 1, 4, 3, 3, 9, 6, 7, 19]</p>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>先将 arr2 中的元素存入到一个 Map 中，值为 key，下标索引为 index，作为排序的标准</li>
<li>将 arr1 分为两个部分，第一个部分包含 arr2 的元素，第二个部分不包含 arr2 的元素</li>
<li>将第一个部分按照 Map 中的规则进行排序，第二个部分按照升序排序</li>
<li>将两个部分的数组拼接起来</li>
</ol>
<h2 id="Java-语言实现"><a href="#Java-语言实现" class="headerlink" title="Java 语言实现"></a>Java 语言实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里使用快速排序（我对快速排序情有独钟，但是之后会尝试一下归并排序）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@map</span> 这个是思路1中制定好的排序规则，用作排序条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(Integer[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, Map&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = arr[left];</span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 map 中取出对应 key 的 value</span></span><br><span class="line">            <span class="comment">// 获得该数值对应的序号</span></span><br><span class="line">            <span class="keyword">if</span> (map.get(value) &gt; map.get(arr[i])) &#123;</span><br><span class="line">                arr[index] = arr[i];</span><br><span class="line">                arr[i] = arr[index + <span class="number">1</span>];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = value;</span><br><span class="line"></span><br><span class="line">        qsort(arr, left, index - <span class="number">1</span>, map);</span><br><span class="line">        qsort(arr, index + <span class="number">1</span>, right, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解题主体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] relativeSortArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建一个 Map 存放排序规则</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; numMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">            numMap.put(arr2[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个 list 存放 arr1 分割的两段数据</span></span><br><span class="line">        List&lt;Integer&gt; l1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; l2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numMap.containsKey(i)) &#123;</span><br><span class="line">                l1.add(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l2.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对第一段数据进行快速排序</span></span><br><span class="line">        Integer[] arrbefore = l1.toArray(<span class="keyword">new</span> Integer[l1.size()]);</span><br><span class="line">        qsort(arrbefore, <span class="number">0</span>, arrbefore.length - <span class="number">1</span>, numMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将第二段数据放入数组中，进行简单选择排序</span></span><br><span class="line">        Integer[] arrafter = l2.toArray(<span class="keyword">new</span> Integer[l2.size()]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrafter.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arrafter.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arrafter[i] &gt; arrafter[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> buf = arrafter[i];</span><br><span class="line">                    arrafter[i] = arrafter[j];</span><br><span class="line">                    arrafter[j] = buf;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个新数组存放结果</span></span><br><span class="line">        <span class="keyword">int</span>[] arrResult = <span class="keyword">new</span> <span class="keyword">int</span>[arrbefore.length + arrafter.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放第一部分的数值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrbefore.length; i++) &#123;</span><br><span class="line">            arrResult[i] = arrbefore[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放第二部分的数值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrafter.length; i++) &#123;</span><br><span class="line">            arrResult[i + arrbefore.length] = arrafter[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Golang-语言实现"><a href="#Golang-语言实现" class="headerlink" title="Golang 语言实现"></a>Golang 语言实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里使用快速排序（我对快速排序情有独钟，但是之后会尝试一下归并排序）</span></span><br><span class="line"><span class="comment"> * @numMap 这个是思路1中制定好的排序规则，用作排序条件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">qsort</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>, numMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    value := arr[left]</span><br><span class="line">    index := left</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line">        <span class="comment">// 从 map 中取出对应 key 的 value</span></span><br><span class="line">        <span class="comment">// 获得该数值对应的序号</span></span><br><span class="line">        <span class="keyword">if</span> numMap[value] &gt; numMap[arr[i]] &#123;</span><br><span class="line">            arr[index] = arr[i]</span><br><span class="line">            arr[i] = arr[index + <span class="number">1</span>]</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[index] = value</span><br><span class="line"></span><br><span class="line">    qsort(arr, left, index - <span class="number">1</span>, numMap)</span><br><span class="line">    qsort(arr, index + <span class="number">1</span>, right, numMap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解题主体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">relativeSortArray</span><span class="params">(arr1 []<span class="keyword">int</span>, arr2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 构建一个 Map 存放排序规则</span></span><br><span class="line">    numMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr2); i++ &#123;</span><br><span class="line">        numMap[arr2[i]] = i</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个数组存放 arr1 分割的两段数据</span></span><br><span class="line">    <span class="keyword">var</span> l1 []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> l2 []<span class="keyword">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置标志位</span></span><br><span class="line">    flag := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr1); i++ &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从 map 中找到对应的 key</span></span><br><span class="line">        <span class="comment">// 如果找到就存到 l1 中</span></span><br><span class="line">        <span class="comment">// 没找到就存到 l2 中</span></span><br><span class="line">        <span class="keyword">for</span> key, _ := <span class="keyword">range</span> numMap&#123;</span><br><span class="line">            <span class="keyword">if</span> arr1[i] == key &#123;</span><br><span class="line">                l1 = <span class="built_in">append</span>(l1, arr1[i])</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !flag &#123;</span><br><span class="line">            l2 = <span class="built_in">append</span>(l2, arr1[i])</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对 l1 进行快速排序</span></span><br><span class="line">    qsort(l1, <span class="number">0</span>, <span class="built_in">len</span>(l1) - <span class="number">1</span>, numMap)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对 l2 进行选择排序</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(l2) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(l2); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> l2[i] &gt; l2[j] &#123;</span><br><span class="line">                l2[i], l2[j] = l2[j], l2[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并两个部分的数组（不得不说 golang 操作数组真的方便）</span></span><br><span class="line">    l1 = <span class="built_in">append</span>(l1, l2...)</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题1030（距离顺序排列矩阵单元格）</title>
    <url>/2019/07/24/LeetCode%E5%88%B7%E9%A2%981030%EF%BC%88%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 &lt;= r &lt; R 且 0 &lt;= c &lt; C。</span><br><span class="line"></span><br><span class="line">另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。</span><br><span class="line"></span><br><span class="line">返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中</span><br><span class="line">两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/matrix-cells-in-distance-order</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<blockquote>
<p>输入：R = 1, C = 2, r0 = 0, c0 = 0<br>输出：[[0,0],[0,1]]<br>解释：从 (r0, c0) 到其他单元格的距离为：[0,1]</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p>输入：R = 2, C = 2, r0 = 0, c0 = 1<br>输出：[[0,1],[0,0],[1,1],[1,0]]<br>解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]<br>[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案</p>
</blockquote>
<p><strong>示例3：</strong></p>
<blockquote>
<p>输入：R = 2, C = 3, r0 = 1, c0 = 2<br>输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]<br>解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]<br>其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]</p>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>用一个<strong>一位数组</strong>存下所有点</li>
<li>利用快速排序按照<strong>曼哈顿距离</strong>对所有的点进行排序</li>
</ol>
<h2 id="Java-语言实现"><a href="#Java-语言实现" class="headerlink" title="Java 语言实现"></a>Java 语言实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序</span></span><br><span class="line"><span class="comment">     * 排序条件是各个点到目标点的距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] value = arr[left];</span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="comment">// 按照各个点到目标点的距离进行排序</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(value[<span class="number">0</span>] - r0) + Math.abs(value[<span class="number">1</span>] - c0) &gt;</span><br><span class="line">                    Math.abs(arr[i][<span class="number">0</span>] - r0) + Math.abs(arr[i][<span class="number">1</span>] - c0)) &#123;</span><br><span class="line">                arr[index] = arr[i];</span><br><span class="line">                arr[i] = arr[index + <span class="number">1</span>];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = value;</span><br><span class="line"></span><br><span class="line">        qsort(arr, left, index - <span class="number">1</span>, r0, c0);</span><br><span class="line">        qsort(arr, index + <span class="number">1</span>, right, r0, c0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解题主要方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="comment">// 判断所传参数是否满足题目要求</span></span><br><span class="line">        <span class="keyword">if</span> ((R &gt; <span class="number">100</span>) || (R &lt; <span class="number">1</span>) || (C &gt; <span class="number">100</span>) || (C &lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用一个一位数组存放二维坐标</span></span><br><span class="line">        <span class="comment">// 实质上也是一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[R * C][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="comment">// 创建一个空间存放每个点的坐标</span></span><br><span class="line">                arr[i * C + j] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">                arr[i * C + j][<span class="number">0</span>] = i;</span><br><span class="line">                arr[i * C + j][<span class="number">1</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进行快速排序</span></span><br><span class="line">        qsort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, r0, c0);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Golang-语言实现"><a href="#Golang-语言实现" class="headerlink" title="Golang 语言实现"></a>Golang 语言实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * 排序条件是各个点到目标点的距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">qsort</span><span class="params">(arr [][]<span class="keyword">int</span>, left, right, r0, c0 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	value := arr[left]</span><br><span class="line">	index := left</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line">        <span class="comment">// 按照各个点到目标点的距离进行排序</span></span><br><span class="line">		<span class="keyword">if</span> math.Abs(<span class="keyword">float64</span>(value[<span class="number">0</span>] - r0)) + math.Abs(<span class="keyword">float64</span>(value[<span class="number">1</span>] - c0)) &gt;</span><br><span class="line">			math.Abs(<span class="keyword">float64</span>(arr[i][<span class="number">0</span>] - r0)) + math.Abs(<span class="keyword">float64</span>(arr[i][<span class="number">1</span>] - c0)) &#123;</span><br><span class="line">			arr[index] = arr[i]</span><br><span class="line">			arr[i] = arr[index + <span class="number">1</span>]</span><br><span class="line">			index++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[index] = value</span><br><span class="line"></span><br><span class="line">	qsort(arr, left, index - <span class="number">1</span>, r0, c0)</span><br><span class="line">	qsort(arr, index + <span class="number">1</span>, right, r0, c0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解题主要方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allCellsDistOrder</span><span class="params">(R <span class="keyword">int</span>, C <span class="keyword">int</span>, r0 <span class="keyword">int</span>, c0 <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断所传参数是否满足题目要求</span></span><br><span class="line">    <span class="keyword">if</span> R &gt; <span class="number">100</span> || R &lt; <span class="number">1</span> || C &gt; <span class="number">100</span> || C &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 利用一个一位数组存放二维坐标</span></span><br><span class="line">	<span class="comment">// 实质上也是一个二维数组</span></span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="keyword">int</span>, R * C)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; R; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; C; j++ &#123;</span><br><span class="line">            <span class="comment">// 创建一个空间存放每个点的坐标</span></span><br><span class="line">            result[i * C + j] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">            result[i * C + j][<span class="number">0</span>] = i</span><br><span class="line">            result[i * C + j][<span class="number">1</span>] = j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行快速排序</span></span><br><span class="line">    qsort(result, <span class="number">0</span>, <span class="built_in">len</span>(result) - <span class="number">1</span>, r0, c0)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题976（三角形的最大周长）</title>
    <url>/2019/07/23/LeetCode%E5%88%B7%E9%A2%98976%EF%BC%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。</span><br><span class="line"></span><br><span class="line">如果不能形成任何面积不为零的三角形，返回 0。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/largest-perimeter-triangle/</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<blockquote>
<p>输入：[2,1,2]<br>输出：5</p>
</blockquote>
<p><strong>示例2：</strong></p>
<blockquote>
<p>输入：[1,2,1]<br>输出：0</p>
</blockquote>
<p><strong>示例3：</strong></p>
<blockquote>
<p>输入：[3,2,3,4]<br>输出：10</p>
</blockquote>
<p><strong>示例4：</strong></p>
<blockquote>
<p>输入：[3,6,2,3]<br>输出：8</p>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>理清楚三角形特点，两边之和大于第三边 <code>A1 + A2 &gt; A3</code>，两边之差小于第三边 <code>|A1 - A2| &lt; A3</code></li>
<li>根据思路1可以得到在有序数组中，某一元素大于前两项之和即可</li>
<li>排序得到有序数组（升序降序随意）</li>
<li>根据思路 1 和 2 得到最大周长</li>
</ol>
<h2 id="Java-语言实现"><a href="#Java-语言实现" class="headerlink" title="Java 语言实现"></a>Java 语言实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里使用的是快速排序</span></span><br><span class="line"><span class="comment">     * 具体说明就不详细写了，单独起新博客写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = arr[left];</span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &gt; arr[i]) &#123;</span><br><span class="line">                arr[index] = arr[i];</span><br><span class="line">                arr[i] = arr[index + <span class="number">1</span>];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = value;</span><br><span class="line"></span><br><span class="line">        qsort(arr, left, index - <span class="number">1</span>);</span><br><span class="line">        qsort(arr, index + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求出满足三角形条件的最大周长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestPerimeter</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断所给的数组长度是否满足 3 条边</span></span><br><span class="line">        <span class="keyword">if</span> (A.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快速排序获得一个升序数组</span></span><br><span class="line">        qsort(A, <span class="number">0</span>, A.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设定一个最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 开始计算最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算出满足两边之和大于第三边的最大周长</span></span><br><span class="line">            <span class="keyword">if</span> ((A[i] &lt; (A[i - <span class="number">1</span>] + A[i - <span class="number">2</span>])) &amp;&amp; (max &lt; A[i] + A[i - <span class="number">1</span>] + A[i - <span class="number">2</span>])) &#123;</span><br><span class="line">                max = A[i] + A[i - <span class="number">1</span>] + A[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最大周长</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Golang-语言实现"><a href="#Golang-语言实现" class="headerlink" title="Golang 语言实现"></a>Golang 语言实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里使用的是快速排序</span></span><br><span class="line"><span class="comment"> * 具体说明就不详细写了，单独起新博客写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">qsort</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	value := arr[left]</span><br><span class="line">	index := left</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> value &gt; arr[i] &#123;</span><br><span class="line">			arr[index] = arr[i]</span><br><span class="line">			arr[i] = arr[index + <span class="number">1</span>]</span><br><span class="line">			index++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[index] = value</span><br><span class="line"></span><br><span class="line">	qsort(arr, left, index - <span class="number">1</span>)</span><br><span class="line">	qsort(arr, index + <span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求出满足三角形条件的最大周长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestPerimeter</span><span class="params">(A []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断所给的数组长度是否满足 3 条边</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(A) &lt; <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 快速排序获得一个升序数组</span></span><br><span class="line">	qsort(A, <span class="number">0</span>, <span class="built_in">len</span>(A) - <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 设定一个最大值</span></span><br><span class="line">	max := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 开始计算最大值</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(A); i++ &#123;</span><br><span class="line">        <span class="comment">// 计算出满足两边之和大于第三边的最大周长</span></span><br><span class="line">		<span class="keyword">if</span> (A[i] &lt; (A[i<span class="number">-1</span>] + A[i<span class="number">-2</span>])) &amp;&amp; (A[i] + A[i - <span class="number">1</span>] + A[i - <span class="number">2</span>] &gt; max) &#123;</span><br><span class="line">			max = A[i] + A[i - <span class="number">1</span>] + A[i - <span class="number">2</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 返回最大周长</span></span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题922（按奇偶排序数组 II）</title>
    <url>/2019/07/23/LeetCode%E5%88%B7%E9%A2%98922%EF%BC%88%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</span><br><span class="line"></span><br><span class="line">对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</span><br><span class="line"></span><br><span class="line">你可以返回任何满足上述条件的数组作为答案。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/sort-array-by-parity-ii</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：[4, 2, 5, 7]<br>输出：[4, 5, 2, 7]<br>解释：[4, 7, 2, 5]，[2, 5, 4, 7]，[2, 7, 4, 5] 也会被接受。</p>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>设置奇偶指针指向奇偶位</li>
<li>如果满足奇偶数条件，指针加 2，不满足，两个指针位互换</li>
</ol>
<h2 id="Java-语言实现"><a href="#Java-语言实现" class="headerlink" title="Java 语言实现"></a>Java 语言实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sortArrayByParityII(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="comment">// 设置奇数指针</span></span><br><span class="line">        <span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 设置偶数指针</span></span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 开始循环判断</span></span><br><span class="line">        <span class="keyword">while</span> (even &lt; A.length &amp;&amp; odd &lt; A.length) &#123;</span><br><span class="line">            <span class="comment">// 判断是否满足偶数条件</span></span><br><span class="line">            <span class="keyword">if</span> (A[even] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                even += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否满足奇数条件</span></span><br><span class="line">            <span class="keyword">if</span> (A[odd] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                odd += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不满足以上条件就交换两个指针的值</span></span><br><span class="line">            <span class="keyword">int</span> buf = A[even];</span><br><span class="line">            A[even] = A[odd];</span><br><span class="line">            A[odd] = buf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Golang-语言实现"><a href="#Golang-语言实现" class="headerlink" title="Golang 语言实现"></a>Golang 语言实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArrayByParityII</span><span class="params">(A []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置奇数指针</span></span><br><span class="line">	even := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 设置偶数指针</span></span><br><span class="line">	odd := <span class="number">1</span></span><br><span class="line">    <span class="comment">// 开始循环判断</span></span><br><span class="line">	<span class="keyword">for</span> even &lt; <span class="built_in">len</span>(A) &amp;&amp; odd &lt; <span class="built_in">len</span>(A) &#123;</span><br><span class="line">        <span class="comment">// 判断是否满足偶数条件</span></span><br><span class="line">        <span class="keyword">if</span> A[even]%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            even += <span class="number">2</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否满足奇数条件</span></span><br><span class="line">        <span class="keyword">if</span> A[odd]%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">            odd += <span class="number">2</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不满足以上条件就交换两个指针的值</span></span><br><span class="line">        A[even], A[odd] = A[odd], A[even]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C++复制构造函数</title>
    <url>/2019/07/19/C-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		value = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A(A other) &#123;</span><br><span class="line">		value = other.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a = <span class="number">10</span>;</span><br><span class="line">	A b = a;</span><br><span class="line">	b.Print();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>上述代码中，复制构造函数 <code>A(A other)</code> 传入的是 A 的一个实例，由于是传值参数，把形参复制到实参会调用复制构造函数，如果允许复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会形成永久递归，导致栈溢出</p>
<p><strong>修改方案：</strong>将 <code>A(A other)</code> 修改为 <code>A(const A&amp; other)</code></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的sizeof函数</title>
    <url>/2019/07/19/C-%E7%9A%84sizeoff%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chen</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Chen a;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>定义一个空类型，里面没有任何成员变量和成员函数，对该类型求 sizeof，得到的结果是多少？</strong></p>
<p>正确答案：1</p>
<blockquote>
<p>空类型的实例中不包含任何信息，sizeof 的结果本应该是 0，但声明类型的时候应该在内存中占有一定的空间，否则无法使用，占用大小由编译器决定，在 Visual Studio 中占 1 字节空间</p>
</blockquote>
<p><strong>如果在该类型中添加构造函数和析构函数，sizeof 的值是多少</strong></p>
<p>正确答案：1</p>
<blockquote>
<p>调用构造函数和析构函数只需要找到函数在内存中的地址就可以了，函数地址只与类型有关，与类型的实例无关，编译器不会为这两个函数添加信息，所以 sizeof 的值不会改变</p>
</blockquote>
<p><strong>如果把析构函数改成虚函数，sizeof 的值是多少</strong></p>
<p>正确答案：根据计算机来说（32 位机是 4，64 位机是 8）</p>
<blockquote>
<p>C++ 编译器中，类型中一旦有虚函数，就会为类型生成虚函数表，并且为每一个实例添加一个指向虚函数表的指针，在 32 位机中，一个指针占 4 字节空间，64 位机中，一个指针占 8 字节空间</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的Goroutine</title>
    <url>/2019/07/06/Go%E8%AF%AD%E8%A8%80%E7%9A%84Goroutine/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul>
<li><strong>并发：</strong>多线程程序在一个核的 CPU 上运行</li>
<li><strong>并行：</strong>多线程程序在多个核的 CPU 上运行</li>
</ul>
<h2 id="协程和线程"><a href="#协程和线程" class="headerlink" title="协程和线程"></a>协程和线程</h2><ul>
<li><strong>协程：</strong>独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的</li>
<li><strong>线程：</strong>一个线程上可以跑多个协程，协程是轻量级的线程</li>
</ul>
<h2 id="goroutine-调度模型"><a href="#goroutine-调度模型" class="headerlink" title="goroutine 调度模型"></a>goroutine 调度模型</h2><ul>
<li><strong>M：</strong>线程，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环；而schedule循环的机制大致是从Global队列、P的Local队列以及wait队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到M，如此反复。M并不保留G状态，这是G可以跨M调度的基础，M的数量是不定的</li>
<li><strong>P：</strong>上下文，表示逻辑处理器， 对G来说，P相当于CPU核，G只有绑定到P(在P的local runq中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P的数量决定了系统内最大可并行的G的数量（前提：物理CPU核数 &gt;= P的数量），P的数量由用户设置的GOMAXPROCS决定，但是不论GOMAXPROCS设置为多大，P的数量最大为256</li>
<li><strong>G：</strong>Goroutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。G并非执行体，每个G需要绑定到P才能被调度执行</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的Struct</title>
    <url>/2019/07/02/Go%E8%AF%AD%E8%A8%80%E7%9A%84Struct/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span></span><br><span class="line">	Age   <span class="keyword">int</span></span><br><span class="line">	score <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Struct-的定义"><a href="#Struct-的定义" class="headerlink" title="Struct 的定义"></a>Struct 的定义</h2><p><strong>struct 定义的三种方式：</strong></p>
<ol>
<li>var stu Student</li>
<li>var stu *Student = new (Student)</li>
<li>var stu *Student = &amp;Student{}</li>
</ol>
<p>其中 2 和 3 返回的都是指向结构体的指针，访问形式如下：</p>
<p>stu.Name 或者 (*stu).Name</p>
<h2 id="Struct-的初始化"><a href="#Struct-的初始化" class="headerlink" title="Struct 的初始化"></a>Struct 的初始化</h2><p>struct 的内存布局：struct 中的所有字段在内存是连续的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> stu Student</span><br><span class="line">	stu.Age = <span class="number">18</span></span><br><span class="line">	stu.Name = <span class="string">"hua"</span></span><br><span class="line">	stu.score = <span class="number">80</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> stu1 *Student = &amp;Student&#123;</span><br><span class="line">		Name:<span class="string">"cty"</span>,</span><br><span class="line">		Age:<span class="number">21</span>,</span><br><span class="line">		score:<span class="number">100</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> stu2 = Student&#123;</span><br><span class="line">		Name:<span class="string">"cty"</span>,</span><br><span class="line">		Age:<span class="number">21</span>,</span><br><span class="line">		score:<span class="number">100</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> stu3 = <span class="built_in">new</span> (Student)</span><br><span class="line">	stu3.Age = <span class="number">18</span></span><br><span class="line">	stu3.Name = <span class="string">"hua"</span></span><br><span class="line">	stu3.score = <span class="number">80</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(stu)</span><br><span class="line">	fmt.Println(*stu1)</span><br><span class="line">	fmt.Println(stu2)</span><br><span class="line">	fmt.Println(*stu3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;hua 18 80&#125;</span><br><span class="line">&#123;cty 21 100&#125;</span><br><span class="line">&#123;cty 21 100&#125;</span><br><span class="line">&#123;hua 18 80&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><strong>golang 中的 struct 没有构造函数，一般可以使用工厂模式解决</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Student</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Student&#123;</span><br><span class="line">		Name: name,</span><br><span class="line">		Age:  age,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p>可以为 struct 中的每个字段写上一个 tag，这个tag 可以通过反射机制获取，最常用的就是 json 序列化和反序列化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span> <span class="string">`json:"student_name"`</span></span><br><span class="line">	Age   <span class="keyword">int</span>    <span class="string">`json:"student_age"`</span></span><br><span class="line">	Score <span class="keyword">int</span>    <span class="string">`json:"student_score"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> stu = Student&#123;</span><br><span class="line">		Name:  <span class="string">"sss"</span>,</span><br><span class="line">		Age:   <span class="number">18</span>,</span><br><span class="line">		Score: <span class="number">80</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data, err := json.Marshal(stu)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"json encode stu failed, err: "</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;student_name&quot;:&quot;sss&quot;,&quot;student_age&quot;:18,&quot;student_score&quot;:80&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言切片</title>
    <url>/2019/07/01/Go%E8%AF%AD%E8%A8%80%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSlice</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> slice []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">	slice = arr[<span class="number">1</span>:]</span><br><span class="line">	fmt.Println(slice)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(slice))</span><br><span class="line"></span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">	slice1 := slice[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">	fmt.Println(slice1)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(slice1))</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(slice1))</span><br><span class="line"></span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">	slice2 := slice1[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">	fmt.Println(slice2)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(slice2))</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(slice2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>初学 Go 语言，疯狂踩坑，很多语法与 Java 不同，这是第一篇关于 Go 语言的学习笔记，开始记录一些学习中遇到的坑</p>
</blockquote>
<p>关于切片，在 Java，Python，JS 等语言中都有过类似的语法，但是人家那个叫做截取，就是截取一段新的数组出来，但是 GO 语言就是那个不一样的烟火，刚开始看的时候，就有点懵，今天终于搞懂了，就特地来记录一下，就拿上面这段代码举例，咱们先把运行结果贴出来，方便解释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1 2 3 4 5]</span><br><span class="line">[2 3 4 5]</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">[1 2 3 4 5]</span><br><span class="line">[2]</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">[1 2 3 4 5]</span><br><span class="line">[2 3 4]</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>我每次都打印一下 arr 就是为了看看切片的时候有没有影响到原数组（很明显没有）</p>
<p>现在来看源代码中的 <code>slice = arr[1:]</code> 这里就生成了第一块切片，也就是 [2, 3, 4, 5]，长度为 4，容量为 4，这个就是初始的切片</p>
<p>然后用 <code>slice1 := slice[0:1]</code> 得到 slice1，仍然没有影响到原数组，得到的切片就是 [2]，长度为 1，容量为 4，因为这个切片是从一个容量为 4 的切片中切出来的，容量不变，只是截取需要的值就行</p>
<p>最后用 <code>slice2 := slice1[0:3]</code> 得到 slice2，这里就和上面的解释一样的了，我就不赘述了</p>
<p>原本我以为从数组里面切出来后的切片再切，容量也会跟着变，但看样子，只要最初的的那个切片容量定了，那再由这个切面切出来的其他切面的容量也是一样，虽然目前看起来没什么用，但以后肯定会有机会用到的</p>
<blockquote>
<p>关于自学笔记的博客我不太喜欢用太过专业的词汇来描述，简单能理解就好了，Go 语言不得不说在我放弃 C++ 学习 Java 后，唯一一个能让我觉得优雅的语言（仅个人主观喜好）</p>
</blockquote>
<p><strong>补充：</strong></p>
<p>切片创建的方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line"><span class="comment">// 或者使用数组创建</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JS查缺补漏01（面向对象）</title>
    <url>/2019/05/31/JS%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F01%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/</url>
    <content><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="对象的分类"><a href="#对象的分类" class="headerlink" title="对象的分类"></a>对象的分类</h3><p><strong>内建对象：</strong></p>
<p>由 ES 标准中定义的对象，在任何的 ES 的实现中都可以使用</p>
<p><strong>宿主对象：</strong></p>
<p>由 JS 的运行环境提供的对象，目前来讲主要指由浏览器提供的对象</p>
<p><strong>自建对象：</strong></p>
<p>由开发人员自己创建的对象</p>
<p><strong>删除对象属性：</strong> delete 对象.属性名</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day14）</title>
    <url>/2019/05/22/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day14%EF%BC%89/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="异步线程池"><a href="#异步线程池" class="headerlink" title="异步线程池"></a>异步线程池</h2><h3 id="定义线程池和开启异步可用"><a href="#定义线程池和开启异步可用" class="headerlink" title="定义线程池和开启异步可用"></a>定义线程池和开启异步可用</h3><p><strong>AsyncConfigurer 接口源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>getAsyncExecutor 方法返回的是一个自定义的线程池，提供空闲线程来执行异步任务</li>
<li>AsyncUncaughtExceptionHandler 处理异常处理器方法，自定义处理异常</li>
<li>@EnableAsync 如果 Java 配置文件标注它，Spring 就会开启异步可用</li>
<li>@Async 驱动 Spring 使用异步调用</li>
</ul>
<p><strong>使用 Java 配置定义线程池和启用异步</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义线程池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义线程池</span></span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        <span class="comment">// 核心线程数</span></span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 线程池最大线程数</span></span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 线程队列最大线程数</span></span><br><span class="line">        taskExecutor.setQueueCapacity(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 @EnableAsync 代表开启 Spring 异步，就可以使用 @Async 驱动 Spring 使用异步</p>
<p><strong>异步服务接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟报表生成的异步方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateReport</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>异步方法实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServiceImpl</span> <span class="keyword">implements</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Async</span>  <span class="comment">// 声明使用异步调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打印异步线程名称</span></span><br><span class="line">        System.out.println(<span class="string">"报表线程名称：【"</span> + Thread.currentThread().getName() + <span class="string">"】"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>异步方法控制器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/async"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncService asyncService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/page"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">asyncPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请求线程名称：【"</span> + Thread.currentThread() + <span class="string">"】"</span>);</span><br><span class="line">        <span class="comment">// 调用异步服务</span></span><br><span class="line">        asyncService.generateReport();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"async"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>控制台打印</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求线程名称：【Thread[http-nio-8080-exec-1,5,main]】</span><br><span class="line">报表线程名称：【ThreadPoolTaskExecutor-1】</span><br></pre></td></tr></table></figure>
<h2 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h2><h3 id="JMS-实例-——-ActiveMQ"><a href="#JMS-实例-——-ActiveMQ" class="headerlink" title="JMS 实例 —— ActiveMQ"></a>JMS 实例 —— ActiveMQ</h3><p><strong>配置 ActiveMQ 和 JMS 信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ActiveMQ 地址</span><br><span class="line">spring.activemq.broker-url=tcp://localhost:61616</span><br><span class="line"># 配置用户名和密码</span><br><span class="line">spring.activemq.user=admin</span><br><span class="line">spring.activemq.password=admin</span><br><span class="line"># 是否使用发布订阅模式，默认为false，即用的是点对点的模式</span><br><span class="line">spring.jms.pub-sub-domain=true</span><br><span class="line"># 默认目的地址</span><br><span class="line">spring.jms.template.default-destination=activemq.default.destination</span><br><span class="line"># 是否启用连接池</span><br><span class="line">spring.activemq.pool.enabled=true</span><br><span class="line"># 连接池最大连接数</span><br><span class="line">spring.activemq.pool.max-connections=50</span><br></pre></td></tr></table></figure>
<p><strong>定义 ActiveMQ 接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ 服务接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActiveMqService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ActiveMQ 服务实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqServiceImpl</span> <span class="keyword">implements</span> <span class="title">ActiveMqService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入由 Spring Boot 自动生产的 jmsTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发送消息【"</span> + message + <span class="string">"】"</span>);</span><br><span class="line">        jmsTemplate.convertAndSend(message);</span><br><span class="line">        <span class="comment">// 自定义发送地址</span></span><br><span class="line">        <span class="comment">// jmsTemplate.convertAndSend("your-destination", message);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"$&#123;spring.jms.template.default-destination&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接收到消息：【"</span> + message + <span class="string">"】"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>convertAndSend 是一个发送消息的方法</p>
<ol>
<li>首先 convert 转换，默认情况下 JmsTemplate 会提供一个 SimpleMessageConverter 去提供转换规则</li>
<li>发送信息（已经在配置文件下设置好了就不用写了）</li>
</ol>
<p>如果要发送一个对象，就要让对象实现 Serializable 接口以便序列化</p>
<p><strong>ActiveMQ 发送 POJO 对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqUserServiceImpl</span> <span class="keyword">implements</span> <span class="title">ActiveMqUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入由 Spring Boot 自动生产的 jmsTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String myDestination = <span class="string">"my-destination"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发送消息【"</span> + user + <span class="string">"】"</span>);</span><br><span class="line">        <span class="comment">// 使用自定义地址发送对象</span></span><br><span class="line">        jmsTemplate.convertAndSend(myDestination, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监控自定义地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = myDestination)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接收到消息：【"</span> + user + <span class="string">"】"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 ActiveMQ 不信任 POJO 对象，所以要在配置文件中添加以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.activemq.packages.trusted=cn.chentyit.chapter13.pojo,java.lang</span><br><span class="line">spring.activemq.packages.trust-all=true</span><br></pre></td></tr></table></figure>
<ul>
<li>spring.activemq.packages.trusted 表示信任某个确定的包</li>
<li>spring.activemq.packages.trust-all 表示信任所有的包</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day13）</title>
    <url>/2019/05/21/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day13%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/21/SpringBoot学习笔记（Day13）/小白.png" alt="插图"></p>
<a id="more"></a>
<h2 id="限制请求"><a href="#限制请求" class="headerlink" title="限制请求"></a>限制请求</h2><p>抽象类 WebSecurityConfigurerAdapter 提供了一个方法 configure(HttpSecurity)，通过它能够实现对于不同角色（用户）赋予不同权限的功能</p>
<p><strong>configure(HttpSecurity) 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.logger.debug(<span class="string">"Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity)."</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只要通过验证就可以访问所有的请求</span></span><br><span class="line"><span class="comment">     * authorizeRequests 方法限定只对签名成功的用户请求</span></span><br><span class="line"><span class="comment">     * anyRequest 方法限定所有请求</span></span><br><span class="line"><span class="comment">     * authenticated 方法对所有签名成功的用户允许方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ((HttpSecurity)((HttpSecurity)((AuthorizedUrl)http.authorizeRequests().anyRequest())</span><br><span class="line">                    .authenticated()</span><br><span class="line">                    <span class="comment">// and 方法是连接词，formLogin 代表使用 Spring Security 默认的登录界面</span></span><br><span class="line">                    .and()).formLogin()</span><br><span class="line">     			   <span class="comment">// httpBasic 方法说明启用 HTTP 认证</span></span><br><span class="line">     			   .and()).httpBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>formLogin 方法配置了使用 Spring Security 的默认登录页面和 httpBasic 方法启用浏览器的 HTTP 基础认证方式</p>
<h3 id="配置请求路径访问权限"><a href="#配置请求路径访问权限" class="headerlink" title="配置请求路径访问权限"></a>配置请求路径访问权限</h3><p><strong>使用 Ant 风格配置限定</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WebSecurityConfigurerAdapter 默认设定访问权限和登录方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 限定签名后的权限</span></span><br><span class="line">    http.</span><br><span class="line">        <span class="comment">/* ============== 第一段 ============== */</span></span><br><span class="line">        authorizeRequests()</span><br><span class="line">        <span class="comment">// 限定 "/user/welcome" 请求赋予角色 ROLE_USER 或者 ROLE_ADMIN</span></span><br><span class="line">        .antMatchers(<span class="string">"/user/welcome"</span>, <span class="string">"/user/details"</span>).hasAnyRole(<span class="string">"USER"</span>, <span class="string">"ADMIN"</span>)</span><br><span class="line">        <span class="comment">// 限定 "/admin/" 先所有请求权限赋予角色 ROLE_ADMIN</span></span><br><span class="line">        .antMatchers(<span class="string">"/admin/**"</span>).hasAnyAuthority(<span class="string">"ROLE_ADMIN"</span>)</span><br><span class="line">        <span class="comment">// 其他路径允许签名后访问</span></span><br><span class="line">        .anyRequest().permitAll()</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ============== 第二段 ============== */</span></span><br><span class="line">        <span class="comment">// and 代表连接词</span></span><br><span class="line">        <span class="comment">// 对于没有配置权限的其他请求允许匿名访问</span></span><br><span class="line">        .and().anonymous()</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ============== 第三段 ============== */</span></span><br><span class="line">        <span class="comment">// 使用 Spring Security 默认的登录页面</span></span><br><span class="line">        .and().formLogin()</span><br><span class="line">        <span class="comment">// 启动 HTTP 基础验证</span></span><br><span class="line">        .and().httpBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center>权限方法说明</center>

<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>access(String)</td>
<td>参数为SpEL，如果返回为 true 则允许访问</td>
</tr>
<tr>
<td>anonymous()</td>
<td>允许匿名访问</td>
</tr>
<tr>
<td>authorizeRequests()</td>
<td>限定通过签名的请求</td>
</tr>
<tr>
<td>anyRequest()</td>
<td>限定任意的请求</td>
</tr>
<tr>
<td>hasAnyRole(String…)</td>
<td>将访问权限赋予多个角色（角色会自动加入前缀 “ROLE_”</td>
</tr>
<tr>
<td>hasRole(String)</td>
<td>将访问权限赋予一个角色（角色会自动加入前缀 “ROLE_”</td>
</tr>
<tr>
<td>permitAll()</td>
<td>无条件允许访问</td>
</tr>
<tr>
<td>and()</td>
<td>连接词，并取消之前限定前提规则</td>
</tr>
<tr>
<td>httpBasic()</td>
<td>启用浏览器的 HTTP 基础验证</td>
</tr>
<tr>
<td>formLogin()</td>
<td>启用 Spring Security 默认的登录页面</td>
</tr>
<tr>
<td>not()</td>
<td>对其他方法的访问采取求反</td>
</tr>
<tr>
<td>fullyAuthenticated()</td>
<td>如果是完整验证（并非 Remember-me），则允许访问</td>
</tr>
<tr>
<td>denyAll()</td>
<td>无条件不允许任何访问</td>
</tr>
<tr>
<td>hasIpAddress(String)</td>
<td>如果是给定的 IP 地址则允许访问</td>
</tr>
<tr>
<td>rememberme()</td>
<td>用户通过 Remember-me 功能验证就允许访问</td>
</tr>
<tr>
<td>hasAuthority(String)</td>
<td>如果是给定的角色就允许访问（不加入前缀 “ROLE_”）</td>
</tr>
<tr>
<td>hasAnyAuthority(String…)</td>
<td>如果是给定的角色中的任意一个就允许访问（不加入前缀 “ROLE_” ）</td>
</tr>
</tbody>
</table>
<p><strong>Spring 表达式设置权限</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        <span class="comment">// 使用 Spring 表达式限定只有角色 ROLE_USER 或者 ROLE_ADMIN</span></span><br><span class="line">        .antMatchers(<span class="string">"/user/**"</span>).access(<span class="string">"hasRole('USER') or hasRole('ADMIN')"</span>)</span><br><span class="line">        <span class="comment">// 设置访问权限给角色 ROLE_ADMIN，要求是完整登录（非记住登录）</span></span><br><span class="line">        .antMatchers(<span class="string">"/admin/welcome"</span>).access(<span class="string">"hasAnyAuthority('ROLE_ADMIN') &amp;&amp; isFullyAuthenticated()"</span>)</span><br><span class="line">        <span class="comment">// 限定 "/admin/welcome2" 访问权限给角色 ROLE_ADMIN，允许不完整登录</span></span><br><span class="line">        .antMatchers(<span class="string">"/admin/welcome2"</span>).access(<span class="string">"hasAnyAuthority('ROLE_ADMIN')"</span>)</span><br><span class="line">        <span class="comment">// 使用记住功能</span></span><br><span class="line">        .and().rememberMe()</span><br><span class="line">        <span class="comment">// 使用 Spring Security 默认的登录页面</span></span><br><span class="line">        .and().formLogin()</span><br><span class="line">        <span class="comment">// 启用 HTTP 基础验证</span></span><br><span class="line">        .and().httpBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>authentication()</td>
<td>用户认证对象</td>
</tr>
<tr>
<td>denyAll()</td>
<td>拒绝任何访问</td>
</tr>
<tr>
<td>hasAnyRole(String…)</td>
<td>当前用户是否存在参数中列明的对象属性</td>
</tr>
<tr>
<td>hasRole(String)</td>
<td>当前用户是否存在角色</td>
</tr>
<tr>
<td>hasIpAddress(String)</td>
<td>是否请求来自指定的 IP</td>
</tr>
<tr>
<td>isAnonymous()</td>
<td>是否匿名访问</td>
</tr>
<tr>
<td>isAuthenticated()</td>
<td>是否用户通过认证签名</td>
</tr>
<tr>
<td>isFullAuthenticated()</td>
<td>是否用户是完整验证，即非“记住我”功能通过的认证</td>
</tr>
<tr>
<td>isRememberMe()</td>
<td>是否是通过 “记住我” 功能通过的验证</td>
</tr>
<tr>
<td>permitAll()</td>
<td>无条件允许任何访问</td>
</tr>
<tr>
<td>principal()</td>
<td>用户的 principal 对象</td>
</tr>
</tbody>
</table>
<h2 id="用户认证功能"><a href="#用户认证功能" class="headerlink" title="用户认证功能"></a>用户认证功能</h2><h3 id="自定义登录页面"><a href="#自定义登录页面" class="headerlink" title="自定义登录页面"></a>自定义登录页面</h3><p><strong>Spring Boot 配置登录请求连接和 “记住我”</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.</span><br><span class="line">        <span class="comment">// 访问 /admin 下的请求需要管理员权限</span></span><br><span class="line">        authorizeRequests().antMatchers(<span class="string">"/admin/**"</span>).access(<span class="string">"hasRole('ADMIN')"</span>)</span><br><span class="line">        <span class="comment">// 启用 remember me 功能</span></span><br><span class="line">        .and().rememberMe().tokenValiditySeconds(<span class="number">86400</span>).key(<span class="string">"remember-me-key"</span>)</span><br><span class="line">        <span class="comment">// 启用 HTTP Basic 功能</span></span><br><span class="line">        .and().httpBasic()</span><br><span class="line">        <span class="comment">// 通过签名后可以访问任何请求</span></span><br><span class="line">        .and().authorizeRequests().antMatchers(<span class="string">"/**"</span>).permitAll()</span><br><span class="line">        <span class="comment">// 设置登录页和默认的跳转路径</span></span><br><span class="line">        .and().formLogin().loginPage(<span class="string">"/login/page"</span>).defaultSuccessUrl(<span class="string">"/admin/welcome1"</span>)</span><br><span class="line">        <span class="comment">// 登出页面和默认跳转路径</span></span><br><span class="line">        .and().logout().logoutUrl(<span class="string">"/logout/page"</span>).logoutSuccessUrl(<span class="string">"/welcome"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>remember 启用了 “记住我” 功能，有效期为 1 天</li>
<li>浏览器中将使用 Cookie 以键 “remember-mu-key” 进行保存，并且以 MD5 加密</li>
<li>loginPage 是指定登录路径为 “/login/page”</li>
<li>defaultSuccessUrl 方法是指定默认的跳转路径为 “/admin/welcome1”</li>
</ul>
<p><strong>新增映射关系</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加映射关系</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是的 /login/page 映射为 login.jsp</span></span><br><span class="line">        registry.addViewController(<span class="string">"/login/page"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">        <span class="comment">// 使得 /login/page 映射为 logout_welcome.jsp</span></span><br><span class="line">        registry.addViewController(<span class="string">"/login/page"</span>).setViewName(<span class="string">"logout_welcome"</span>);</span><br><span class="line">        <span class="comment">// 使得 /logout 映射为 logout.jsp</span></span><br><span class="line">        registry.addViewController(<span class="string">"/logout"</span>).setViewName(<span class="string">"logout"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day12）</title>
    <url>/2019/05/20/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day12%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/20/SpringBoot学习笔记（Day12）/小白.png" alt="插图"></p>
<h1 id="Spring-Security-安全"><a href="#Spring-Security-安全" class="headerlink" title="Spring Security 安全"></a>Spring Security 安全</h1><a id="more"></a>
<p><strong>Spring Boot 对 Spring Security 支持的配置项</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># SECURITY (SecurityProperties)</span><br><span class="line"># Spring Security 过滤器排序</span><br><span class="line">spring.security.filter.order=-100</span><br><span class="line"># 安全过滤器责任链拦截的分支类型</span><br><span class="line">spring.security.filter.dispatcher-types=async,error,request</span><br><span class="line"># 用户名</span><br><span class="line">spring.security.user.name=myuser</span><br><span class="line"># 用户密码</span><br><span class="line">spring.security.user.password=123456</span><br><span class="line"># 用户角色</span><br><span class="line">spring.security.user.roles=</span><br><span class="line"></span><br><span class="line"># SECURITY OATH2 CLIENT（OAuth2ClientProperties）</span><br><span class="line"># OAuth 提供者详情配置信息</span><br><span class="line">spring.security.oauth2.client.provider.*= #</span><br><span class="line"># OAuth 客户端登记信息</span><br><span class="line">spring.security.oauth2.client.registration.*=</span><br></pre></td></tr></table></figure>
<h2 id="使用-WebSecurityConfigurerAdapter-自定义"><a href="#使用-WebSecurityConfigurerAdapter-自定义" class="headerlink" title="使用 WebSecurityConfigurerAdapter 自定义"></a>使用 WebSecurityConfigurerAdapter 自定义</h2><p>WebSecurityConfigurerAdapter 中默认存在的三个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来配置用户签名服务，主要是 user-details 机制，还可以给予用户赋予角色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> auth 签名管理器构造器，用于构建用户具体权限控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来配置 Filter 链</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> web  Spring Web Security 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来配置拦截保护的请求，比如请求放行，请求验证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> http  http 安全请求对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>
<p>对于使用 WebSecurity 参数的方法主要是配置 Filter 链的内容，可以配置 Filter 链忽略那些内容。</p>
<h2 id="自定义用户服务信息"><a href="#自定义用户服务信息" class="headerlink" title="自定义用户服务信息"></a>自定义用户服务信息</h2><h3 id="使用内存签名服务"><a href="#使用内存签名服务" class="headerlink" title="使用内存签名服务"></a>使用内存签名服务</h3><p><strong>使用内存用户（取消连接方法 and() ）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chapter12Application</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 密码编码器</span></span><br><span class="line">        PasswordEncoder passwordEncoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">        <span class="comment">// 使用内存存储</span></span><br><span class="line">        InMemoryUserDetailsManagerConfigurer&lt;AuthenticationManagerBuilder&gt; userConfig</span><br><span class="line">                = auth.inMemoryAuthentication().passwordEncoder(passwordEncoder);</span><br><span class="line">        <span class="comment">// 注册用户 admin，密码为 abc，并赋予 USER 和 ADMIN 的角色权限</span></span><br><span class="line">        userConfig.withUser(<span class="string">"admin"</span>)</span><br><span class="line">                .password(passwordEncoder.encode(<span class="string">"abc"</span>))</span><br><span class="line">                .authorities(<span class="string">"ROLE_USER"</span>, <span class="string">"ROLE_ADMIN"</span>);</span><br><span class="line">        userConfig.withUser(<span class="string">"myuser"</span>)</span><br><span class="line">                .password(passwordEncoder.encode(<span class="string">"123456"</span>))</span><br><span class="line">                .authorities(<span class="string">"ROLE_USER"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用内存缓存用户信息方式不是主要方式，因为内存空间优先，而且会占用 JVM 内存空间</p>
<center>UserDetailsBuilder 方法简介</center>

<table>
<thead>
<tr>
<th>项目类型</th>
<th>描        述</th>
</tr>
</thead>
<tbody>
<tr>
<td>accountExpired(boolean)</td>
<td>设置账号是否过期</td>
</tr>
<tr>
<td>accountLocked(boolean)</td>
<td>是否锁定账号</td>
</tr>
<tr>
<td>credentialsExpired(boolean)</td>
<td>定义凭证是否过期</td>
</tr>
<tr>
<td>disabled(boolean)</td>
<td>是否禁用用户</td>
</tr>
<tr>
<td>username(String)</td>
<td>定义用户名</td>
</tr>
<tr>
<td>authorities(GrantedAuthority…)</td>
<td>赋予一个或者多个权限</td>
</tr>
<tr>
<td>authorities(List&lt;? extends GrantedAuthority)</td>
<td>使用列表（List）赋予权限</td>
</tr>
<tr>
<td>password(String)</td>
<td>定义密码</td>
</tr>
<tr>
<td>roles(String…)</td>
<td>赋予角色，会自动加入前缀 “ROLE_”</td>
</tr>
</tbody>
</table>
<h3 id="使用数据库定义用户认证服务"><a href="#使用数据库定义用户认证服务" class="headerlink" title="使用数据库定义用户认证服务"></a>使用数据库定义用户认证服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注入数据源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用和用户名称查询密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String pwdQuery = <span class="string">" select user_name, pwd, available from t_user3 where user_name = ?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用用户名称查询角色信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String roleQuery = <span class="string">"select u.user_name, r.role_name "</span> +</span><br><span class="line">    <span class="string">"from t_user3 as u, t_user_role as ur, t_role as r "</span> +</span><br><span class="line">    <span class="string">"where u.id = ur.user_id, and r.id = ur.role_id "</span> +</span><br><span class="line">    <span class="string">"and u.user_name = ?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 覆盖 WebSecurityConfigurerAdapter 用户详情方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> auth 用户签名管理器构造器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PasswordEncoder passwordEncoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    auth.jdbcAuthentication()</span><br><span class="line">        <span class="comment">// 密码编码器</span></span><br><span class="line">        .passwordEncoder(passwordEncoder)</span><br><span class="line">        <span class="comment">// 数据源</span></span><br><span class="line">        .dataSource(dataSource)</span><br><span class="line">        <span class="comment">// 查询用户，自动判断密码是否一致</span></span><br><span class="line">        .usersByUsernameQuery(pwdQuery)</span><br><span class="line">        <span class="comment">// 赋予权限</span></span><br><span class="line">        .authoritiesByUsernameQuery(roleQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>设置密码管理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注入数据源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用和用户名称查询密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String pwdQuery = <span class="string">" select user_name, pwd, available from t_user3 where user_name = ?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用用户名称查询角色信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String roleQuery = <span class="string">"select u.user_name, r.role_name "</span> +</span><br><span class="line">    <span class="string">"from t_user3 as u, t_user_role as ur, t_role as r "</span> +</span><br><span class="line">    <span class="string">"where u.id = ur.user_id, and r.id = ur.role_id "</span> +</span><br><span class="line">    <span class="string">"and u.user_name = ?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注入配置的钥匙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;system.user.password.secret&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String secret = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PasswordEncoder passwordEncoder = <span class="keyword">new</span> Pbkdf2PasswordEncoder(<span class="keyword">this</span>.secret);</span><br><span class="line">    auth.jdbcAuthentication()</span><br><span class="line">        .passwordEncoder(passwordEncoder)</span><br><span class="line">        .dataSource(dataSource)</span><br><span class="line">        .usersByUsernameQuery(pwdQuery)</span><br><span class="line">        .authoritiesByUsernameQuery(roleQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle学习笔记01</title>
    <url>/2019/05/18/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<a id="more"></a>
<ol>
<li>count() 如果字段为空，则不统计，* 全部统计</li>
<li>排序 asc 升序，desc 降序</li>
<li>通过其他表创建一个新表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> EMP3 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> EMP_NO, EMP_NAME</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> EMP_NO &lt;= <span class="number">10</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>左连接和右连接的主表信息全部显示：左连接的左表示主表，右连接的右表是主表</li>
<li>full join 全连接，有无关联都显示</li>
<li>左连接简写</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.EMP_NO, e.EMP_NAME, d.DEPT_NAME</span><br><span class="line"><span class="keyword">FROM</span> EMP e, DEPT d</span><br><span class="line"><span class="keyword">WHERE</span> e.DEPTNO = d.DEPT_NO(+)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> e.EMP_NO</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>右连接简写</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.EMP_NO, e.EMP_NAME, d.DEPT_NAME</span><br><span class="line"><span class="keyword">FROM</span> EMP e, DEPT d</span><br><span class="line"><span class="keyword">WHERE</span> e.DEPTNO(+) = d.DEPT_NO</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> e.EMP_NO</span><br></pre></td></tr></table></figure>
<ol start="8">
<li><p>all 表示必须满足所有及结果集，any 表示满足其中一个结果集就可以</p>
</li>
<li><p>ROWID 获取物理地址</p>
</li>
<li><p>ROWNUM 在查询的列前面，添加序号</p>
</li>
<li><p>intersect 放在两个查询之间，表示取交集</p>
</li>
<li><p>union 表示取并集</p>
</li>
<li><p>minus 表示取差集</p>
</li>
<li><p>单行函数 / 聚合函数</p>
<p>单行函数：对每一个函数应用在表的记录中时，只能输入一行结果，返回一个结果.</p>
<p>聚合函数：聚合函数同时可以对多行数据进行操作，并返回一个结果.</p>
</li>
<li><p>decode函数</p>
<p><strong>decode</strong>(条件,值1,返回值1,值2,返回值2,…值n,返回值n,缺省值)</p>
</li>
<li><p>case </p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.EMP_NO, e.EMP_NAME, (</span><br><span class="line">	<span class="keyword">CASE</span> </span><br><span class="line">		<span class="keyword">WHEN</span> e.SALARY &gt;= <span class="number">900</span> <span class="keyword">THEN</span> <span class="string">'A'</span></span><br><span class="line">		<span class="keyword">WHEN</span> e.SALARY &gt;= <span class="number">700</span> <span class="keyword">AND</span> e.SALARY &lt; <span class="number">900</span> <span class="keyword">THEN</span> <span class="string">'B'</span></span><br><span class="line">		<span class="keyword">WHEN</span> e.SALARY &gt;= <span class="number">300</span> <span class="keyword">AND</span> e.SALARY &lt; <span class="number">700</span> <span class="keyword">THEN</span> <span class="string">'C'</span></span><br><span class="line">		<span class="keyword">ELSE</span> <span class="string">'D'</span></span><br><span class="line">	<span class="keyword">END</span></span><br><span class="line">) lvl</span><br><span class="line"><span class="keyword">FROM</span> EMP e</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> lvl</span><br></pre></td></tr></table></figure>
<ol start="17">
<li>恢复数据库</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取当前时间</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> NTUCTY.EMP</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">of</span> <span class="keyword">scn</span> <span class="number">12156162</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">FROM</span> EMP e</span><br><span class="line"><span class="keyword">WHERE</span> e.EMP_NO = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先运行这一条命令 启用行移动功能</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> NTUCTY.EMP <span class="keyword">enable</span> <span class="keyword">row</span> <span class="keyword">movement</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在运行这一条 恢复数据</span></span><br><span class="line">flashback table NTUCTY.EMP to scn 12156162;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle - 自学笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day11）</title>
    <url>/2019/05/16/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day11%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/16/SpringBoot学习笔记（Day11）/erik-kaha-1575002-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>Photo by <a href="https://unsplash.com/photos/9Nok_iZEgLk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Erik Kaha</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="REST-风格网站"><a href="#REST-风格网站" class="headerlink" title="REST 风格网站"></a>REST 风格网站</h2><h3 id="HTTP-动作"><a href="#HTTP-动作" class="headerlink" title="HTTP 动作"></a>HTTP 动作</h3><ul>
<li>GET（VISIT）：访问服务器资源（一个或多个资源）</li>
<li>POST（CREATE）：提交服务器资源信息，用来创建新的资源</li>
<li>PUT（UPDATE）：修改服务器已经存在的资源，使用 PUT 时需要把资源的所有属性一并提交</li>
<li>PATCH（UPDATE）：修改服务器已经存在的资源，使用 PATCH 时只需要将部分资源属性提交</li>
<li>DELETE（DELETE）：从服务器将资源删除</li>
</ul>
<h3 id="Spring-MVC-整合-REST"><a href="#Spring-MVC-整合-REST" class="headerlink" title="Spring MVC 整合 REST"></a>Spring MVC 整合 REST</h3><p>如果是简单参数，往往直接通过 URL 直接传递，在 Spring MVC 中可以使用注解 @PathVariable 进行获取。<strong>（动点脑子，复杂的你确定你会用 URL 传吗，肯定 JSON 啊）</strong></p>
<p><strong>@RequestBody</strong> 可以将请求体为 JSON 的数据转化为复杂的 Java 对象。</p>
<h3 id="处理-HTTP-状态码、异常和响应头"><a href="#处理-HTTP-状态码、异常和响应头" class="headerlink" title="处理 HTTP 状态码、异常和响应头"></a>处理 HTTP 状态码、异常和响应头</h3><p>Spring 提供了实体封装类 ResponseEntity 和注解 @ResponseStatus</p>
<ul>
<li>ResponseEntity 封装错误消息和状态码</li>
<li>@ResponseStatus 配置指定的响应码给客户端</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day10）</title>
    <url>/2019/05/15/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day10%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/15/SpringBoot学习笔记（Day10）/max-ducourneau-1580353-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>Photo by <a href="https://unsplash.com/photos/P_J3chFYwIU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Max Ducourneau</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Spring-MVC-补充知识"><a href="#Spring-MVC-补充知识" class="headerlink" title="Spring MVC 补充知识"></a>Spring MVC 补充知识</h2><h3 id="ResponseBody-转换为-JSON-的原理"><a href="#ResponseBody-转换为-JSON-的原理" class="headerlink" title="@ResponseBody 转换为 JSON 的原理"></a>@ResponseBody 转换为 JSON 的原理</h3><p><center>@ResponseBody 注解转换为 JSON 流程图</center></p>
<p><img src="/2019/05/15/SpringBoot学习笔记（Day10）/@ResponseBody 注解转换为 JSON 流程图.jpg" alt="@ResponseBody 注解转换为 JSON 流程图"></p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>废话不多说，直接上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/show"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showUser</span><span class="params">(Long id, Model model)</span> </span>&#123;</span><br><span class="line">    User user = userService.getUser(id);</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"data/user"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用字符串指定跳转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> note</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/redirect1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">redirect1</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setNote(note);</span><br><span class="line">    user.setUserName(userName);</span><br><span class="line">    <span class="comment">// 插入数据库后，回填 user 的 id</span></span><br><span class="line">    userService.insertUser(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/user/show?id="</span> + user.getId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用模型和视图指定跳转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> note</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/redirect2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">redirect2</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setNote(note);</span><br><span class="line">    user.setUserName(userName);</span><br><span class="line">    <span class="comment">// 插入数据库后，回填 user 的 id</span></span><br><span class="line">    userService.insertUser(user);</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.setViewName(<span class="string">"redirect:/user/show?id="</span> + user.getId());</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进版本</p>
<p><strong>重定向传递 Java 对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user 直接从数据模型 RedirectAttributes 对象中取出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/showUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showUser</span><span class="params">(User user, Model model)</span> </span>&#123;</span><br><span class="line">    System.out.println(user.getId());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"data/user"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用字符串指定跳转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> note</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ra</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/redirect1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">redirect1</span><span class="params">(String userName, String note, RedirectAttributes ra)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setNote(note);</span><br><span class="line">    user.setUserName(userName);</span><br><span class="line">    <span class="comment">// 插入数据库后，回填 user 的 id</span></span><br><span class="line">    userService.insertUser(user);</span><br><span class="line">    <span class="comment">// 保存需要传递给重定向的对象</span></span><br><span class="line">    ra.addFlashAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/user/showUser"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用模型和视图指定跳转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> note</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ra</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/redirect2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">redirect2</span><span class="params">(String userName, String note, RedirectAttributes ra)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setNote(note);</span><br><span class="line">    user.setUserName(userName);</span><br><span class="line">    <span class="comment">// 插入数据库后，回填 user 的 id</span></span><br><span class="line">    userService.insertUser(user);</span><br><span class="line">    <span class="comment">// 保存需要传递给重定向的对象</span></span><br><span class="line">    ra.addFlashAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.setViewName(<span class="string">"redirect:/user/showUser"</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中给方法中加入了 RedirectAttributes 对象参数，然后将 redirect1 和 redirect2 方法的用户信息通过 addFlashAttribute 保存起来，在执行重定向的时候，再将 user 对象传递</p>
<p>被 addFlashAttribute 保存的参数，在控制器执行完之后，会被保存到 Session 对象中；</p>
<p>执行重定向的时候，进入重定向前首先把 Session 中的参数取出，用以填充重定向方法的参数和数据模型，之后删除 Session 中的数据，执行重定向方法，并传递对象</p>
<center>重定向传递对象的流程图</center>

<p><img src="/2019/05/15/SpringBoot学习笔记（Day10）/重定向传递对象的流程图.jpg" alt="重定向传递对象的流程图"></p>
<h3 id="操作会话对象"><a href="#操作会话对象" class="headerlink" title="操作会话对象"></a>操作会话对象</h3><ul>
<li>@SessionAttribute 应用于参数，将 HTTPSession 中的属性读出</li>
<li>@SessionAttributes 只能用于类的注解，将相关数据模型的属性保存到 Session 中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SessionAttributes</span>(names = &#123;<span class="string">"user"</span>&#125;, types = Long.class)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/session"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id <span class="doctag">@SessionAttribute</span> 从 HttpSession 中取出数据，填充控制器方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@SessionAttribute(<span class="string">"id"</span>)</span> Long id, Model model) </span>&#123;</span><br><span class="line">        <span class="comment">// 根据类型保存到 Session 中</span></span><br><span class="line">        model.addAttribute(<span class="string">"id_new"</span>, id);</span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        <span class="comment">// 根据名称保存到 Session 中</span></span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"session/test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给控制器增加通知"><a href="#给控制器增加通知" class="headerlink" title="给控制器增加通知"></a>给控制器增加通知</h3><ul>
<li>@ControllerAdvice：定义一个控制器的通知类，允许定义一些关于增强控制器的各类通知和限定增强哪些控制器功能等；</li>
<li>@InitBinder：定义控制器参数绑定规则，如转换规则，格式化等，他会在参数转换之前执行；</li>
<li>@ExceptionHandler：定义控制器发生异常后的操作。发生异常后转跳到指定的友好页面；</li>
<li>@ModelAttribute：可以在控制器方法前执行，对数据模型进行操作；</li>
</ul>
<p><strong><em>（这里有点复杂，笔记没法描述清楚，请看《SpringBoot 深入浅出》第 245 页）</em></strong></p>
<h3 id="获取请求头参数"><a href="#获取请求头参数" class="headerlink" title="获取请求头参数"></a>获取请求头参数</h3><p><strong>带请求头的 HTTP 请求</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.post(&#123;</span><br><span class="line">    url : <span class="string">"$&#123;pageContext.request.contextPath&#125;/user/header/user"</span>,</span><br><span class="line">    <span class="comment">// 设置请求头参数</span></span><br><span class="line">    headers : &#123;<span class="attr">id</span> : <span class="string">'1'</span>&#125;,</span><br><span class="line">    <span class="comment">// 成功后的方法</span></span><br><span class="line">    success : <span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span> || user.id == <span class="literal">null</span>) &#123;</span><br><span class="line">            alert(<span class="string">"获取失败"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 弹出请求返回的用户信息</span></span><br><span class="line">        alert(<span class="string">"id="</span> + user.id +<span class="string">", user_name="</span></span><br><span class="line">              +user.userName+<span class="string">", note="</span>+ user.note);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>代码中的 “headers : {id : ‘1’}” 设置了一个请求头，是一个键为 id 而值为 1 的请求头</p>
<p><strong>使用 @RequestHeader 接收请求头参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 <span class="doctag">@RequestHeader</span> 接收请求头参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/header/user"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">headerUser</span><span class="params">(@RequestHeader(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过注解 @RequestHeader(“id”) 获取请求请求头中的的 id 键值</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day09）</title>
    <url>/2019/05/14/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day09%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/14/SpringBoot学习笔记（Day09）/sid-verma-1387708-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>Photo by <a href="https://unsplash.com/photos/5BsNkTMbZZ0?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Sid Verma</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="Spring-MVC-对文件上传的支持"><a href="#Spring-MVC-对文件上传的支持" class="headerlink" title="Spring MVC 对文件上传的支持"></a>Spring MVC 对文件上传的支持</h3><center>文件请求转换类之间的关系</center>

<p><img src="/2019/05/14/SpringBoot学习笔记（Day09）/文件请求转换类之间的关系.jpg" alt="文件请求转换类之间的关系"></p>
<p>Spring MVC 会将 HttpServletRequest 对象转化为 MultipartHttpServletRequest 对象；</p>
<p>上传文件时，还需要配置 MultipartHttpServletRequest，是通过 MultipartResolver 接口实现的；</p>
<p>MultipartResolver 有两个实现类：StandardServletMultipartResolver 和 CommonsMultipartResolver，推荐使用前者进行文件上传（如果没有自定义 MultipartResolver，Spring Boot 自定创建 StandardServletMultipartResolver 对象）；</p>
<p><strong>文件上传配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># MULTIPART (MultipartProperties)</span><br><span class="line"># 是否启用 Spring MVC 多分部上传功能</span><br><span class="line">spring.servlet.multipart.enabled=true</span><br><span class="line"># 将文件写入磁盘的阈值。值可以使用后缀&quot;MB&quot;或&quot;KB&quot;来表示兆字节或字节大小</span><br><span class="line">spring.servlet.multipart.file-size-threshold=0</span><br><span class="line"># 指定默认上传的文件夹</span><br><span class="line">spring.servlet.multipart.location=</span><br><span class="line"># 限制单个文件最大大小</span><br><span class="line">spring.servlet.multipart.max-file-size=1MB</span><br><span class="line"># 限制所有文件最大大小</span><br><span class="line">spring.servlet.multipart.max-request-size=10MB</span><br><span class="line"># 是否延迟多部文件请求的参数和文件的解析</span><br><span class="line">spring.servlet.multipart.resolve-lazily=false</span><br></pre></td></tr></table></figure>
<p><strong>上传文件 Controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/file"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开文件上传请求页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指向 JSP 的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/upload/page"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/file/upload"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用HTTPServletRequest 作为参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/upload/request"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">uploadRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        MultipartHttpServletRequest mreq = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 强制转换为 MultipartHttpServletRequest 接口对象</span></span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> MultipartHttpServletRequest) &#123;</span><br><span class="line">            mreq = (MultipartHttpServletRequest) request;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dealRequestMap(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取 MultipartFile 文件信息</span></span><br><span class="line">        MultipartFile mf = mreq.getFile(<span class="string">"file"</span>);</span><br><span class="line">        <span class="comment">// 获取源文件名称</span></span><br><span class="line">        String fileName = mf != <span class="keyword">null</span> ? mf.getOriginalFilename() : <span class="keyword">null</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保存文件</span></span><br><span class="line">            mf.transferTo(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> dealRequestMap(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dealRequestMap(<span class="keyword">true</span>, <span class="string">"上传成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Spring MVC 的 MultipartFile 类作为参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/upload/multipart"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">uploadMultipartFile</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        File dest = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(dest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> dealRequestMap(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dealRequestMap(<span class="keyword">true</span>, <span class="string">"上传成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/upload/part"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">uploadPart</span><span class="params">(Part file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取提交文件名称</span></span><br><span class="line">        String fileName = file.getSubmittedFileName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 写入文件</span></span><br><span class="line">            file.write(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> dealRequestMap(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dealRequestMap(<span class="keyword">true</span>, <span class="string">"上传成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理上传文件结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> success</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">dealRequestMap</span><span class="params">(<span class="keyword">boolean</span> success, String msg)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        result.put(<span class="string">"success"</span>, success);</span><br><span class="line">        result.put(<span class="string">"msg"</span>, msg);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>当请求来到 DispatcherServlet 时，会根据 HandlerMapping 的机制找到处理器，这样就会返回一个 HandlerExecution 对象，这个对象包含处理器和拦截器，拦截器会对处理器进行拦截。</p>
<h3 id="拦截器的设计"><a href="#拦截器的设计" class="headerlink" title="拦截器的设计"></a>拦截器的设计</h3><p><strong>HandlerInterceptor 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理器执行前方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理器处理后方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理器完成后方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center>拦截器执行过程</center>

<p><img src="/2019/05/14/SpringBoot学习笔记（Day09）/拦截器执行过程.jpg" alt="拦截器执行过程"></p>
<ol>
<li>执行 preHandle 方法，返回一个布尔值，如果为 false，则结束所有流程；如果为 true，则执行下一步</li>
<li>执行处理器逻辑，它包含控制器的功能</li>
<li>执行 postHandle 方法</li>
<li>执行视图解析和视图渲染</li>
<li>执行 afterCompletion 方法</li>
</ol>
<p><strong>自定义简单拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理器前方法"</span>);</span><br><span class="line">        <span class="comment">// 返回 true，不会拦截后续的处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理器后方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"处理器完成方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注册拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chapter10Application</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Chapter10Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册拦截器到 Spring MVC 机制，然后会返回一个拦截器注册</span></span><br><span class="line">        InterceptorRegistration ir = registry.addInterceptor(<span class="keyword">new</span> Interceptor1());</span><br><span class="line">        <span class="comment">// 指定拦截匹配模式，限制拦截器拦截请求</span></span><br><span class="line">        ir.addPathPatterns(<span class="string">"/interceptor/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果注册多个，和上面一样配置</p>
<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><h3 id="国际化消息源"><a href="#国际化消息源" class="headerlink" title="国际化消息源"></a>国际化消息源</h3><p>大部分情况下，是使用 JDK 的 ResourceBundle 处理国际化信息的，为此这里主要使用 ResourceBundleMessageSource 这个国际化消息源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置国际化消息是否总是采用格式化，默认 false</span><br><span class="line">spring.messages.always-use-message-format=false</span><br><span class="line"># 设置国际化属性名称，如果可以使用逗号分隔，默认为 message</span><br><span class="line">spring.messages.basename=messages</span><br><span class="line"># 设置国际化消息缓存超时秒数，默认为永远不过期，如果为 0 表示每次都重新加载</span><br><span class="line">spring.messages.cache-duration=</span><br><span class="line"># 国际化消息编码</span><br><span class="line">spring.messages.encoding=utf-8</span><br><span class="line"># 如果没有找到特定区域设置的文件，则设置是否返回到系统区域设置</span><br><span class="line">spring.messages.fallback-to-system-locale=true</span><br><span class="line"># 是否使用消息编码作为默认的响应消息，而非抛出 NoSuchMessageException 异常，建议只在开发时使用</span><br><span class="line">spring.messages.use-code-as-default-message=false</span><br></pre></td></tr></table></figure>
<h3 id="国际化解析器"><a href="#国际化解析器" class="headerlink" title="国际化解析器"></a>国际化解析器</h3><ul>
<li>AcceptHeaderLocaleResolver：使用浏览器头请求去实现国际化区域</li>
<li>FixedLocaleResolve：固定国际化区域。</li>
<li>CookieLocaleResolve：将国际化区域信息设置在浏览器 Cookie 中，使得系统可以从 Cookie 中读取国际化信息来确定用户的国际化区域</li>
<li>SessionLocaleResolve：类似于 CookieLocaleResolve，只是将国际化信息设置在 Session 中，这样就能读取 Session 中的信息去确定用户的国际化区域</li>
</ul>
<center>国际化解析器设计</center>

<p><img src="/2019/05/14/SpringBoot学习笔记（Day09）/国际化解析器设计.jpg" alt="国际化解析器设计"></p>
<center>Spring MVC 国际化流程图</center>

<p><img src="/2019/05/14/SpringBoot学习笔记（Day09）/Spring MVC 国际化流程图.jpg" alt="Spring MVC 国际化流程图"></p>
<p>LocaleChangeInterceptor 拦截器可以通过请求参数来确定国际化，同时吧请求参数保存到 Session 中。</p>
<p><strong>在 Spring Boot 启动 java 文件中添加国家化解析器和拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 国际化解析器</span></span><br><span class="line"><span class="comment">     * Bean Name 要为 localeResolve</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"localeResolver"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">initLocaleResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SessionLocaleResolver slr = <span class="keyword">new</span> SessionLocaleResolver();</span><br><span class="line">        <span class="comment">// 默认国际化区域</span></span><br><span class="line">        slr.setDefaultLocale(Locale.SIMPLIFIED_CHINESE);</span><br><span class="line">        <span class="keyword">return</span> slr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建国际化拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocaleChangeInterceptor <span class="title">localeChangeInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lci != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lci;</span><br><span class="line">        &#125;</span><br><span class="line">        lci.setParamName(<span class="string">"language"</span>);</span><br><span class="line">        <span class="keyword">return</span> lci;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给处理器增加国际化拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里将通过国际化拦截器的 preHandle 方法对请求的国际化区域参数进行修改</span></span><br><span class="line">        registry.addInterceptor(localeChangeInterceptor());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>initLocaleResolver 方法创建了一个国际化拦截器，有两点需要注意，第一，保证 BeanName 为 “localeResolver”；第二，设置了默认语言为简体中文；</li>
<li>localeChangeInterceptor 方法创建国际化拦截器，这里设置拦截参数为 “language”；</li>
<li>addInterceptors 方法将拦截器添加到 Spring MVC 中；</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day08）</title>
    <url>/2019/05/11/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day08%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/11/SpringBoot学习笔记（Day08）/asoggetti-1486419-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>Photo by <a href="https://unsplash.com/photos/VJTmFSendQ0?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">asoggetti</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="处理器映射"><a href="#处理器映射" class="headerlink" title="处理器映射"></a>处理器映射</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="comment">// 配置请求映射名称</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 通过路径映射</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"path"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 通过路径映射回 path 配置项</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限定只响应 HTTP 请求类型，如 GET，POST，HEAD，OPTIONS，PUT，TRACE 等</span></span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当存在对应的 HTTP 参数时才响应请求</span></span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限定请求头存在对应的参数时才响应</span></span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限定 HTTP 请求体提交类型，如 "application/json"、"text/html"</span></span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 限定返回的内容类型，仅当 HTTP 请求头中的（Accept）类型中包含该指定类型时才返回</span></span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取控制器参数"><a href="#获取控制器参数" class="headerlink" title="获取控制器参数"></a>获取控制器参数</h2><p>处理器是对控制器的包装，处理器运行过程中会调度控制器的方法，只是它在进入控制器方法之前会对 HTTP 的参数和上下文进行解析</p>
<h3 id="无注解下获取参数"><a href="#无注解下获取参数" class="headerlink" title="无注解下获取参数"></a>无注解下获取参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在无注解下获取参数，要求参数名称和 HTTP 参数名称一致</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intVal —— 整数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longVal —— 长整型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string —— 字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 响应 JSON 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/no/annotation"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">noAnnotation</span><span class="params">(Integer intVal, Long longVal, String string)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    paramsMap.put(<span class="string">"intVal"</span>, intVal);</span><br><span class="line">    paramsMap.put(<span class="string">"longVal"</span>, longVal);</span><br><span class="line">    paramsMap.put(<span class="string">"str"</span>, string);</span><br><span class="line">    <span class="keyword">return</span> paramsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-RequestParam-获取参数"><a href="#使用-RequestParam-获取参数" class="headerlink" title="使用 @RequestParam 获取参数"></a>使用 @RequestParam 获取参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过注解 <span class="doctag">@RequestParam</span> 获取参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intVal —— 整数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> longVal —— 长整型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> strVal —— 字符串，在默认情况下，标注的参数是不能为空的，为了能让它为空，可以配置其属性 required 为 false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 响应 JSON 数据集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/annotation"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">requestParam</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @RequestParam(<span class="string">"int_val"</span>)</span> Integer intVal,</span></span><br><span class="line"><span class="function">    @<span class="title">RequestParam</span><span class="params">(<span class="string">"long_val"</span>)</span> Long longVal,</span></span><br><span class="line"><span class="function">    @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"str_val"</span>, required = <span class="keyword">false</span>)</span> String strVal) </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    paramsMap.put(<span class="string">"intVal"</span>, intVal);</span><br><span class="line">    paramsMap.put(<span class="string">"longVal"</span>, longVal);</span><br><span class="line">    paramsMap.put(<span class="string">"strVal"</span>, strVal);</span><br><span class="line">    <span class="keyword">return</span> paramsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传递数组"><a href="#传递数组" class="headerlink" title="传递数组"></a>传递数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/requestArray"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">requestArray</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>[] intArr, Long[] longArr, String[] strArr)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    paramsMap.put(<span class="string">"intArr"</span>, intArr);</span><br><span class="line">    paramsMap.put(<span class="string">"longArr"</span>, longArr);</span><br><span class="line">    paramsMap.put(<span class="string">"strArr"</span>, strArr);</span><br><span class="line">    <span class="keyword">return</span> paramsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传递-JSON"><a href="#传递-JSON" class="headerlink" title="传递 JSON"></a>传递 JSON</h3><p>方法的参数标注为 @RequestBody，意味着它将接受前端提交的 JSON 请求体，在 JSON 请求体与 User 类之间的属性名称保持一致的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user 通过 <span class="doctag">@RequestBody</span> 注解得到 JSON 参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 回填 id 后的用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">insert</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">    userService.insertUser(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过-URL-传递参数"><a href="#通过-URL-传递参数" class="headerlink" title="通过 URL 传递参数"></a>通过 URL 传递参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过 @GetMapping 指定一个 URL，然后用 {…} 来标明参数的位置和名称，这里指定名称为 id，Spring MVC 就会根据请求去匹配这个方法；@PathVariable 配置的字符串为 id，它对应 URL 的参数声明，这样 Spring 就知道如何从 URL 中获取参数。</p>
<h3 id="获取格式化参数"><a href="#获取格式化参数" class="headerlink" title="获取格式化参数"></a>获取格式化参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/format/commit"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">format</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @DateTimeFormat(iso = DateTimeFormat.ISO.DATE)</span> Date date,</span></span><br><span class="line"><span class="function">    @<span class="title">NumberFormat</span><span class="params">(pattern = <span class="string">"#,###,##"</span>)</span> Double number) </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; dataMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    dataMap.put(<span class="string">"date"</span>, date);</span><br><span class="line">    dataMap.put(<span class="string">"number"</span>, number);</span><br><span class="line">    <span class="keyword">return</span> dataMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@DateTimeFormat 和 @NumberFormat 配置了格式话所约定的格式</p>
<p>在 Spring Boot 中，日期参数的格式化也可以不使用 @DateTimeFormat，而只在配置文件 application.properties 中加入如下配置：</p>
<p>spring.mvc.date-format=yyyy-MM-dd</p>
<h2 id="自定义参数转换规则"><a href="#自定义参数转换规则" class="headerlink" title="自定义参数转换规则"></a>自定义参数转换规则</h2><h3 id="处理器获取参数逻辑"><a href="#处理器获取参数逻辑" class="headerlink" title="处理器获取参数逻辑"></a>处理器获取参数逻辑</h3><p><strong>HttpMessageConverter 接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpMessageConverter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 是否可读，其中 clazz 为 Java 类型，mediaType 为 HTTP 请求类型</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">(Class&lt;?&gt; var1, @Nullable MediaType var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 clazz 类型是否能够转换为 mediaType 媒体类型</span></span><br><span class="line">    <span class="comment">// 其中 clazz 为 java 类型，mediaType 为 HTTP 响应类型</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(Class&lt;?&gt; var1, @Nullable MediaType var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可支持的媒体类型列表</span></span><br><span class="line">    <span class="function">List&lt;MediaType&gt; <span class="title">getSupportedMediaTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 canRead 验证通过后，读入 HTTP 请求信息</span></span><br><span class="line">    <span class="function">T <span class="title">read</span><span class="params">(Class&lt;? extends T&gt; var1, HttpInputMessage var2)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 canWrite 方法验证通过后，写入响应</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T var1, @Nullable MediaType var2, HttpOutputMessage var3)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Spring MVC 中，是通过 WebDataBinder 机制来获取参数的，作用是解析 HTTP 请求上下文，在控制器的调用之前，转换参数并且提供验证的功能，为调用控制器方法做准备；</p>
<p>处理器会从 HTTP 请求中读取数据，然后通过三类接口进行各类参数转换，分别是 Converter，Formatter 和 GenericConverter</p>
<center>Spring MVC 处理器 HTTP 请求体转换流程图</center>

<p><img src="/2019/05/11/SpringBoot学习笔记（Day08）/Spring MVC 处理器 HTTP 请求体转换流程图.jpg" alt="Spring MVC 处理器 HTTP 请求体转换流程图"></p>
<p>Convert：是一个普通的转换器</p>
<p>Formatter：是一个格式转换器</p>
<p>GenericConverter：将 HTTP 参数转换为数组</p>
<center>ConversionService 转化机制设计</center>

<p><img src="/2019/05/11/SpringBoot学习笔记（Day08）/ConversionService转化机制设计.jpg" alt="ConversionService转化机制设计"></p>
<p><strong>Spring Boot 的自动注册机制</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历 IoC 容器，找到 Converter 类型的 Bean 注册到服务类中</span></span><br><span class="line">    <span class="keyword">for</span> (Converter&lt;?, ?&gt; converter : getBeansOfType(Converter.class)) &#123;</span><br><span class="line">        registry.addConverter(converter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 IoC 容器，找到 GenericConverter 类型的 Bean 注册到服务类中</span></span><br><span class="line">    <span class="keyword">for</span> (GenericConverter converter : getBeansOfType(GenericConverter.class)) &#123;</span><br><span class="line">        registry.addConverter(converter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 IoC 容器，找到 Formatter 类型的 Bean 注册到服务类中</span></span><br><span class="line">    <span class="keyword">for</span> (Formatter&lt;?&gt; formatter : getBeansOfType(Formatter.class)) &#123;</span><br><span class="line">        registry.addFormatter(formatter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Boot 初始化时，会将对应用户自定义的 Converter，Formatter 和 GenericConverter 的实现类所创建的 Spring Bean 自动的注册到 DefaultFormattingConversionService 对象中。</p>
<h2 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h2><h3 id="JSR-303-验证"><a href="#JSR-303-验证" class="headerlink" title="JSR-303 验证"></a>JSR-303 验证</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorPojo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非空判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"id不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Future</span>(message = <span class="string">"需要一个将来日期"</span>)      <span class="comment">// 只能是将来的日期</span></span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd"</span>)  <span class="comment">// 日期格式化</span></span><br><span class="line">    <span class="meta">@NotNull</span>                                 <span class="comment">// 不能为空</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@DecimalMin</span>(value = <span class="string">"0.1"</span>)               <span class="comment">// 最小值 0.1 元</span></span><br><span class="line">    <span class="meta">@DecimalMax</span>(value = <span class="string">"10000.00"</span>)          <span class="comment">// 最大值为 10000 元</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleValue = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">1</span>, message = <span class="string">"最小值为1"</span>)    <span class="comment">// 最小值为 1</span></span><br><span class="line">    <span class="meta">@Max</span>(value = <span class="number">38</span>, message = <span class="string">"最大值为88"</span>)  <span class="comment">// 最大值为 88</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Integer integer;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Range</span>(min = <span class="number">1</span>, max = <span class="number">888</span>, message = <span class="string">"范围为1至888"</span>)    <span class="comment">// 限定范围</span></span><br><span class="line">    <span class="keyword">private</span> Long range;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮箱验证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Email</span>(message = <span class="string">"邮箱格式错误"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Size</span>(min = <span class="number">20</span>, max = <span class="number">30</span>, message = <span class="string">"字符串长度还要求20到30之间"</span>)</span><br><span class="line">    <span class="keyword">private</span> String size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>后台验证方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析验证参数错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vp —— 需要验证的 POJO，使用注解 <span class="doctag">@Valid</span> 表示验证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> errors —— 错误信息，它由 Spring MVC 通过验证 POJO 后自动填充</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/valid/validate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">validate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @Valid @RequestBody ValidatorPojo vp,</span></span></span><br><span class="line"><span class="function"><span class="params">    Errors errors)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; errMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取错误列表</span></span><br><span class="line">    List&lt;ObjectError&gt; oes = errors.getAllErrors();</span><br><span class="line">    <span class="keyword">for</span> (ObjectError oe : oes) &#123;</span><br><span class="line">        String key = <span class="keyword">null</span>;</span><br><span class="line">        String msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 字段错误</span></span><br><span class="line">        <span class="keyword">if</span> (oe <span class="keyword">instanceof</span> FieldError) &#123;</span><br><span class="line">            FieldError fe = (FieldError) oe;</span><br><span class="line">            key = fe.getField();        <span class="comment">// 获取错误验证字段名</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非字段错误</span></span><br><span class="line">            key = oe.getObjectName();   <span class="comment">// 获取验证对象名称</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 错误信息</span></span><br><span class="line">        msg = oe.getDefaultMessage();</span><br><span class="line">        errMap.put(key, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@ResponseBody</strong> 代表接收一个 JSON 参数，然后 <strong>@Valid</strong> 注解则表示启动验证机制，Spring 就会启用 JSR-303 验证机制进行验证，自动地将最后的验证结果放入 Errors 对象中；</p>
<h3 id="参数验证机制"><a href="#参数验证机制" class="headerlink" title="参数验证机制"></a>参数验证机制</h3><p><strong>验证接口定义</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判定当前验证器是否支持该 Class 类型的验证</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> clazz —— POJO 类型</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 当前验证器是否支持该 POJO 验证</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果 supports 返回 true，则这个方法执行验证逻辑</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target 被验证 POJO 对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> errors 错误对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>supports 方法参数为需要验证的 POJO 类型，如果该方法返回 true，则 Spring 会使用当前验证器的 validate 方法验证 POJO；</p>
<p>validate 方法包含需要的 target 对象和错误对象 errors，其中 target 是参数绑定后的 POJO，可以通过这个参数对象进行业务逻辑的自定义验证，如果发现错误，则保存到 errors 对象中，返回给控制器；</p>
<p><strong>自定义用户验证器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证只支持 User 类验证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clazz.equals(User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对象为空</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 直接在参数出报错，这样就不能进入控制器的方法</span></span><br><span class="line">            errors.rejectValue(<span class="string">""</span>, <span class="keyword">null</span>, <span class="string">"用户不能为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 强制转换</span></span><br><span class="line">        User user = (User) target;</span><br><span class="line">        <span class="comment">// 用户名非空串</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(user.getUserName())) &#123;</span><br><span class="line">            <span class="comment">// 增加错误，可以进入控制器方法</span></span><br><span class="line">            errors.rejectValue(<span class="string">"userName"</span>, <span class="keyword">null</span>, <span class="string">"用户名不能为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring MVC 中提供了一个注解 @InitBinder，他的作用是在执行控制器方法前，处理器会限制性被 @InitBinder 标注的方法。这是可以将 WebDataBinder 对象最为参数传递到方法中，得到 WebDataBinder 对象，该对象有 setValidator方法，可以绑定自定义的验证器，在获取参数后，通过自定义的验证器去验证参数。</p>
<h2 id="视图和视图解析器"><a href="#视图和视图解析器" class="headerlink" title="视图和视图解析器"></a>视图和视图解析器</h2><h3 id="视图设计"><a href="#视图设计" class="headerlink" title="视图设计"></a>视图设计</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 响应状态属性</span></span><br><span class="line">	String RESPONSE_STATUS_ATTRIBUTE = View.class.getName() + <span class="string">".responseStatus"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 路径变量</span></span><br><span class="line">	String PATH_VARIABLES = View.class.getName() + <span class="string">".pathVariables"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择内容类型</span></span><br><span class="line">	String SELECTED_CONTENT_TYPE = View.class.getName() + <span class="string">".selectedContentType"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 响应类型</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 渲染方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>getContentType 方法是获取 HTTP 响应类型，它可以返回的类型是文本，JSON 数据集或者文件等</li>
<li>render 方法则是将数据模型渲染到视图的，model 参数是数据类型，</li>
</ul>
<center>Spring MVC 常用视图关系模型</center>

<p><img src="/2019/05/11/SpringBoot学习笔记（Day08）/Spring MVC 常用视图关系模型.jpg" alt="Spring MVC 常用视图关系模型"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day07）</title>
    <url>/2019/05/09/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day07%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/09/SpringBoot学习笔记（Day07）/pat-kay-1380646-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>Photo by <a href="https://unsplash.com/photos/BuPgonMyK9E?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Pat Kay</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Spring-MVC-流程"><a href="#Spring-MVC-流程" class="headerlink" title="Spring MVC 流程"></a>Spring MVC 流程</h2><p>流程和组件是 Spring MVC 的核心，Spring MVC的流程是围绕 DispatcherServlet 而工作的，所以在 Spring MVC 中DispatcherServlet 就是其中最重要的内容；</p>
<center>Spring MVC 全流程</center>

<p><img src="/2019/05/09/SpringBoot学习笔记（Day07）/SpringMVC全流程.jpg" alt="插图"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入用户服务类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示用户详情</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/details"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">details</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">        User user = userService.getUser(id);</span><br><span class="line">        <span class="comment">// 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">// 定义模型视图</span></span><br><span class="line">        mv.setViewName(<span class="string">"user/details"</span>);</span><br><span class="line">        <span class="comment">// 加入数据模型</span></span><br><span class="line">        mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="comment">// 返回模型和视图</span></span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Controller 表示这是一个控制器，@RequestMapping 代表请求路径和控制器的映射关系，会在 Web 服务器启动 Spring MVC 时，就被扫描到 <strong>HandlerMapping</strong> 的机制中存储，之后在用户发起请求被 <strong>DispatcherServlet</strong> 拦截后，通过 URI 和其他条件，通过 <strong>HandlerMapping</strong> 机制就能找到对应的控制器进行响应。只是通过 <strong>HandlerMapping</strong> 返回的是一个 <strong>HandlerExecutionChain</strong> 对象；</p>
<p><strong>HandlerExecutionChain 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(HandlerExecutionChain.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截器数组</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截器列表</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截器当前下标</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> interceptorIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HandlerExecutionChain 对象包含一个处理器，这里处理器是对控制器的包装。处理器包含了控制器方法的逻辑，此外还有处理器的拦截器，这样就能够通过拦截器进一步地增强处理器的功能；</p>
<p>还需要一个适配器去运行 HandlerExecutionChain 对象包含的处理器，就是 HandlerAdapter 的实现类 HttpRequesHandlerAdapter，通过请求类型，DispatcherServlet 就会找到它来执行 Web 请求的 HandlerExecutionChain 对象包含的内容</p>
<p><strong>通过 application.properties 定制 InternalResourceViewResolver 初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.mvc.view.prefix=/WEB-INF/jsp/</span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></table></figure>
<p>通过修改配置文件，就能在 Spring Boot 的机制下定制 <strong>InternalResourceViewResolver </strong> 这个视图解析器的初始化</p>
<p><strong>（注：踩坑 —— 在项目编译的时候，springboot 好像没有支持 jsp，要手动在 pom.xml 里面添加以下内容）</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">![实例在SpringMVC下的流程图](D:\Blog\myblog\source\_posts\SpringBoot学习笔记（Day07）\实例在SpringMVC下的流程图.jpg)<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<center>实例在 Spring MVC 下的流程图</center>

<p><img src="/2019/05/09/SpringBoot学习笔记（Day07）/实例在SpringMVC下的流程图.jpg" alt="实例在SpringMVC下的流程图"></p>
<p><strong>使用 JSON 视图</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/detailsForJson"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">detailsForJson</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问模型层得到数据</span></span><br><span class="line">    User user = userService.getUser(id);</span><br><span class="line">    <span class="comment">// 模型和视图</span></span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">// 生成 JSON 视图</span></span><br><span class="line">    MappingJackson2JsonView jsonView = <span class="keyword">new</span> MappingJackson2JsonView();</span><br><span class="line">    mv.setView(jsonView);</span><br><span class="line">    <span class="comment">// 加入模型</span></span><br><span class="line">    mv.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center>在 Spring MVC 流程中使用 JSON 视图</center>

<p><img src="/2019/05/09/SpringBoot学习笔记（Day07）/在SpringMVC流程中使用JSON视图.jpg" alt="在SpringMVC流程中使用JSON视图"></p>
<h2 id="定制-Spring-MVC-初始化"><a href="#定制-Spring-MVC-初始化" class="headerlink" title="定制 Spring MVC 初始化"></a>定制 Spring MVC 初始化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 异步请求超时时间</span><br><span class="line">spring.mvc.async.request-timeout=</span><br><span class="line"># 是否使用请求参数（默认参数为 &quot;format&quot;）来确定请求的媒体类型</span><br><span class="line">spring.mvc.contentnegotiation.favor-parameter=false</span><br><span class="line"># 是否使用 URL 中的路径扩展来确定请求的媒体类型</span><br><span class="line">spring.mvc.contentnegotiation.favor-path-extension=false</span><br><span class="line"># 设置内容协商向媒体类型映射文件扩展名，例如，YML文本 / YAML</span><br><span class="line">spring.mvc.contentnegotiation.media-types.*=</span><br><span class="line"># 当启用 favor-parameter 参数时，自定义参数名</span><br><span class="line">spring.mvc.contentnegotiation.parameter-name=</span><br><span class="line"># 日期格式配置，入 yyyy-MM-dd</span><br><span class="line">spring.mvc.date-format=</span><br><span class="line"># 是否让 FrameworkServlet doService 方法支持 TRACE 请求</span><br><span class="line">spring.mvc.dispatch-trace-request=false</span><br><span class="line"># 是否启用 FrameworkServlet doService 方法支持 OPTIONS 请求</span><br><span class="line">spring.mvc.dispatch-options-request=true</span><br><span class="line"># spring MVC 的图标是否启用</span><br><span class="line">spring.mvc.favicon.enabled=true</span><br><span class="line"># Servlet 规范要求表格数据可用于 HTTP POST 而不是 HTTP PUT 或 PATCH 请求，这个选项将使得过滤器拦截 HTTP PUT 和 PATCH，且内容类型是 application/x-www-form-urlencoded 的请求，并且将其转换为 POST 请求</span><br><span class="line">spring.mvc.formcontent.filter.enabled=true</span><br><span class="line"># 如果配置为 default，那么他将忽略模型重定向的场景</span><br><span class="line">spring.mvc.ignore-default-model-on-redirect=true</span><br><span class="line"># 默认国际化选项，默认取 Accept-Language</span><br><span class="line">spring.mvc.locale=</span><br><span class="line"># 国际化解析器，如果需要固定可以使用 fixed</span><br><span class="line">spring.mvc.locale-resolver=accept_header</span><br><span class="line"># 是否启用警告日志异常解决</span><br><span class="line">spring.mvc.log-resolved-exception=false</span><br><span class="line"># 消息代码的格式化策略。例如 &apos; prefix_error_code &apos;</span><br><span class="line">spring.mvc.message-codes-resolver-format=</span><br><span class="line"># 是否对 spring.mvc.contentnegotiation.media-types.* 注册的扩展采用后缀模式匹配</span><br><span class="line">spring.mvc.pathmatch.use-registered-suffix-pattern=false</span><br><span class="line"># 当匹配模式到请求时，是否使用后缀模式匹配（.*）</span><br><span class="line">spring.mvc.pathmatch.use-suffix-pattern=false</span><br><span class="line"># 启用 Spring Web 服务 Servlet 的优先顺序配置</span><br><span class="line">spring.mvc.servlet.load-on-startup=-1</span><br><span class="line"># 指定静态资源路径</span><br><span class="line">spring.mvc.static-path-pattern=/**</span><br><span class="line"># 如果请求找不到处理器，是否抛出 NoHandlerFoundException 异常</span><br><span class="line">spring.mvc.throw-exception-if-no-handler-found=false</span><br><span class="line"></span><br><span class="line">spring.mvc.view.prefix=</span><br><span class="line">spring.mvc.view.suffix=</span><br></pre></td></tr></table></figure>
<p>这些配置项将会被 Spring Boot 的机制读入，然后使用 WebMVCAutoConfigurationAdapter 去定制初始化</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day06）</title>
    <url>/2019/05/08/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day06%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/08/SpringBoot学习笔记（Day06）/marion-michele-1464753-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>Photo by <a href="https://unsplash.com/photos/TaINhZO6diw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Marion Michele</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Redis-的一些特殊用法"><a href="#Redis-的一些特殊用法" class="headerlink" title="Redis 的一些特殊用法"></a>Redis 的一些特殊用法</h2><h3 id="使用-Redis-事务"><a href="#使用-Redis-事务" class="headerlink" title="使用 Redis 事务"></a>使用 Redis 事务</h3><p>watch 命令：监控 Redis 的一些键；</p>
<p>multi 命令：是开始事务，开始事务后，该客户端的命令不会马上执行，而是存放在一个队列里面；</p>
<p>exec 命令：执行事务，在队列命令执行前会判断被 watch 监控的 Redis 键的数据是否发生过变化，如果发生变化，Redis 就会取消事务；</p>
<center>Redis 事务执行过程</center>

<p><img src="/2019/05/08/SpringBoot学习笔记（Day06）/Redis事务执行过程.jpg" alt="插图"></p>
<p><strong>通过 Spring 使用 Redis 事务机制</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/multi"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">testMulti</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	redisTemplate.opsForValue().set(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">	List list = (List) redisTemplate.execute(<span class="keyword">new</span> SessionCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            <span class="comment">// 设置要监控key1</span></span><br><span class="line">            operations.watch(<span class="string">"key1"</span>);</span><br><span class="line">            <span class="comment">// 开启事务，在exec命令执行前，全部都只是进入队列</span></span><br><span class="line">            operations.multi();</span><br><span class="line">            operations.opsForValue().set(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">            <span class="comment">// operations.opsForValue().increment("key1", 1);// ①</span></span><br><span class="line">            <span class="comment">// 获取值将为null，因为redis只是把命令放入队列，</span></span><br><span class="line">            Object value2 = operations.opsForValue().get(<span class="string">"key2"</span>);</span><br><span class="line">            System.out.println(<span class="string">"命令在队列，所以value为null【"</span> + value2 + <span class="string">"】"</span>);</span><br><span class="line">            operations.opsForValue().set(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">            Object value3 = operations.opsForValue().get(<span class="string">"key3"</span>);</span><br><span class="line">            System.out.println(<span class="string">"命令在队列，所以value为null【"</span> + value3 + <span class="string">"】"</span>);</span><br><span class="line">            <span class="comment">// 执行exec命令，将先判别key1是否在监控后被修改过，如果是不执行事务，否则执行事务</span></span><br><span class="line">            <span class="keyword">return</span> operations.exec();<span class="comment">// ②</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"success"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Redis 处理事务和数据库事务不同，Redis 事务先让命令进入已有队列，所以一开始并没有检测错误命令是否能执行成功，只有在 <strong>exec</strong> 命令执行的时候，才能发现错误，对于出错的命令 Redis 只是报出错误，而错误后面的命令依旧被执行，这就是 Redis 事务的特点，也是使用 Redis 事务需要特别注意的地方；</p>
<h3 id="使用-Redis-流水线"><a href="#使用-Redis-流水线" class="headerlink" title="使用 Redis 流水线"></a>使用 Redis 流水线</h3><p>一次性发送多条执行命令</p>
<p><strong>使用 Redis 流水线测试性能</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/multi"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">testMulti</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long start = System.currentTimeMillis();</span><br><span class="line">    List list = (List) redisTemplate.execute(<span class="keyword">new</span> SessionCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                operations.opsForValue().set(<span class="string">"pipeline_"</span> + i, <span class="string">"value_"</span> + i);</span><br><span class="line">                String value = (String) operations.opsForValue().get(<span class="string">"pipeline_"</span> + i);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">100000</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"命令只是进入队列，所以值为空【"</span> + value + <span class="string">"】"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Long end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"耗时："</span> + (end - start) + <span class="string">"毫秒。"</span>);</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"success"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-Redis-发布订阅"><a href="#使用-Redis-发布订阅" class="headerlink" title="使用 Redis 发布订阅"></a>使用 Redis 发布订阅</h3><p>发布订阅是消息的一种常用模式，Redis 先提供一个渠道，让消息能够发送到这个渠道上，多个系统可以监听这个渠道，当一条消息发送到渠道，渠道就会通知它的监听者，这些监听者就会根据自己的需要去处理这个消息</p>
<center>发布订阅模式</center>

<p><img src="/2019/05/08/SpringBoot学习笔记（Day06）/发布订阅模式.jpg" alt="插图"></p>
<p><strong>Redis 消息监听器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * onMessage 方法是得到消息后的处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 代表 Redis 发送过来的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern 渠道名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 消息体</span></span><br><span class="line">        String body = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        <span class="comment">// 渠道名称</span></span><br><span class="line">        String topic = <span class="keyword">new</span> String(pattern);</span><br><span class="line">        System.out.println(body);</span><br><span class="line">        System.out.println(topic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-Spring-缓存注解操作-Redis"><a href="#使用-Spring-缓存注解操作-Redis" class="headerlink" title="使用 Spring 缓存注解操作 Redis"></a>使用 Spring 缓存注解操作 Redis</h2><h3 id="缓存管理器和缓存的启用"><a href="#缓存管理器和缓存的启用" class="headerlink" title="缓存管理器和缓存的启用"></a>缓存管理器和缓存的启用</h3><p><strong>缓存管理器配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># SPRING CACHE (CacheProperties)</span><br><span class="line"># 如果由底层的缓存管理器支持创建，以逗号分隔的列表来缓存名称</span><br><span class="line">spring.cache.cache-names=</span><br><span class="line"># caffeine 缓存配置细节</span><br><span class="line">spring.cache.caffeine.spec=</span><br><span class="line"># couchbase 缓存超时时间，默认是永不超时</span><br><span class="line">spring.cache.couchbase.expiration=0ms</span><br><span class="line"># 配置 ehcache 缓存初始化文件路径</span><br><span class="line">spring.cache.infinispan.config=</span><br><span class="line"># jcache 缓存配置文件</span><br><span class="line">spring.cache.jcache.config=</span><br><span class="line"># jcache 缓存提供者配置</span><br><span class="line">spring.cache.jcache.provider=</span><br><span class="line"># 是否允许 Redis 缓存空值</span><br><span class="line">spring.cache.redis.cache-null-values=true</span><br><span class="line"># Redis 的键前缀</span><br><span class="line">spring.cache.redis.key-prefix=</span><br><span class="line"># 缓存超时时间戳，配置为0则不设置超时时间</span><br><span class="line">spring.cache.redis.time-to-live=0ms</span><br><span class="line"># 是否启用 Redis 的键前缀</span><br><span class="line">spring.cache.redis.use-key-prefix=true</span><br><span class="line"># 缓存类型，在默认的情况下，Spring 会自动根据上下文探测</span><br><span class="line">spring.cache.type=</span><br></pre></td></tr></table></figure>
<p><strong>用户实现类使用 Spring 缓存注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Cacheable</span>(value = <span class="string">"redisCache"</span>, key = <span class="string">"'redis_user_' + #id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@CachePut</span>(value = <span class="string">"redisCache"</span>, key = <span class="string">"'redis_user_' + #result.id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">insertUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userDao.insertUser(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@CachePut</span>(value = <span class="string">"redisCache"</span>, condition = <span class="string">"#result != 'null'"</span>, key = <span class="string">"'redis_user_' + #id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUserName</span><span class="params">(Long id, String userName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处调用 getUser 方法，该方法缓存注解失效</span></span><br><span class="line">        <span class="comment">// 所以这里还会执行 SQL，将查询到数据库最近数据</span></span><br><span class="line">        User user = <span class="keyword">this</span>.getUser(id);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        user.setUserName(userName);</span><br><span class="line">        userDao.updateUser(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findUsers(userName, note);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@CacheEvict</span>(value = <span class="string">"redisCache"</span>, key = <span class="string">"'redis_user_' + #id"</span>, beforeInvocation = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.deleteUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@CachePut 表示将方法结果返回存放到缓存中</li>
<li>@Cacheable 表示先从缓存中通过定义的键查询，如果可以查询到数据，则返回，否则执行方法，返回数据，并且将返回结果保存到缓存中</li>
<li>@CacheEvict 通过定义的键移除缓存，它有一个 Boolean 类型的配置项 beforeInvocation，表示在方法之前或者之后移除缓存，false代表方法之后将缓存移除</li>
</ul>
<h3 id="自定义缓存管理器"><a href="#自定义缓存管理器" class="headerlink" title="自定义缓存管理器"></a>自定义缓存管理器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 禁用前缀</span><br><span class="line">spring.cache.redis.use-key-prefix=false</span><br><span class="line"># 允许保存空值</span><br><span class="line"># spring.cache.redis.cache-null-values=true</span><br><span class="line"># 自定义前缀</span><br><span class="line"># spring.cache.redis.key-prefix=</span><br><span class="line"># 定义超时时间，单位毫秒</span><br><span class="line">spring.cache.redis.time-to-live=600000</span><br></pre></td></tr></table></figure>
<p><strong>自定义缓存管理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisConnectionFactory connectionFactory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"redisCacheManager"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">initRedisCacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Redis 加锁的写入器</span></span><br><span class="line">    RedisCacheWriter writer = RedisCacheWriter.lockingRedisCacheWriter(connectionFactory);</span><br><span class="line">    <span class="comment">// 启动 Redis 序列化器</span></span><br><span class="line">    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">    <span class="comment">// 设置 JDK 序列化器</span></span><br><span class="line">    config = config.serializerValuesWith(SerializationPair.fromSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer()));</span><br><span class="line">    <span class="comment">// 禁用前缀</span></span><br><span class="line">    config = config.disableKeyProfix();</span><br><span class="line">    <span class="comment">// 设置 10min 超时</span></span><br><span class="line">    config = config.entryTtl(Duration.ofMinutes(<span class="number">10</span>));</span><br><span class="line">    <span class="comment">// 创建缓存 Redis 管理器</span></span><br><span class="line">    RedisCacheManager redisCacheManager = <span class="keyword">new</span> RedisCacheManager(writer, config);</span><br><span class="line">    <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先注入 RedisConnectionFactory 对象；</li>
<li>创建带锁的 RedisCacheWriter；</li>
<li>使用 RedisCacheConfiguration 对 RedisCacheWriter 属性进行配置（禁用前缀，设置超时时间为 10min）；</li>
<li>用 RedisCacheWriter 对象和 RedisCacheConfiguration 对象构建 RedisCacheManager 对象；</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day05）</title>
    <url>/2019/05/07/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day05%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/07/SpringBoot学习笔记（Day05）/ruud-luijten-1551202-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>Photo by <a href="https://unsplash.com/photos/zFvZ1r7YjGc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Ruud Luijten</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="spring-data-redis-项目介绍"><a href="#spring-data-redis-项目介绍" class="headerlink" title="spring-data-redis 项目介绍"></a>spring-data-redis 项目介绍</h2><h3 id="spring-data-redis-项目设计"><a href="#spring-data-redis-项目设计" class="headerlink" title="spring-data-redis 项目设计"></a>spring-data-redis 项目设计</h3><p>Spring 提供了一个 RedisConnectionFactory 接口，通过它可以生成一个 RedisConnection 接口对象，而 RedisConnection 是 Redis 底层接口的封装，如使用 Jedis，Spring 就会提供 RedisConnection 接口的实现类 JedisConnection 去封装原有的 Jedis；</p>
<p><img src="/2019/05/07/SpringBoot学习笔记（Day05）/RedisConnection关系图.jpg" alt="RedisConnection关系图"></p>
<h3 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h3><p>RedisTemplate 是一个强大的类，首先他会自动从 RedisConnectionFactory 工厂中获取连接，执行对应的 Redis 命令，在最后还会关闭 Redis 的连接；</p>
<h3 id="Spring-序列化器"><a href="#Spring-序列化器" class="headerlink" title="Spring 序列化器"></a>Spring 序列化器</h3><p>Spring 序列化器用于转储 Java 对象到 Redis 中，因为 Redis 是一种基于字符串存储的 NoSQL，对象无法存储到 Redis 中，只有通过序列化器转换为二进制字符串才能存储</p>
<p><img src="/2019/05/07/SpringBoot学习笔记（Day05）/Spring序列化器.jpg" alt="RedisConnection关系图"></p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">defaultSerializer</td>
<td style="text-align:left">默认序列化器</td>
<td style="text-align:left">如果没有配置，则使用 JdkSerializationRedisSerializer</td>
</tr>
<tr>
<td style="text-align:left">keySerializer</td>
<td style="text-align:left">Redis 键序列化器</td>
<td style="text-align:left">如果没有配置，则使用默认序列化器</td>
</tr>
<tr>
<td style="text-align:left">valueSerializer</td>
<td style="text-align:left">Redis 值序列化器</td>
<td style="text-align:left">如果没有配置，则使用默认序列化器</td>
</tr>
<tr>
<td style="text-align:left">hashKeySerializer</td>
<td style="text-align:left">Redis 散列结构 field 序列化器</td>
<td style="text-align:left">如果没有配置，则使用默认序列化器</td>
</tr>
<tr>
<td style="text-align:left">hashValueSerializer</td>
<td style="text-align:left">Redis 散列结构 value 序列化器</td>
<td style="text-align:left">如果没有配置，则使用默认序列化器</td>
</tr>
<tr>
<td style="text-align:left">stringSerializer</td>
<td style="text-align:left">字符串序列化器</td>
<td style="text-align:left">RedisTemplate 自动赋值为 StringRedisSerializer 对象</td>
</tr>
</tbody>
</table>
<h3 id="Spring-对-Redis-数据类型操作的封装"><a href="#Spring-对-Redis-数据类型操作的封装" class="headerlink" title="Spring 对 Redis 数据类型操作的封装"></a>Spring 对 Redis 数据类型操作的封装</h3><center>spring-data-redis 数据类型封装操作接口</center>

<table>
<thead>
<tr>
<th style="text-align:left">操作接口</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GeoOperations</td>
<td>地理位置操作接口</td>
<td>使用不多</td>
</tr>
<tr>
<td style="text-align:left">HashOperations</td>
<td>散列操作接口</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">HyperLogLogOperations</td>
<td>基数操作接口</td>
<td>使用不多</td>
</tr>
<tr>
<td style="text-align:left">ListOperations</td>
<td>列表（链表）操作接口</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">SetOperations</td>
<td>集合操作接口</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">ValueOperations</td>
<td>字符串操作接口</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">ZSetOperations</td>
<td>有序集合操作接口</td>
</tr>
</tbody>
</table>
<p>都可以通过 RedisTemplate 得到，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取地理位置操作接口</span></span><br><span class="line">redisTemplate.opsForGeo();</span><br><span class="line"><span class="comment">// 获取散列操作接口</span></span><br><span class="line">redisTemplate.opsForHash();</span><br><span class="line"><span class="comment">// 获取基数操作接口</span></span><br><span class="line">redisTemplate.opsForHyperLogLog();</span><br><span class="line"><span class="comment">// 获取列表操作接口</span></span><br><span class="line">redisTemplate.opsForList();</span><br><span class="line"><span class="comment">// 获取集合操作接口</span></span><br><span class="line">redisTemplate.opsForSet();</span><br><span class="line"><span class="comment">// 获取字符串操作接口</span></span><br><span class="line">redisTemplate.opsForValue();</span><br><span class="line"><span class="comment">// 获取有序集合操作接口</span></span><br><span class="line">redisTemplate.opsForZSet();</span><br></pre></td></tr></table></figure>
<p>有事需要连续操作一个散列数据类型或者列表多次，这时 Spring 也提供支持，它提供了对应的 BoundXXXOperation 绑定接口：</p>
<table>
<thead>
<tr>
<th>接    口</th>
<th>说    明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BoundGeoOperations</td>
<td>绑定一个地理位置数据类型的键操作，不常用</td>
</tr>
<tr>
<td>BoundHashOperations</td>
<td>绑定一个散列数据类型的键操作</td>
</tr>
<tr>
<td>BoundListOperations</td>
<td>绑定一个列表（链表）数据类型的键操作</td>
</tr>
<tr>
<td>BoundSetOperations</td>
<td>绑定一个集合数据类型的键操作</td>
</tr>
<tr>
<td>BoundValueOperations</td>
<td>绑定一个字符串集合数据类型的键操作</td>
</tr>
<tr>
<td>BoundZSetOperations</td>
<td>绑定一个有序集合数据类型的键操作</td>
</tr>
</tbody>
</table>
<p>RedisTemplate 对获取它们提供了对应的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取地理位置绑定键操作接口</span></span><br><span class="line">redisTemplate.boundGeoOps();</span><br><span class="line"><span class="comment">// 获取散列绑定键操作接口</span></span><br><span class="line">redisTemplate.boundHashOps();</span><br><span class="line"><span class="comment">// 获取列表（链表）绑定键操作接口</span></span><br><span class="line">redisTemplate.boundListOps();</span><br><span class="line"><span class="comment">// 获取集合绑定键操作接口</span></span><br><span class="line">redisTemplate.boundSetOps();</span><br><span class="line"><span class="comment">// 获取字符串绑定键操作接口</span></span><br><span class="line">redisTemplate.boundValueOps();</span><br><span class="line"><span class="comment">// 获取有序集合绑定键操作接口</span></span><br><span class="line">redisTemplate.boundZSetOps();</span><br></pre></td></tr></table></figure>
<h3 id="SessionCallback-和-RedisCallback-接口"><a href="#SessionCallback-和-RedisCallback-接口" class="headerlink" title="SessionCallback 和 RedisCallback 接口"></a>SessionCallback 和 RedisCallback 接口</h3><p>作用是让 RedisTemplate 进行回调，通过它们可以在同一条连接下执行多个 Redis 命令；</p>
<h2 id="在-Spring-Boot-中配置和使用-Redis"><a href="#在-Spring-Boot-中配置和使用-Redis" class="headerlink" title="在 Spring Boot 中配置和使用 Redis"></a>在 Spring Boot 中配置和使用 Redis</h2><h3 id="在-Spring-Boot-中配置-Redis"><a href="#在-Spring-Boot-中配置-Redis" class="headerlink" title="在 Spring Boot 中配置 Redis"></a>在 Spring Boot 中配置 Redis</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置连接池属性</span><br><span class="line">spring.redis.jedis.pool.min-idle=5</span><br><span class="line">spring.redis.jedis.pool.max-active=10</span><br><span class="line">spring.redis.jedis.pool.max-idle=10</span><br><span class="line">spring.redis.jedis.pool.max-wait=2000</span><br><span class="line"># 配置 Redis 服务器属性</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">spring.redis.host=192.168.11.154</span><br><span class="line"># 由于我的 Redis 服务器没有设置密码就没下下面的配置了</span><br><span class="line"># spring.redis.password</span><br><span class="line"># Redis 连接超时时间，单位毫秒</span><br><span class="line">spring.redis.timeout=1000</span><br></pre></td></tr></table></figure>
<p><strong>操作 Redis 字符串和散列数据类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redis"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/stringAndHash"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">testStringAndHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"int_key"</span>, <span class="string">"1"</span>);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">"int"</span>, <span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">// 使用运算</span></span><br><span class="line">        stringRedisTemplate.opsForValue().increment(<span class="string">"int"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取底层 Jedis 连接</span></span><br><span class="line">        Jedis jedis = (Jedis) stringRedisTemplate.getConnectionFactory().getConnection().getNativeConnection();</span><br><span class="line">        <span class="comment">// 减1操作，这个命令 RedisTemplate 不支持，所以先获取底层连接再操作</span></span><br><span class="line">        jedis.decr(<span class="string">"int"</span>);</span><br><span class="line">        Map&lt;String, String&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hash.put(<span class="string">"field1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        hash.put(<span class="string">"field2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        <span class="comment">// 存入一个散列数据类型</span></span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(<span class="string">"hash"</span>, hash);</span><br><span class="line">        <span class="comment">// 新增一个字段</span></span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">"hash"</span>, <span class="string">"field3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">        <span class="comment">// 绑定散列操作的key，这样可以连续对同一个散列数据类型进行操作</span></span><br><span class="line">        BoundHashOperations hashOps = stringRedisTemplate.boundHashOps(<span class="string">"hash"</span>);</span><br><span class="line">        <span class="comment">// 删除两个字段</span></span><br><span class="line">        hashOps.delete(<span class="string">"field1"</span>, <span class="string">"field2"</span>);</span><br><span class="line">        <span class="comment">// 新增一个字段</span></span><br><span class="line">        hashOps.put(<span class="string">"field5"</span>, <span class="string">"value5"</span>);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"success"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 Spring 操作列表（链表）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redis"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">testList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入两个列表，注意它们在链表的顺序</span></span><br><span class="line">        <span class="comment">// 链表从左到右顺序为v10，v8，v6，v4，v2</span></span><br><span class="line">        stringRedisTemplate.opsForList().leftPushAll(</span><br><span class="line">                <span class="string">"list1"</span>, <span class="string">"v2"</span>, <span class="string">"v4"</span>, <span class="string">"v6"</span>, <span class="string">"v8"</span>, <span class="string">"v10"</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 链表从左到右顺序为v1, v2, v3, v4, v5, v6</span></span><br><span class="line">        stringRedisTemplate.opsForList().rightPushAll(</span><br><span class="line">                <span class="string">"list2"</span>, <span class="string">"v1"</span>, <span class="string">"v2"</span>, <span class="string">"v3"</span>, <span class="string">"v4"</span>, <span class="string">"v5"</span>, <span class="string">"v6"</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 绑定 list2 链表操作</span></span><br><span class="line">        BoundListOperations listOps = stringRedisTemplate.boundListOps(<span class="string">"list2"</span>);</span><br><span class="line">        <span class="comment">// 从右边弹出一个成员</span></span><br><span class="line">        Object result1 = listOps.rightPop();</span><br><span class="line">        <span class="comment">// 获取定位元素，Redis 从 0 开始计算，这里值为 v2</span></span><br><span class="line">        Object result2 = listOps.index(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 从左边插入链表</span></span><br><span class="line">        listOps.leftPush(<span class="string">"v0"</span>);</span><br><span class="line">        <span class="comment">// 求链表长度</span></span><br><span class="line">        Long size = listOps.size();</span><br><span class="line">        <span class="comment">// 求链表下标区间成员，整个链表下标范围为 0 到 size-1，这里不取最后一个元素</span></span><br><span class="line">        List elements = listOps.range(<span class="number">0</span>, size - <span class="number">2</span>);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"success"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 Spring 集合</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redis"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/set"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">testSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 请注意：这里 v1 重复两次，因为集合不允许重复，所以只是插入 5 个成员到集合中</span></span><br><span class="line">        stringRedisTemplate.opsForSet().add(</span><br><span class="line">                <span class="string">"set1"</span>, <span class="string">"v1"</span>, <span class="string">"v1"</span>, <span class="string">"v2"</span>, <span class="string">"v3"</span>, <span class="string">"v4"</span>, <span class="string">"v5"</span></span><br><span class="line">        );</span><br><span class="line">        stringRedisTemplate.opsForSet().add(</span><br><span class="line">                <span class="string">"set2"</span>, <span class="string">"v2"</span>, <span class="string">"v4"</span>, <span class="string">"v6"</span>, <span class="string">"v8"</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 绑定 set1 集合操作</span></span><br><span class="line">        BoundSetOperations setOps = stringRedisTemplate.boundSetOps(<span class="string">"set1"</span>);</span><br><span class="line">        <span class="comment">// 增加两个元素</span></span><br><span class="line">        setOps.add(<span class="string">"v6"</span>, <span class="string">"v7"</span>);</span><br><span class="line">        <span class="comment">// 删除两个元素</span></span><br><span class="line">        setOps.remove(<span class="string">"v1"</span>, <span class="string">"v7"</span>);</span><br><span class="line">        <span class="comment">// 返回所有元素</span></span><br><span class="line">        Set set1 = setOps.members();</span><br><span class="line">        <span class="comment">// 求成员数</span></span><br><span class="line">        Long size = setOps.size();</span><br><span class="line">        <span class="comment">// 求交集</span></span><br><span class="line">        Set inter = setOps.intersect(<span class="string">"set2"</span>);</span><br><span class="line">        <span class="comment">// 求交集，并且用新集合 inter 保存</span></span><br><span class="line">        setOps.intersectAndStore(<span class="string">"set2"</span>, <span class="string">"inter"</span>);</span><br><span class="line">        <span class="comment">// 求差集</span></span><br><span class="line">        Set diff = setOps.diff(<span class="string">"set2"</span>);</span><br><span class="line">        <span class="comment">// 求差集，并且用新集合 diff 保存</span></span><br><span class="line">        setOps.diffAndStore(<span class="string">"set2"</span>, <span class="string">"diff"</span>);</span><br><span class="line">        <span class="comment">// 求并集</span></span><br><span class="line">        Set union = setOps.union(<span class="string">"set2"</span>);</span><br><span class="line">        <span class="comment">// 求并集，并且用新集合 union 保存</span></span><br><span class="line">        setOps.unionAndStore(<span class="string">"set2"</span>, <span class="string">"union"</span>);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"success"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>操作 Redis 有序集合</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redis"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/zset"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">testZSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTupleSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 分数</span></span><br><span class="line">            <span class="keyword">double</span> score = i * <span class="number">0.1</span>;</span><br><span class="line">            <span class="comment">// 创建一个 TypeTuple 对象，存入值和分数</span></span><br><span class="line">            ZSetOperations.TypedTuple&lt;String&gt; typedTuple = <span class="keyword">new</span> DefaultTypedTuple&lt;&gt;(<span class="string">"value"</span> + i, score);</span><br><span class="line">            typedTupleSet.add(typedTuple);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往有序集合插入元素</span></span><br><span class="line">        stringRedisTemplate.opsForZSet().add(<span class="string">"zset1"</span>, typedTupleSet);</span><br><span class="line">        <span class="comment">// 绑定 zset1 有序集合操作</span></span><br><span class="line">        BoundZSetOperations&lt;String, String&gt; zsetOps = stringRedisTemplate.boundZSetOps(<span class="string">"zset1"</span>);</span><br><span class="line">        <span class="comment">// 增加一个元素</span></span><br><span class="line">        zsetOps.add(<span class="string">"value10"</span>, <span class="number">0.26</span>);</span><br><span class="line">        Set&lt;String&gt; setRange = zsetOps.range(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 按分数排序获取有序集合</span></span><br><span class="line">        Set&lt;String&gt; setScore = zsetOps.rangeByScore(<span class="number">0.2</span>, <span class="number">0.6</span>);</span><br><span class="line">        <span class="comment">// 定义值范围</span></span><br><span class="line">        Range range = <span class="keyword">new</span> Range();</span><br><span class="line">        range.gt(<span class="string">"value3"</span>);</span><br><span class="line">        range.lte(<span class="string">"value8"</span>);</span><br><span class="line">        <span class="comment">// 按值排序，请注意这个排序是按字符串排序</span></span><br><span class="line">        Set&lt;String&gt;  setLex = zsetOps.rangeByLex(range);</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        zsetOps.remove(<span class="string">"value9"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        <span class="comment">// 求分数</span></span><br><span class="line">        Double score = zsetOps.score(<span class="string">"value8"</span>);</span><br><span class="line">        <span class="comment">// 在下标区间下，按分数排序，同时返回 value 和 score</span></span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; rangeSet = zsetOps.rangeWithScores(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 在分数区间下，按分数排序，同时返回 value 和 score</span></span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; scoreSet = zsetOps.rangeByScoreWithScores(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 按从大到小排序</span></span><br><span class="line">        Set&lt;String&gt; reverseSet = zsetOps.reverseRange(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"success"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记（Day06）</title>
    <url>/2019/05/06/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day06%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/06/Redis学习笔记（Day06）/sid-verma-1387706-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>Photo by <a href="https://unsplash.com/photos/Xvlc79bu9MA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Sid Verma</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>所需 jar 包：</p>
<ul>
<li>commons-pool</li>
<li>jedis</li>
</ul>
<h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.11.154"</span>, <span class="number">6379</span>);</span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不是在 Linux 上直接运行代码，而是在 Windows 上远程连接，就会报错，解决方案：</p>
<ol>
<li>注释配置文件的 bind 127.0.0.1</li>
<li>将保护模式后面的 yea 改为 no</li>
</ol>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># JUST COMMENT THE FOLLOWING LINE.</span><br><span class="line"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"># 把这里的 bind 注释掉</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># Protected mode is a layer of security protection, in order to avoid that</span><br><span class="line"># Redis instances left open on the internet are accessed and exploited.</span><br><span class="line">#</span><br><span class="line"># When protected mode is on and if:</span><br><span class="line">#</span><br><span class="line"># 1) The server is not binding explicitly to a set of addresses using the</span><br><span class="line">#    &quot;bind&quot; directive.</span><br><span class="line"># 2) No password is configured.</span><br><span class="line">#</span><br><span class="line"># The server only accepts connections from clients connecting from the</span><br><span class="line"># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span><br><span class="line"># sockets.</span><br><span class="line">#</span><br><span class="line"># By default protected mode is enabled. You should disable it only if</span><br><span class="line"># you are sure you want clients from other hosts to connect to Redis</span><br><span class="line"># even if no authentication is configured, nor a specific set of interfaces</span><br><span class="line"># are explicitly listed using the &quot;bind&quot; directive.</span><br><span class="line"># 把保护模式关掉或者添加密码 测试的话直接关掉 省得麻烦</span><br><span class="line">protected-mode no</span><br></pre></td></tr></table></figure>
<h3 id="Jedis-操作数据"><a href="#Jedis-操作数据" class="headerlink" title="Jedis  操作数据"></a>Jedis  操作数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.11.154"</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.set(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">        jedis.set(<span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line">        jedis.set(<span class="string">"k3"</span>, <span class="string">"v3"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(jedis.get(<span class="string">"k1"</span>));</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; sets = jedis.keys(<span class="string">"*"</span>);</span><br><span class="line">        System.out.println(sets.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Jedis-事务"><a href="#Jedis-事务" class="headerlink" title="Jedis 事务"></a>Jedis 事务</h3><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTX</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.11.154"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        Transaction transaction = jedis.multi();</span><br><span class="line">        transaction.set(<span class="string">"k44"</span>, <span class="string">"v44"</span>);</span><br><span class="line">        transaction.set(<span class="string">"k55"</span>, <span class="string">"v55"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// transaction.exec();</span></span><br><span class="line">        transaction.discard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事务案例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTX</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.11.154"</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">int</span> balance;    <span class="comment">// 可用余额</span></span><br><span class="line">        <span class="keyword">int</span> debt;       <span class="comment">// 欠额</span></span><br><span class="line">        <span class="keyword">int</span> amtToSubtract = <span class="number">10</span>;  <span class="comment">// 实刷额度</span></span><br><span class="line"></span><br><span class="line">        jedis.watch(<span class="string">"balance"</span>);</span><br><span class="line">        balance = Integer.parseInt(jedis.get(<span class="string">"balance"</span>));</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; amtToSubtract) &#123;</span><br><span class="line">            jedis.unwatch();</span><br><span class="line">            System.out.println(<span class="string">"modify"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"*******************transaction"</span>);</span><br><span class="line">            Transaction transaction = jedis.multi();</span><br><span class="line">            transaction.decrBy(<span class="string">"balance"</span>, amtToSubtract);</span><br><span class="line">            transaction.incrBy(<span class="string">"debt"</span>, amtToSubtract);</span><br><span class="line">            transaction.exec();</span><br><span class="line">            balance = Integer.parseInt(jedis.get(<span class="string">"balance"</span>));</span><br><span class="line">            debt = Integer.parseInt(jedis.get(<span class="string">"debt"</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"*************"</span> + balance);</span><br><span class="line">            System.out.println(<span class="string">"*************"</span> + debt);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * watch 命令就是标记一个键，如果标记了一个键</span></span><br><span class="line"><span class="comment">     * 在提交事务前，如果别比人修改过，那事务就会失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestTX testTX = <span class="keyword">new</span> TestTX();</span><br><span class="line">        <span class="keyword">boolean</span> retValue = testTX.transMethod();</span><br><span class="line">        System.out.println(<span class="string">"main retValue ----------- : "</span> + retValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JedisPool"><a href="#JedisPool" class="headerlink" title="JedisPool"></a>JedisPool</h3><ul>
<li>获取 Jedis 实例需要从 JedisPool 中获取</li>
<li>用完 Jedis 实例需要返还给 JedisPool</li>
<li>如果 Jedis 在使用过程中出错，则也需要还给 JedisPool</li>
</ul>
<p>演示代码：</p>
<p>JedisPoolUtil.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JedisPoolUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPoolInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedisPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">                    JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">                    poolConfig.setMaxActive(<span class="number">1000</span>);</span><br><span class="line">                    poolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">                    poolConfig.setMaxWait(<span class="number">100</span> * <span class="number">1000</span>);</span><br><span class="line">                    poolConfig.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">"192.168.11.154"</span>, <span class="number">6379</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(JedisPool jedisPool, Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedisPool.returnResourceObject(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TestPool.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JedisPool jedisPool = JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line"></span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.set(<span class="string">"aa"</span>, <span class="string">"bb"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JedisPoolUtil.release(jedisPool, jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong>：</p>
<p>JedisPool 的配置参数大部分是由 JedisPoolConfig 的对应项来赋值的。</p>
<p><strong>maxActive</strong>：控制一个pool可分配多少个jedis实例，通过 pool.getResource() 来获取；如果赋值为 -1，则表示不限制；如果 pool 已经分配了 maxActive 个 jedis 实例，则此时 pool 的状态为 exhausted；</p>
<p><strong>maxIdle</strong>：控制一个 pool 最多有多少个状态为 idle（空闲）的 jedis 实例；</p>
<p>whenExhaustedAction：表示当 pool 中的 jedis 实例都被 allocated 完时，pool 要采取的操作；默认有三种：</p>
<ul>
<li>WHEN_EXHAUSTED_FAIL –&gt; 表示无 jedis 实例时，直接抛出 NoSuchElementException；</li>
<li>WHEN_EXHAUSTED_BLOCK –&gt; 则表示阻塞住，或者达到 maxWait 时抛出 JedisConnectionException；</li>
<li>WHEN_EXHAUSTED_GROW –&gt; 则表示新建一个 jedis 实例，也就说设置的 maxActive 无用；</li>
</ul>
<p><strong>maxWait</strong>：表示当borrow一个 jedis 实例时，最大的等待时间，如果超过等待时间，则直接抛 JedisConnectionException；</p>
<p><strong>testOnBorrow</strong>：获得一个 jedis 实例的时候是否检查连接可用性（ ping() ）；如果为true，则得到的 jedis 实例均是可用的；</p>
<p>testOnReturn：return 一个 jedis 实例给pool时，是否检查连接可用性（ping() ）；</p>
<p>testWhileIdle：如果为 true，表示有一个 idle object evitor 线程对 idle object 进行扫描，如果 validate 失败，此 object 会被从 pool 中 drop 掉；这一项只有在 timeBetweenEvictionRunsMillis 大于 0 时才有意义；</p>
<p>timeBetweenEvictionRunsMillis：表示 idle object evitor 两次扫描之间要 sleep 的毫秒数；</p>
<p>numTestsPerEvictionRun：表示 idle object evitor 每次扫描的最多的对象数；</p>
<p>minEvictableIdleTimeMillis：表示一个对象至少停留在 idle 状态的最短时间，然后才能被 idle object evitor 扫描并驱逐；这一项只有在 timeBetweenEvictionRunsMillis 大于0时才有意义；</p>
<p>softMinEvictableIdleTimeMillis：在 minEvictableIdleTimeMillis 基础上，加入了至少 minIdle 个对象已经在pool里面了。如果为 -1，evicted 不会根据 idle time 驱逐任何对象。如果 minEvictableIdleTimeMillis&gt;0，则此项设置无意义，且只有在 timeBetweenEvictionRunsMillis 大于 0 时才有意义；</p>
<p>lifo：borrowObject返回对象时，是采用 DEFAULT_LIFO（last in first out，即类似cache的最频繁使用队列），如果为 False，则表示 FIFO 队列；</p>
<p>==================================================================================================================<br>其中 JedisPoolConfig 对一些参数的默认设置如下：<br>testWhileIdle=true<br>minEvictableIdleTimeMills=60000<br>timeBetweenEvictionRunsMillis=30000<br>numTestsPerEvictionRun=-1</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记（Day05）</title>
    <url>/2019/05/05/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day05%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/05/Redis学习笔记（Day05）/martin-adams-1557946-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>Photo by <a href="https://unsplash.com/photos/RCx7eaBL8Io?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Martin Adams</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>可以一次执行多个命令，本质是一组命令的集合。一个事务中的，所有命令都会序列化，<strong>按顺序地串行化执行而不会被其它命令插入，不许加塞</strong></p>
<h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><p>一个队列中，一次性，顺序性，排他性的执行一系列命令</p>
<h3 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><strong>Case1：DISCARD —— 取消事务，放弃事务块内的所有命令</strong></p>
<p><strong>Case2：EXEC —— 执行所有事务块内的命令</strong></p>
<p><strong>Case3：MULTI —— 标记一个事务块的开始</strong></p>
<p><strong>Case4：UNWATCH —— 取消 WATCH 命令对所有 key 的监视</strong></p>
<p><strong>Case5：WATCH —— 监视一个（或多个）key，如果在事务执行之前，这个（或这些）key 被其他命令所改动，那么事务将被打断</strong></p>
<ul>
<li><p><strong>悲观锁</strong></p>
<p> 悲观锁（Pessimistic Lock）， 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</p>
</li>
<li><p><strong>乐观锁</strong></p>
<p>乐观锁（Optimistic Lock）， 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，<strong>所以不会上锁</strong>，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，</p>
<p><strong>乐观锁策略：提交版本必须大于记录当前版本才能执行更新</strong></p>
</li>
<li><p><strong>CAS（Check And Set）</strong></p>
</li>
<li><p><strong>有加塞篡改</strong></p>
<p>监控了key，如果key被修改了，后面一个事务的执行失效</p>
</li>
</ul>
<p>一旦执行了 EXEC 之前加的监控锁都会被取消掉了</p>
<p>Watch 指令，类似乐观锁，事务提交时，如果 Key 的值已被别的客户端改变，比如某个 list 已被别的客户端 push / pop 过了，整个事务队列都不会被执行</p>
<p>通过 WATCH 命令在事务执行之前监控了多个 Keys，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 Nullmulti-bulk 应答以通知调用者事务执行失败</p>
<h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><ol>
<li>开启：以MULTI开始一个事务</li>
<li>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</li>
<li>执行：由EXEC命令触发事务</li>
</ol>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</li>
<li>不保证原子性：redis 同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ol>
<h2 id="Redis-的发布订阅"><a href="#Redis-的发布订阅" class="headerlink" title="Redis 的发布订阅"></a>Redis 的发布订阅</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li><p>PSUBSCRIBE pattern [pattern …]</p>
<p>订阅一个或多个符合给定模式的频道</p>
</li>
<li><p>PUBSUB subcommand [argument [argument …]]</p>
<p>查看订阅与发布信息</p>
</li>
<li><p>PUBLISH channel message</p>
<p>将信息发送到指定的频道</p>
</li>
<li><p>PUNSUBSCRIBE [pattern [pattern …]]</p>
<p>退订所有给定模式的频道</p>
</li>
<li><p>SUBSCRIBE channel [channel …]</p>
<p>订阅给定的一个或多个频道信息</p>
</li>
<li><p>UNSUBSCRIBE [channel [channel …]]</p>
<p>指退订给定的频道</p>
</li>
</ul>
<h3 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h3><p><strong>先订阅后发布</strong>后才能收到消息</p>
<ol>
<li>可以一次性订阅多个，SUBSCRIBE c1 c2 c3</li>
<li>消息发布，PUBLISH c2 hello-redis</li>
<li>订阅多个，通配符<em>，PSUBSCRIBE new</em></li>
<li>收取消息，PUBLISH new1 redis2015</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记（Day04）</title>
    <url>/2019/05/04/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day04%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/04/Redis学习笔记（Day04）/berti-benbanaste-1550570-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>Photo by <a href="https://unsplash.com/photos/O6vaYviRDoo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Berti Benbanaste</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的 Snapshot 快照，它恢复时是将快照文件直接读到内存里</p>
<p>Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。</p>
<p>RDB 的缺点是最后一次持久化后的数据可能丢失。</p>
<h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><p>fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>
<h4 id="rdb-保存的是dump-rdb文件"><a href="#rdb-保存的是dump-rdb文件" class="headerlink" title="rdb 保存的是dump.rdb文件"></a>rdb 保存的是dump.rdb文件</h4><h4 id="如何触发RDB快照"><a href="#如何触发RDB快照" class="headerlink" title="如何触发RDB快照"></a>如何触发RDB快照</h4><ul>
<li><p>配置文件中默认的快照配置</p>
<p>冷拷贝后重新使用（可以cp dump.rdb dump_new.rdb）</p>
</li>
<li><p>命令 save 或者是 bgsave</p>
<ul>
<li>save：save时只管保存，其它不管，全部阻塞</li>
<li>bgsave：Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过 lastsave 命令获取最后一次成功执行快照的时间</li>
</ul>
</li>
<li><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p>
</li>
</ul>
<h4 id="如何恢复"><a href="#如何恢复" class="headerlink" title="如何恢复"></a>如何恢复</h4><p>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</p>
<p>CONFIG GET dir获取目录</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ul>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改</li>
<li>fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
</ul>
<h4 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h4><p>动态所有停止RDB保存规则的方法：redis-cli config set save “”</p>
<h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p><strong>以日志的形式来记录每个<em>写操作</em></strong>，将 Redis 执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis 启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<h4 id="AOF-保存的是-appendonly-aof-文件"><a href="#AOF-保存的是-appendonly-aof-文件" class="headerlink" title="AOF 保存的是 appendonly.aof 文件"></a>AOF 保存的是 appendonly.aof 文件</h4><h4 id="AOF启动-修复-恢复"><a href="#AOF启动-修复-恢复" class="headerlink" title="AOF启动/修复/恢复"></a>AOF启动/修复/恢复</h4><h5 id="正常恢复"><a href="#正常恢复" class="headerlink" title="正常恢复"></a>正常恢复</h5><ol>
<li>修改默认的appendonly no，改为yes</li>
<li>将有数据的aof文件复制一份保存到对应目录(config get dir)</li>
<li>恢复：重启redis然后重新加载</li>
</ol>
<h5 id="异常恢复"><a href="#异常恢复" class="headerlink" title="异常恢复"></a>异常恢复</h5><ol>
<li>修改默认的appendonly no，改为yes</li>
<li>备份被写坏的AOF文件</li>
<li>redis-check-aof –fix进行修复</li>
<li>恢复：重启redis然后重新加载</li>
</ol>
<h4 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h4><ul>
<li><strong>是什么：</strong>AOF 采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令 bgrewriteaof</li>
<li><strong>重写原理：</strong>AOF 文件持续增长而过大时，会 fork 出一条新进程来将文件重写(也是先写临时文件最后再 rename)，遍历新进程的内存中数据，每条记录有一条的 Set 语句。重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似</li>
<li><strong>触发机制：</strong> <em>Redis 会记录上次重写时的 AOF 大小，默认配置是当AOF文件大小是上次 rewrite 后大小的一倍且文件大于 64M 时触发</em></li>
</ul>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul>
<li>每修改同步：appendfsync always——同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好</li>
<li>每秒同步：appendfsync everysec——异步操作，每秒记录   如果一秒内宕机，有数据丢失</li>
<li>不同步：appendfsync no——从不同步</li>
</ul>
<h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ul>
<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li>
<li>aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记（Day03）</title>
    <url>/2019/05/03/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day03%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/03/Redis学习笔记（Day03）/chi-liu-1552956-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>Photo by <a href="https://unsplash.com/photos/Bj_MIJ3vpT4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Chi Liu</a> on <a href="https://unsplash.com/t/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Redis-配置文件"><a href="#Redis-配置文件" class="headerlink" title="Redis 配置文件"></a>Redis 配置文件</h2><h3 id="在哪"><a href="#在哪" class="headerlink" title="在哪"></a>在哪</h3><p>拷贝出来单独执行，原文件在 redis 解压文件目录下</p>
<h3 id="Units-单位"><a href="#Units-单位" class="headerlink" title="Units 单位"></a>Units 单位</h3><ol>
<li>配置大小单位，开头定义了一些基本的度量单位，只支持 bytes，不支持 bit</li>
<li>对大小写不敏感</li>
</ol>
<h3 id="INCLUDES-包含"><a href="#INCLUDES-包含" class="headerlink" title="INCLUDES 包含"></a>INCLUDES 包含</h3><p>和 Strust2 配置文件类似，可以通过 includes 包含，redis.conf 可以作为总闸，包含其他</p>
<h3 id="GENERAL-通用"><a href="#GENERAL-通用" class="headerlink" title="GENERAL 通用"></a>GENERAL 通用</h3><ul>
<li><p>Daemonlize</p>
<p>默认为 no，需要改成 yes</p>
</li>
<li><p>Pidfile</p>
<p>进程管道 ID 文件，运行起来如果没指定路径，就使用默认的路径</p>
</li>
<li><p>Port</p>
<p>配置的端口号</p>
</li>
<li><p>Tcp-backlog</p>
<p>设置 tcp 的 backlog，backlog其实是一个连接队列，backlog队列总和 = 未完成三次握手 + 已经完成三次握手队列</p>
<p>在高并发环境下，需要一个高 backlog 值来避免慢客户端连接问题，Linux 内核会将这个值减小到 /proc/sys/net/core/somaxconn 的值，所以需要确认增大 somaxconn 和 tcp_max_syn_backlog 两个值来达到想要的效果</p>
</li>
<li><p>Timeout</p>
</li>
<li><p>Bind</p>
</li>
<li><p>Tcp-keepalive</p>
<p>单位为秒，如果设置为 0，则不会进行 Keepalive 检测，建议设置成 60</p>
</li>
<li><p>Loglevel</p>
<p>日志级别：</p>
<ul>
<li>debug</li>
<li>verbose</li>
<li>notice</li>
<li>warning</li>
</ul>
</li>
<li><p>Logfile</p>
<p>日志名字</p>
</li>
<li><p>Syslog-enabled</p>
<p>是否把日志输出到 Syslog（默认关）</p>
</li>
<li><p>Syslog-ident</p>
<p>指定 Syslog 里的日志标志</p>
</li>
<li><p>Syslog-facility</p>
<p>指定 syslog 设备，只可以是 USER 或 LOCAL0 - LOCAL7（默认LOCAL0）</p>
</li>
<li><p>Databases</p>
<p>默认数据库的数量</p>
</li>
</ul>
<h3 id="SNAPSHOTTING-快照"><a href="#SNAPSHOTTING-快照" class="headerlink" title="SNAPSHOTTING 快照"></a>SNAPSHOTTING 快照</h3><ul>
<li>Save（save 秒钟 写操作次数）</li>
<li>stop-writes-on-bgsave-error（如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制）</li>
<li>rdbcompression（rdbcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis 会采用 LZF 算法进行压缩。如果你不想消耗 CPU 来进行压缩的话，可以设置为关闭此功能）</li>
<li>rdbchecksum（rdbchecksum：在存储快照后，还可以让 redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能）</li>
<li>dbfilename（备份文件名称）</li>
<li>dir</li>
</ul>
<h3 id="REPLICATION-复制"><a href="#REPLICATION-复制" class="headerlink" title="REPLICATION 复制"></a>REPLICATION 复制</h3><h3 id="SECURITY-安全"><a href="#SECURITY-安全" class="headerlink" title="SECURITY 安全"></a>SECURITY 安全</h3><h3 id="LIMITS-限制"><a href="#LIMITS-限制" class="headerlink" title="LIMITS 限制"></a>LIMITS 限制</h3><ul>
<li><p>Maxclients</p>
</li>
<li><p>Maxmemory</p>
</li>
<li><p>Maxmemory-policy</p>
<ul>
<li>Volatile-lru -&gt; remove the key with an expire set using an LRU algorithm（使用 LRU 算法移除 key， 只对设置了过期时间的键）</li>
<li>Allkeys-lru -&gt; remove any key according to the LRU algorithm（使用 LRU 算法移除 key）</li>
<li>Volatile-random -&gt; remove a random key with an expire set（在过期集合中移除随机的 key，只对设置了过期时间的键）</li>
<li>Allkeys-random -&gt; remoce a random key, any key（移除随机的 key）</li>
<li>Volatile-ttl -&gt; remove the key with the nearest expire time(minor TTL)（移除那些 TTL 值最小的 key，即那些最近要过期的 key）</li>
<li>Noeviction -&gt; don’t expire at all, just return an error on write operations（不进行移除，针对写操作，只是返回错误信息）</li>
</ul>
</li>
<li><p>Maxmemory-samples</p>
<p>设置样本数量，LRU 算法和最小 TTL 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis 默认会检查这么多个 key 并选择其中 LRU 的那个</p>
</li>
</ul>
<h3 id="APPEND-ONLY-MODE-追加"><a href="#APPEND-ONLY-MODE-追加" class="headerlink" title="APPEND ONLY MODE 追加"></a>APPEND ONLY MODE 追加</h3><ul>
<li>appendonly</li>
<li>appendfilename</li>
<li>appendfsync<ul>
<li>always：同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li>
<li>everysec：出厂默认推荐，异步操作，每秒记录，如果一秒内宕机，有数据丢失</li>
<li>no</li>
</ul>
</li>
<li>no-appendfsync-on-rewrite：重写时是否可以运用 Appendfsync，用默认 no 即可，保证数据安全性。</li>
<li>auto-aof-rewrite-min-size：设置重写的基准值</li>
<li>auto-aof-rewrite-percentage：设置重写的基准值</li>
</ul>
<h3 id="常见配置-redis-conf-介绍"><a href="#常见配置-redis-conf-介绍" class="headerlink" title="常见配置 redis.conf 介绍"></a>常见配置 redis.conf 介绍</h3><p>参数说明<br>redis.conf 配置项说明如下：</p>
<ol>
<li>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程<br> daemonize no</li>
<li>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定<br> pidfile /var/run/redis.pid</li>
<li>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字<br> port 6379</li>
<li>绑定的主机地址<br> bind 127.0.0.1<br>5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能<br> timeout 300</li>
<li>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose<br> loglevel verbose</li>
<li>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null<br> logfile stdout</li>
<li>设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id<br> databases 16</dbid></li>
<li><p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合<br> save <seconds> <changes><br> Redis默认配置文件中提供了三个条件：<br> save 900 1<br> save 300 10<br> save 60 10000<br> 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</changes></seconds></p>
</li>
<li><p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大<br>rdbcompression yes</p>
</li>
<li>指定本地数据库文件名，默认值为dump.rdb<br>dbfilename dump.rdb</li>
<li>指定本地数据库存放目录<br>dir ./</li>
<li>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步<br>slaveof <masterip> <masterport></masterport></masterip></li>
<li>当master服务设置了密码保护时，slav服务连接master的密码<br>masterauth <master-password></master-password></li>
<li>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭<br>requirepass foobared</password></li>
<li>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息<br>maxclients 128</li>
<li>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区<br>maxmemory <bytes></bytes></li>
<li>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no<br>appendonly no</li>
<li>指定更新日志文件名，默认为appendonly.aof<br>  appendfilename appendonly.aof</li>
<li><p>指定更新日志条件，共有3个可选值：<br>no：表示等操作系统进行数据缓存同步到磁盘（快）<br>always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br>everysec：表示每秒同步一次（折衷，默认值）<br>appendfsync everysec</p>
</li>
<li><p>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）<br>  vm-enabled no</p>
</li>
<li>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享<br>  vm-swap-file /tmp/redis.swap</li>
<li>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0<br>  vm-max-memory 0</li>
<li>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值<br>  vm-page-size 32</li>
<li>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。<br>  vm-pages 134217728</li>
<li>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4<br>  vm-max-threads 4</li>
<li>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启<br>glueoutputbuf yes</li>
<li>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法<br>hash-max-zipmap-entries 64<br>hash-max-zipmap-value 512</li>
<li>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）<br>activerehashing yes</li>
<li>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件<br>include /path/to/local.conf</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记（Day02）</title>
    <url>/2019/05/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day02%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/02/Redis学习笔记（Day02）/john-hoang-1553942-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>Photo by <a href="https://unsplash.com/photos/sf7TIaIwbjs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">John Hoang</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="入门概述"><a href="#入门概述" class="headerlink" title="入门概述"></a>入门概述</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Redis：<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver（远程字典服务器）</p>
<p>是完全开源免费的，用 C 语言编写，遵循 BSD 协议，是一个高性能的（key / value）分布式内存数据库，基于内存运行并支持持久化的 NoSQL 数据库，是当前最热门的 NoSQL 数据库之一，也被称为数据结构服务器</p>
<p>特点：</p>
<ul>
<li>Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用</li>
<li>Redis 不仅仅支持简单的 key - value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储</li>
<li>Redis 支持数据的备份，即 master - slave 模式的数据备份</li>
</ul>
<h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><p>内存存储和持久化：redis 支持异步将内存中的数据写到硬盘上，同时不影响继续服务</p>
<p>取最新 N 个数据的操作，如：可以将最新的10条评论的 ID 放在 Redis 的 List 集合里面</p>
<p>模拟类似于 HttpSession 这种需要设定过期时间的功能</p>
<p>发布、订阅消息系统</p>
<p>定时器、计数器</p>
<h2 id="Redis安装及启动"><a href="#Redis安装及启动" class="headerlink" title="Redis安装及启动"></a>Redis安装及启动</h2><p>将 tar.gz 包发送到 Linux 下，解压，进入目录，make &amp;&amp; make install，如果报没有 gcc 错误，就执行 <strong>yum install -y gcc</strong></p>
<p>安装完成之后可以在 /usr/local/bin 下面发现有以下命令</p>
<p><img src="/2019/05/02/Redis学习笔记（Day02）/Rediscmd.png" alt="插图"></p>
<p>将 <strong>redis</strong> 解压目录下的 redis.conf 复制到自定义目录中（我的是/myredis/）</p>
<p>启动 redis 服务器：redis-server /myredis/redis.conf</p>
<p>查看 redis 服务是否启动：ps -ef | grep redis</p>
<p>启动 redis-cli：redis-cli -p 6379（6379 为默认端口）</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li><p>单进程</p>
<p>单进程模型来处理客户端请求，对读写等事件的响应，是通过对 epoll 函数的包装来做到的，Redis 的实际处理速度完全依靠主进程的执行效率</p>
<p>Epoll 是 Linux 内核为处理大批量文件描述符二做了改进的 epoll，是 Linux 下多路复用 IO 接口 select / poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率</p>
</li>
<li><p>默认 16 个数据库，类似数组下标从 0 开始，初始默认使用零号数据库</p>
</li>
<li>Select 命令切换数据库</li>
<li>Dbsize 查看当前数据库的 key 的数量</li>
<li>FLUSHDB：清空当前库</li>
<li>FLUSHALL：通杀全部库</li>
<li>统一密码管理，16 个库都是同样的密码，要么都连接，要么都连不上</li>
<li>Redis 索引都是从零开始</li>
<li>默认端口 6379</li>
</ul>
<h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><h3 id="Redis-五大数据类型"><a href="#Redis-五大数据类型" class="headerlink" title="Redis 五大数据类型"></a>Redis 五大数据类型</h3><ul>
<li>String（字符串，最多可以是 512M）</li>
<li>Hash（哈希，类似于 Java 里的 Map）</li>
<li>List（列表）</li>
<li>Set（集合）</li>
<li>Zset（sorted set：有序集合 每个元素都会关联一个double类型的分数，分数可重复）</li>
</ul>
<h3 id="Redis-常见数据类型操作命令"><a href="#Redis-常见数据类型操作命令" class="headerlink" title="Redis 常见数据类型操作命令"></a>Redis 常见数据类型操作命令</h3><p><strong><a href="https://redis.io/commands" target="_blank" rel="noopener">https://redis.io/commands</a></strong></p>
<h3 id="Redis-键（key）"><a href="#Redis-键（key）" class="headerlink" title="Redis 键（key）"></a>Redis 键（key）</h3><ul>
<li>keys * –&gt; 查看当前数据库所有的 key</li>
<li>exists key的名字 –&gt; 判断某个 key 是否存在</li>
<li>move key名 db序号 –&gt; 将一个 key 值移动到指定的数据库中，当前数据库就没有了</li>
<li>expire key名 –&gt; 为给定的 key 设置过期时间</li>
<li>ttl key –&gt; 查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</li>
<li>type key –&gt; 查看 key 是什么类型</li>
</ul>
<h3 id="Redis-字符串（String）"><a href="#Redis-字符串（String）" class="headerlink" title="Redis 字符串（String）"></a>Redis 字符串（String）</h3><ul>
<li><p>set / get / del / append / strlen</p>
</li>
<li><p>incr / decr / incrby / decrby，一定一要是数字才能进行加减（前面两个是递增或者递减，后面两个带值加减）</p>
</li>
<li><p>getrange / setrange</p>
<p>getrange：获取指定区间内的值，类似于 between …… and 的关系</p>
<p>setrange：设置指定区间内的值，格式是：setrange key值 具体值</p>
</li>
<li><p>setex（set with expire）键 秒 值 / setnx（set if not exist）</p>
</li>
<li><p>mset / mget / msetnx 批量设置 key-value</p>
</li>
<li><p>getset（先 get 再 set）</p>
</li>
</ul>
<h3 id="Redis-列表（List）"><a href="#Redis-列表（List）" class="headerlink" title="Redis 列表（List）"></a>Redis 列表（List）</h3><ul>
<li>lpush / rpush / lrange</li>
<li>lpop / rpop</li>
<li>lindex，按照索引下标获得元素（从上到下）</li>
<li>lrem list名 N value（从 list 中删除 N 个值为 value 的元素）</li>
<li>ltrim list名 index index（截取指定范围的值后再赋给 key）</li>
<li>rpoplpush 源列表 目的列表</li>
<li>linsert list名 before / after 值1 值2（在 list 中的值1前/后插入值2）</li>
</ul>
<h3 id="Redis-集合（Set）"><a href="#Redis-集合（Set）" class="headerlink" title="Redis 集合（Set）"></a>Redis 集合（Set）</h3><ul>
<li>sadd / smembers / sismember</li>
<li>scard（获取集合里面的元素个数）</li>
<li>srem key value （删除集合中元素）</li>
<li>srandmember key 某个整数（随机出几个数）</li>
<li>spop key （随机出栈）</li>
<li>smove key1 key2 在 key1 里的某个值（作用是将 key1 里的某个值赋给 key2）</li>
<li>数学集合类<ul>
<li>差集：sdiff</li>
<li>交集：sinter</li>
<li>并集：sunion</li>
</ul>
</li>
</ul>
<h3 id="Redis-哈希（Hash）"><a href="#Redis-哈希（Hash）" class="headerlink" title="Redis 哈希（Hash）"></a>Redis 哈希（Hash）</h3><p><strong>KV 模式不变，但是 V 是一个键值对</strong></p>
<ul>
<li>hset / hget / hmset / hmget / hgetall / hdel</li>
<li>hlen</li>
<li>hexist key（在 key 里面的某个值的 key）</li>
<li>hkeys / hvals</li>
<li>hincrby / hincrbyfloat</li>
<li>hsetnx</li>
</ul>
<h3 id="Redis-有序集合（Zset-——-sorted-set）"><a href="#Redis-有序集合（Zset-——-sorted-set）" class="headerlink" title="Redis 有序集合（Zset —— sorted set）"></a>Redis 有序集合（Zset —— sorted set）</h3><ul>
<li>zadd / zrange（zrange 最后可以带一个 withscores 顺便输出 key 值）</li>
<li>zrangebyscore key 开始score 结束score<ul>
<li>withscores</li>
<li>( 不包含</li>
<li>Limit i num 作用是返回限制（从 i 开始截取 num 个）</li>
</ul>
</li>
<li>zrem key 某个 score 下对应的 value 值（作用是删除元素）</li>
<li>zcard / zcount / key score区间 / zrank key values值（作用是获得下标值 / zscore key 对应值，获得分数）</li>
<li>zrevrank key values值（作用是逆序获得下标值）</li>
<li>zrevrange</li>
<li>zrevrangebyscore key 结束score 开始score</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记（Day01）</title>
    <url>/2019/05/01/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day01%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/05/01/Redis学习笔记（Day01）/kellen-riggin-1452245-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/hlvtJ4JkVfc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Kellen Riggin</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>NoSQL（NoSQL = Not Only SQL）泛指非关系型的数据库，这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展</p>
<h3 id="易扩展"><a href="#易扩展" class="headerlink" title="易扩展"></a>易扩展</h3><p>NoSQL 数据库种类繁多，共同德天是去掉关系数据库的关系型特性</p>
<p>数据之间无关系，非常容易扩展，在架构的层面带来了可扩展的能力</p>
<h3 id="大数据量高性能"><a href="#大数据量高性能" class="headerlink" title="大数据量高性能"></a>大数据量高性能</h3><p>具有非常高的读写性能，尤其是在大数据量下，同样表现优秀</p>
<h2 id="3V-3高"><a href="#3V-3高" class="headerlink" title="3V + 3高"></a>3V + 3高</h2><p>3V：</p>
<ul>
<li>海量 Volume</li>
<li>多样 Variety</li>
<li>实时 Velocity</li>
</ul>
<p>3高：</p>
<ul>
<li>高并发</li>
<li>高可扩</li>
<li>高性能</li>
</ul>
<h2 id="NoSQL-数据模型"><a href="#NoSQL-数据模型" class="headerlink" title="NoSQL 数据模型"></a>NoSQL 数据模型</h2><h3 id="聚合模型"><a href="#聚合模型" class="headerlink" title="聚合模型"></a>聚合模型</h3><ul>
<li>KV 键值对</li>
<li>BSON</li>
<li>列族</li>
<li>图形</li>
</ul>
<h2 id="NoSQL-数据库的四大分类"><a href="#NoSQL-数据库的四大分类" class="headerlink" title="NoSQL 数据库的四大分类"></a>NoSQL 数据库的四大分类</h2><p><strong>KV 键值</strong>：</p>
<ul>
<li>新浪</li>
<li>美团</li>
<li>阿里</li>
<li>百度</li>
</ul>
<p><strong>文档型数据库（BSON格式较多）</strong>：</p>
<ul>
<li>CouchDB</li>
<li>MongoDB：是一个基于分布式存储的数据库，由 C++ 语言编写，结余关系数据库和非关系数据库之间的产品</li>
</ul>
<p><strong>列存储数据库</strong>：</p>
<ul>
<li>Cassandra</li>
<li>HBase</li>
<li>分布式文件系统</li>
</ul>
<p><strong>图关系数据库</strong></p>
<p>不是放图形的，放的是关系，比如：朋友圈社交网络、广告推荐系统，社交网络、推荐系统等，专注于构建关系图谱</p>
<ul>
<li>Neo4j</li>
<li>InfoGrid</li>
</ul>
<p><strong>四者对比</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>Example 举例</th>
<th>典型应用场景</th>
<th>数据模型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>键值（key - value）</td>
<td>Tokyo，Cabinet/Tyrant，Redis，Voldemort，Oracle BDB</td>
<td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等</td>
<td>Key 指向 Value的键值对，通常用 hash table 来实现</td>
<td>查找熟读快</td>
<td>数据无机构化，通常只被当做字符串或者二进制数据</td>
</tr>
<tr>
<td>列存储数据库</td>
<td>Cassandra，HBase，Riak</td>
<td>分布式的文件系统</td>
<td>以列簇式存储，将同一列数据存在一起</td>
<td>查找速度快，可扩展性强，更容易进行分布式扩展</td>
<td>功能相对有限</td>
</tr>
<tr>
<td>文档型数据库</td>
<td>CouchDB，MongoDB</td>
<td>Web 应用（与 key - value 类似，value 是结构化的，不同的是数据库能够了解 value 的内容</td>
<td>key - value对应的键值对，value 为结构化数据</td>
<td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td>
<td>查询性能不高，而且缺乏统一的查询语法</td>
</tr>
<tr>
<td>图形（Graph）数据库</td>
<td>Noe4J，InfoGrid，Infinite Graph</td>
<td>社交网络，推荐系统，专注于构建关系图谱</td>
<td>图结构</td>
<td>利用图结构相关算法，比如最短路径寻址，N 度关系查找等</td>
<td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案</td>
</tr>
</tbody>
</table>
<h2 id="分布式数据库中-CAP-原理-CAP-BASE"><a href="#分布式数据库中-CAP-原理-CAP-BASE" class="headerlink" title="分布式数据库中 CAP 原理 CAP + BASE"></a>分布式数据库中 CAP 原理 CAP + BASE</h2><h3 id="传统的ACID"><a href="#传统的ACID" class="headerlink" title="传统的ACID"></a>传统的ACID</h3><ul>
<li>A（Atomicity）原子性</li>
<li>C（Consistency）一致性</li>
<li>I（Isolation）独立性</li>
<li>D（Durability）持久性</li>
</ul>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul>
<li>C（Consistency）强一致性</li>
<li>A（Availability）可用性</li>
<li>P（Partition tolerance）分区容错性</li>
</ul>
<p>CAP 理论的核心：一个分布式系统不可能同时很好满足一致性，可用性和分区容错性这三个需求，<strong>最多只能同时<em>较好的</em>满足两个</strong></p>
<p>根据 CAP 原理将 NoSQL 数据库分成了 满足 CA 原则，满足 CP 原则和满足 AP 原则三大类：</p>
<ul>
<li>CA – 单点集群：满足一致性，可用性的系统，通常在可扩展性上不太强大；（Oracle）</li>
<li>CP – 满足一致性，分区容错性的系统，通常性能不是特别高；（Redis，MongoDB）</li>
<li>AP – 满足可用性，分区容错性的系统，通常可能对一致性要求低一些（大多数网站架构选择）</li>
</ul>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>是为了结局关系数据库强一致性引起的问题而引起的可用性降低突出的解决方案</p>
<ul>
<li>BA（Basically Available）基本可用</li>
<li>S（Soft state）软状态</li>
<li>E（Eventually consistent）最终一致</li>
</ul>
<p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day04）</title>
    <url>/2019/04/28/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day04%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/04/28/SpringBoot学习笔记（Day04）/asoggetti-1486419-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/VJTmFSendQ0?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">asoggetti</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="Spring-声明式事务的使用"><a href="#Spring-声明式事务的使用" class="headerlink" title="Spring 声明式事务的使用"></a>Spring 声明式事务的使用</h2><h3 id="Transactional-配置项"><a href="#Transactional-配置项" class="headerlink" title="@Transactional 配置项"></a>@Transactional 配置项</h3><p><strong>@Transactional 源码</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface Transactional &#123;</span><br><span class="line"></span><br><span class="line">    // 通过 bean name 指定事务管理器</span><br><span class="line">    @AliasFor(&quot;transactionManager&quot;)</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    // 同 value 属性</span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String transactionManager() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    // 指定传播行为</span><br><span class="line">    Propagation propagation() default Propagation.REQUIRED;</span><br><span class="line"></span><br><span class="line">    // 指定隔离级别</span><br><span class="line">    Isolation isolation() default Isolation.DEFAULT;</span><br><span class="line"></span><br><span class="line">    // 指定超时时间</span><br><span class="line">    int timeout() default -1;</span><br><span class="line"></span><br><span class="line">    // 是否只读事务</span><br><span class="line">    boolean readOnly() default false;</span><br><span class="line"></span><br><span class="line">    // 方法在发生指定异常时回滚，默认是所有异常都回滚</span><br><span class="line">    Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 方法在发生指定异常名称时回滚，默认是所有异常都回滚</span><br><span class="line">    String[] rollbackForClassName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 方法在发生指定异常时不回滚，默认是所有异常都回滚</span><br><span class="line">    Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 方法在发生指定异常名称时不回滚，默认是所有异常都回滚</span><br><span class="line">    String[] noRollbackForClassName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>value，transactionManager</strong> 属性是配置一个 Spring 的事务管理器；<br><strong>timeout</strong> 是事务可以允许存在的时间戳，单位为秒；<br><strong>readOnly</strong> 属性定义的是事务是否是只读事务；<br><strong>propagation</strong> 指的是传播行为；<br><strong>isolation</strong> 是隔离级别；</p>
<p>关于 @Transactional：<br>它可以放在接口上，也可以放在实现类上，推荐放在实现类上</p>
<h2 id="Spring-事务管理器"><a href="#Spring-事务管理器" class="headerlink" title="Spring 事务管理器"></a>Spring 事务管理器</h2><p><strong>PlatformTransactionManager 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取事务，他还会设置数据属性</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getTransaction</strong> 方法的参数是一个事务定义器，依赖于配置的 @Transactional 的配置项生成的，提交和回滚事务也就可以通过 <strong>commit</strong> 和 <strong>rollback</strong> 方法执行</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="数据库事务的知识"><a href="#数据库事务的知识" class="headerlink" title="数据库事务的知识"></a>数据库事务的知识</h3><p>数据库事务具有以下4个基本特征（ACID）：  </p>
<ul>
<li>Atomoc（原子性）：事务中包含的操作被看作一个整体单元，这个业务单元中的操作要么全部成功，要么全部失败；</li>
<li>Consistency（一致性）：事务在完成时，必须使所有的数据都保持一直状态，在数据库中所有的修改都基于事务，保证了数据的完整性；</li>
<li>Isolation（隔离性）：为了压制丢失更新的产生，数据库定义了隔离级别的概念，可以在不同上程度压制丢失更新的发生；</li>
<li>Durability（持久性）：事务结束后，所有的数据会固化到一个地方，入保存到磁盘中，即使断电重启后也可以提供应用程序访问；</li>
</ul>
<h3 id="详解隔离级别"><a href="#详解隔离级别" class="headerlink" title="详解隔离级别"></a>详解隔离级别</h3><ul>
<li>未提交读（run uncommitted）：是最低的隔离级别，允许一个事务读取另一个事务没有提交的数据（比较危险，会出现脏读）</li>
<li>读写提交（read committed）：指一个事务只能读取另外一个事务已经提交的数据，不能读取未提交的数据</li>
<li>可重复读：克服读写提交中出现的不可重读的现象</li>
<li>串行化（Serializable）：是数据库最高的隔离级别，他会要求所有的 SQL，都会按照顺序执行，可以克服上述隔离级别出现的各种问题，能够保证数据的一致性</li>
</ul>
<p>在 Spring Boot 配置文件 application.properties 中配置隔离级别：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 隔离级别数字配置的含义</span><br><span class="line"># -1    数据库默认隔离级别</span><br><span class="line"># 1     未提交读</span><br><span class="line"># 2     读写提交</span><br><span class="line"># 4     可重复读</span><br><span class="line"># 8     串行化</span><br><span class="line"># tomcat    数据源默认隔离级别</span><br><span class="line">spring.datasource.tomcat.default-transaction-isolation=2</span><br><span class="line"># dbcp2 数据库连接池默认隔离级别</span><br><span class="line"># spring.datasource.dbcp2.default-transaction-isolation=2</span><br></pre></td></tr></table></figure></p>
<h2 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h2><h3 id="传播行为的定义"><a href="#传播行为的定义" class="headerlink" title="传播行为的定义"></a>传播行为的定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Propagation &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要事务，它是默认传播行为，如果当前存在事务，就沿用当前事务</span></span><br><span class="line"><span class="comment">     * 否则新建一个事务运行子方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持事务，如果当前存在事务，就沿用当前事务</span></span><br><span class="line"><span class="comment">     * 如果不存在，则继续采用无事务的方式运行子方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须使用事务，如果当前没有事务，则会抛出异常</span></span><br><span class="line"><span class="comment">     * 如果存在当前事务，就沿用当前事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无论当前事务是否存在，都会创建新事务运行方法</span></span><br><span class="line"><span class="comment">     * 这样新事物就可以拥有新的锁和隔离级别等特性，与当前事务相互独立</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不支持事务，当前存在事务时，将挂起事务，运行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不支持事务，当前存在事务时，将挂起事务，运行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在当前方法调用子方法时，如果子方法发生异常</span></span><br><span class="line"><span class="comment">     * 只回滚子方法执行过的 SQL，而不回滚当前方法的事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    Propagation(<span class="keyword">int</span> value) &#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day03）</title>
    <url>/2019/04/24/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day03%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/04/24/SpringBoot学习笔记（Day03）/max-van-den-oetelaar-1328723-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/F3rDBnQQbQU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Max van den Oetelaar</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="代理模式和分类"><a href="#代理模式和分类" class="headerlink" title="代理模式和分类"></a>代理模式和分类</h2><ul>
<li>虚拟代理：根据余姚将资源消耗很大的对象进行延迟，真正需要的时候进行创建</li>
<li>智能引用代理：提供对目标对象额外的服务</li>
<li>远程代理：为不同地理的对象提供局域网代表对象</li>
<li>保护代理：控制对一个对象的访问权限</li>
</ul>
<h3 id="智能引用代理"><a href="#智能引用代理" class="headerlink" title="智能引用代理"></a>智能引用代理</h3><ul>
<li>静态代理：代理和被代理对象在代理之前是确定的，他们都实现相同的接口或者继承相同的抽象类</li>
<li>动态代理</li>
</ul>
<h4 id="继承和聚合实现静态代理"><a href="#继承和聚合实现静态代理" class="headerlink" title="继承和聚合实现静态代理"></a>继承和聚合实现静态代理</h4><p>继承会导致每添加一个功能就需要新建一个类，导致代码无限膨胀<br>聚合代理每添加一个被代理对象就需要新建一个类，也会导致代码膨胀</p>
<h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>动态代理（Dynamic Proxy）是这样一种class：<br>它是在运行时产生的 class 对象<br>该 class 需要实现一组 interface<br>只用动态代理类是，必须实现 InvocationHandler 接口</p>
<p>实现步骤：</p>
<ul>
<li>创建一个实现 InvocationHandler 的类，它必须实现 invoke 方法</li>
<li>创建被代理的类以及接口</li>
<li>调用 Proxy 的静态方法，创建一个代理类<br>new ProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler handler)</li>
<li>通过代理调用方法</li>
</ul>
<h4 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h4><p>与 JDK 动态代理的区别：  </p>
<p>JDK 动态代理：</p>
<ul>
<li>只能代理实现了接口的类</li>
<li>没有实现接口的类不能实现 JDK 的动态代理</li>
</ul>
<p>CGLIB 动态代理：</p>
<ul>
<li>针对类来代理的</li>
<li>队指定目标类产生一个子类，通过方法拦截技术拦截所有父类方法的调用</li>
</ul>
<h4 id="动态代理实现思路"><a href="#动态代理实现思路" class="headerlink" title="动态代理实现思路"></a>动态代理实现思路</h4><p>实现功能：通过 Proxy 的 newProxyInstance 返回代理对象  </p>
<ol>
<li>声明一段源码（动态产生代理）</li>
<li>编译源码（JDK Compiler API），产生新的代理类（代理类）</li>
<li>将这个类 load 到内存中，产生一个新的对象（代理对象）</li>
<li>return 代理对象</li>
</ol>
<h3 id="AOP-术语和流程"><a href="#AOP-术语和流程" class="headerlink" title="AOP 术语和流程"></a>AOP 术语和流程</h3><p><strong>连接点（join point）：</strong> 对应的是具体没拦截的对象，因为 Spring 只能支持方法，所以被拦截的对象往往就是指特定的方法<br><strong>切点（point cut）：</strong> 有时候，我们的切面不单单应用于耽搁方法，也有可能是多个类的不同方法，这时，可以通过正则表达式和指示器的规则去定义，从而适配连接点。切点就是提供这样一个功能的概念<br><strong>通知（advice）：</strong> 就是按照约定的流程下的方法，分为前置通知（before advice）、后置通知（after advice）、环绕通知（around advice）、事后返回通知（afterReturningadvice）和异常通知（afterThrowing advice），它会根据约定织入流程中，需要弄明白它们在流程中的顺序和运行的条件<br><strong>目标对象（target）：</strong> 即被代理对象<br><strong>引入（introduction）：</strong> 是指引入新的类和方法，增强现有 Bean 的功能<br><strong>织入（weaving）：</strong> 它是通过动态代理技术，为原有服务对象生成代理对象，然后将切点定义匹配的连接点拦截，并按约定将各类通知织入约定流程的过程<br><strong>切面（aspect）：</strong> 是一个可以定义切点、各类通知和引入的内容，Spring AOP 将通过它的信息来增强 Bean 的功能或者将对应的方法织入流程</p>
<p><img src="/2019/04/24/SpringBoot学习笔记（Day03）/SpringAOP流程约定.jpg" alt="插图"></p>
<center> Spring AOP 流程约定 </center>

<h3 id="定义切面-切点"><a href="#定义切面-切点" class="headerlink" title="定义切面 切点"></a>定义切面 切点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(* cn.chentyit.chapter4.aspect.service.impl.UserServiceImpl.printUser(..))&quot;)</span><br><span class="line">    public void pointCut() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;pointCut()&quot;)</span><br><span class="line">    public void around(ProceedingJoinPoint jp) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;around before ......&quot;);</span><br><span class="line">        // 回调目标对象的原有方法</span><br><span class="line">        jp.proceed();</span><br><span class="line">        System.out.println(&quot;around after ......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;pointCut()&quot;)</span><br><span class="line">    public void before() &#123;</span><br><span class="line">        System.out.println(&quot;before ......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;pointCut()&quot;)</span><br><span class="line">    public void after() &#123;</span><br><span class="line">        System.out.println(&quot;after ......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterReturning(&quot;pointCut()&quot;)</span><br><span class="line">    public void afterReturning() &#123;</span><br><span class="line">        System.out.println(&quot;afterReturning ......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterThrowing(&quot;pointCut()&quot;)</span><br><span class="line">    public void afterThrowing() &#123;</span><br><span class="line">        System.out.println(&quot;afterThrowing ......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@Aspect</strong> 作为注解时，Spring 就会知道这是一个切面，我们就可以通过各类注解来定义各类的通知了<br><strong>@Before</strong> 前置通知<br><strong>@After</strong> 后置通知<br><strong>@AfterReturning</strong> 返回通知<br><strong>@AfterThrowing</strong> 异常通知</p>
<p><strong>切点：</strong> 作用就是向 Spring 描述哪些类的哪些方法需要启用 AOP 编程<br><strong>@Pointcut</strong> 标志在 pointCut 方法上，则在后面的通知注解中就可以使用方法名来定义了</p>
<p>其他：</p>
<ul>
<li>execution：表示在执行的时候，拦截里面的正则匹配的方法</li>
<li>* 表示任意返回类型的方法</li>
<li>cn.chentyit.chapter4.aspect.service.impl.UserServiceImpl 指定目标对象的全限定名称</li>
<li>printUser 指定目标对象的方法</li>
<li>(..) 表示任意参数进行匹配</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day02）</title>
    <url>/2019/04/23/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day02%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/04/23/SpringBoot学习笔记（Day02）/kellen-riggin-1529865-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/jv3W2z-79Rc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Kellen Riggin</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="使用属性文件"><a href="#使用属性文件" class="headerlink" title="使用属性文件"></a>使用属性文件</h2><h3 id="直接使用配置文件属性"><a href="#直接使用配置文件属性" class="headerlink" title="直接使用配置文件属性"></a>直接使用配置文件属性</h3><p>先在 pom.xml 文件中添加以下依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以在代码中直接使用 .application 文件了<br>再编写以下代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">/**</span><br><span class="line"> * @PropertySource(&quot;classpath:application.properties&quot;) </span><br><span class="line"> * 这行代码是必要的，指定配置文件的路径，方便使用属性配置</span><br><span class="line"> */</span><br><span class="line">@PropertySource(&quot;classpath:application.properties&quot;)</span><br><span class="line">public class DataBaseProperties &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;database.driver&#125;&quot;)</span><br><span class="line">    private String driverName = null;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;database.url&#125;&quot;)</span><br><span class="line">    private String url = null;</span><br><span class="line"></span><br><span class="line">    private String username = null;</span><br><span class="line"></span><br><span class="line">    private String password = null;</span><br><span class="line"></span><br><span class="line">    public String getDriverName() &#123;</span><br><span class="line">        return driverName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDriverName(String driverName) &#123;</span><br><span class="line">        System.out.println(driverName);</span><br><span class="line">        this.driverName = driverName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUrl() &#123;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUrl(String url) &#123;</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        this.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;database.username&#125;&quot;)</span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;database.password&#125;&quot;)</span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        System.out.println(password);</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用-ConfigurationProperties"><a href="#使用-ConfigurationProperties" class="headerlink" title="使用 @ConfigurationProperties"></a>使用 @ConfigurationProperties</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(&quot;database&quot;)</span><br><span class="line">public class DataBaseProperties &#123;</span><br><span class="line"></span><br><span class="line">    private String driverName = null;</span><br><span class="line"></span><br><span class="line">    private String url = null;</span><br><span class="line"></span><br><span class="line">    private String username = null;</span><br><span class="line"></span><br><span class="line">    private String password = null;</span><br><span class="line"></span><br><span class="line">    public String getDriverName() &#123;</span><br><span class="line">        return driverName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDriverName(String driverName) &#123;</span><br><span class="line">        System.out.println(driverName);</span><br><span class="line">        this.driverName = driverName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUrl() &#123;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUrl(String url) &#123;</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        this.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        System.out.println(password);</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注解 <strong>@ConfigurationProperties</strong> 中配置的字符串 <strong>database</strong> 将于 POJO 的属性名组成属性的全限定名去配置文件里面查找</p>
<h3 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h3><p>将配置文件中的属性单独取出来放到新的 .properties 文件中（以 jdbc.properties为例）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">database.driver=com.mysql.jdbc.Driver</span><br><span class="line">database.url=&quot;jdbc:mysql://127.0.0.1:3306/repository?characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=Asia/Shanghai&quot;</span><br><span class="line">database.username=root</span><br><span class="line">database.password=Chentyit123456</span><br></pre></td></tr></table></figure></p>
<p>配置类代码不改动，并在 *Application 中添加 <strong>@PropertySource</strong> 注释<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@PropertySource(value = &#123;&quot;classpath:jdbc.properties&quot;&#125;, ignoreResourceNotFound = true)</span><br><span class="line">public class Chapter2Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Chapter2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ignoreResourceNotFound 是忽略配置文件找不到的问题，默认值为false，也就是没找到配置文件，就会报错；这里配置为true，忽略掉错误，不报错；</p>
<h2 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h2><table>
<thead>
<tr>
<th>作用域类型</th>
<th style="text-align:center">使用范围</th>
<th style="text-align:right">作用域描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>singleton</strong></td>
<td style="text-align:center">所有 Spring 应用</td>
<td style="text-align:right">默认值，IoC 容器只存在单例</td>
</tr>
<tr>
<td><strong>prototype</strong></td>
<td style="text-align:center">所有 Spring 应用</td>
<td style="text-align:right">每当从 IoC 容器中取出一个 Bean，则创建一个新的 Bean</td>
</tr>
<tr>
<td><strong>session</strong></td>
<td style="text-align:center">Spring Web 应用</td>
<td style="text-align:right">HTTP 会话</td>
</tr>
<tr>
<td><strong>application</strong></td>
<td style="text-align:center">Spring Web 应用</td>
<td style="text-align:right">Web 工程生命周期</td>
</tr>
<tr>
<td>request</td>
<td style="text-align:center">Spring Web 应用</td>
<td style="text-align:right">Web 工程单次请求（request）</td>
</tr>
<tr>
<td>globalSession</td>
<td style="text-align:center">Spring Web 应用</td>
<td style="text-align:right">在一个全局的 HTTp Session 中，一个 Bean 定义对应一个实例</td>
</tr>
</tbody>
</table>
<p>可以使用 @Scope 定义单例或者原型（默认单例）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">// @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">public class ScopeBean &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码注释了 @Scope，使用的是单例，但是取消注释后，就是原型了  </p>
<ul>
<li>ConfigurableBeanFactory 只能提供单例（SCOPE_SINGLETON）和原型（SCOPE_PROTOTYPE）两种作用域供选择</li>
<li>WebApplicationContext 提供了请求（SCOPE_REQUEST）、会话（SCOPE_SESSION）和应用（SCOPE_APPLICATION）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（Day01）</title>
    <url>/2019/04/22/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day01%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2019/04/22/SpringBoot学习笔记（Day01）/david-billings-1528851-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/567UmWZIYJ8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Matthew T Rader</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h2 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h2><h3 id="通过扫描装配Bean"><a href="#通过扫描装配Bean" class="headerlink" title="通过扫描装配Bean"></a>通过扫描装配Bean</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component（&quot;user&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Value(&quot;1&quot;)</span><br><span class="line">    private Long id;</span><br><span class="line">    @Value(&quot;user_name_1&quot;)</span><br><span class="line">    private String userName;</span><br><span class="line">    @Value(&quot;note_1&quot;)</span><br><span class="line">    private String note;</span><br><span class="line"></span><br><span class="line">    /** setter and getter **/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Component 是标明哪个类被扫描进入 Spring IoC 容器<br>@ComponentScan 是标明采用何种策略去扫描装配Bean（默认扫描被标注类所在的当前包和其子包）</p>
<p><strong>@ComponentScan 源码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Documented</span><br><span class="line">@Repeatable(ComponentScans.class)</span><br><span class="line">public @interface ComponentScan &#123;</span><br><span class="line"></span><br><span class="line">    // 定义扫描的包</span><br><span class="line">    @AliasFor(&quot;basePackages&quot;)</span><br><span class="line">    String[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 定义扫描的包</span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String[] basePackages() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 定义扫描的类</span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // Bean name 生成器</span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class;</span><br><span class="line"></span><br><span class="line">    // 作用域解析器</span><br><span class="line">    Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() default AnnotationScopeMetadataResolver.class;</span><br><span class="line"></span><br><span class="line">    // 作用域代理模式</span><br><span class="line">    ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;</span><br><span class="line"></span><br><span class="line">    // 资源匹配模式</span><br><span class="line">    String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;</span><br><span class="line"></span><br><span class="line">    // 是否启用默认的过滤器</span><br><span class="line">    boolean useDefaultFilters() default true;</span><br><span class="line"></span><br><span class="line">    // 当满足过滤器的条件时扫描</span><br><span class="line">    Filter[] includeFilters() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 当不满足过滤器的条件时扫描</span><br><span class="line">    Filter[] excludeFilters() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 是否延迟初始化</span><br><span class="line">    boolean lazyInit() default false;</span><br><span class="line"></span><br><span class="line">    // 定义过滤器</span><br><span class="line">    @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">    @Target(&#123;&#125;)</span><br><span class="line">    @interface Filter &#123;</span><br><span class="line">        // 过滤器类型，可以按注解类型或者正则式等过滤</span><br><span class="line">        FilterType type() default FilterType.ANNOTATION;</span><br><span class="line">        </span><br><span class="line">        // 定义过滤的类</span><br><span class="line">        @AliasFor(&quot;classes&quot;)</span><br><span class="line">        Class&lt;?&gt;[] value() default &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        // 定义过滤的类</span><br><span class="line">        @AliasFor(&quot;value&quot;)</span><br><span class="line">        Class&lt;?&gt;[] classes() default &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        // 匹配方式</span><br><span class="line">        String[] pattern() default &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@SpringBootApplication 源码</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters = &#123;</span><br><span class="line">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">		@Filter(type = FilterType.CUSTOM,</span><br><span class="line">				classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">    </span><br><span class="line">    // 通过类型排除自动配置类</span><br><span class="line">    @AliasFor(annotation = EnableAutoConfiguration.class)</span><br><span class="line">    Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 通过名称排除自动配置类</span><br><span class="line">    @AliasFor(annotation = EnableAutoConfiguration.class)</span><br><span class="line">    String[] excludeName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 定义扫描包</span><br><span class="line">    @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span><br><span class="line">    String[] scanBasePackages() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 定义被扫描的类</span><br><span class="line">    @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)</span><br><span class="line">    Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注解-Autowired"><a href="#注解-Autowired" class="headerlink" title="注解 @Autowired"></a>注解 @Autowired</h3><p>注入机制：根据类型<br>注入规则：首先会根据类型找到对应的 Bean，如果对应类型的 Bean 不是唯一的，那么他会根据其属性名称和 Bean 的名称进行匹配。如果匹配得上，就会使用该 Bean，如果还无法匹配，就会抛出异常。</p>
<h3 id="消除歧义性-——-Primary-和-Qualifier"><a href="#消除歧义性-——-Primary-和-Qualifier" class="headerlink" title="消除歧义性 —— @Primary 和 @Qualifier"></a>消除歧义性 —— @Primary 和 @Qualifier</h3><p>@Primary：告诉 Spring IoC 容器，当发现有多个同样类型的 Bean 时，优先使用 @Primary 标注的 Bean 注入<br>@Qualifier：配置项 value 需要一个字符串去定义，它将与 <strong>@Autowired</strong> 组合在一起，通过类型和名称一起找到 Bean</p>
<h3 id="带有参数的构造方法类的装配"><a href="#带有参数的构造方法类的装配" class="headerlink" title="带有参数的构造方法类的装配"></a>带有参数的构造方法类的装配</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BussinessPerson implements Person &#123;</span><br><span class="line"></span><br><span class="line">    private Animal animal;</span><br><span class="line"></span><br><span class="line">    public BussinessPerson(@Autowired @Qualifier(&quot;dog&quot;) Animal animal) &#123;</span><br><span class="line">        this.animal = animal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void service() &#123;</span><br><span class="line">        this.animal.use();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setAnimal(Animal animal) &#123;</span><br><span class="line">        this.animal = animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>自学笔记</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-1.x和SpringBoot-2.x区别</title>
    <url>/2019/04/16/SpringBoot-1-x%E5%92%8CSpringBoot-2-x%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="该博客用于更新SpingBoot-1-x-和-2-x-之间的区别（长期更新）"><a href="#该博客用于更新SpingBoot-1-x-和-2-x-之间的区别（长期更新）" class="headerlink" title="该博客用于更新SpingBoot 1.x 和 2.x 之间的区别（长期更新）"></a>该博客用于更新SpingBoot 1.x 和 2.x 之间的区别（长期更新）</h2><p><img src="/2019/04/16/SpringBoot-1-x和SpringBoot-2-x区别/garrett-patz-1504925-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/Ilu1Vv6EYds?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Garrett Patz</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h3 id="编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置"><a href="#编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置" class="headerlink" title="编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置"></a>编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</h3><ul>
<li>SpringBoot 1.x</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean  //一定要将这个定制器加入到容器中</span><br><span class="line">public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123;</span><br><span class="line">    return new EmbeddedServletContainerCustomizer() &#123;</span><br><span class="line"></span><br><span class="line">        //定制嵌入式的Servlet容器相关的规则</span><br><span class="line">        @Override</span><br><span class="line">        public void customize(ConfigurableEmbeddedServletContainer container) &#123;</span><br><span class="line">            container.setPort(8083);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SpringBoot 2.x</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ConfigurableServletWebServerFactory webServerFactory() &#123;</span><br><span class="line">    return new TomcatServletWebServerFactory() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void customizeConnector(Connector connector) &#123;</span><br><span class="line">            connector.setPort(8083);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>苏州Vlog（01）</title>
    <url>/2019/04/05/%E8%8B%8F%E5%B7%9EVlog%EF%BC%8801%EF%BC%89/</url>
    <content><![CDATA[<h2 id="清明苏州游Vlog（第一弹）"><a href="#清明苏州游Vlog（第一弹）" class="headerlink" title="清明苏州游Vlog（第一弹）"></a>清明苏州游Vlog（第一弹）</h2><p>游玩景点：</p>
<ul>
<li>诚品书店</li>
<li>桃花眷村</li>
<li>月光码头</li>
</ul>
<p><img src="/2019/04/05/苏州Vlog（01）/金鸡湖.jpg" alt="插图"></p>
<blockquote>
<p>拍摄于月光码头</p>
</blockquote>
<a id="more"></a>
<p><strong>难得一次节假日，溜出来和同学来苏州游玩一番，大学三年，我差不多宅了三年，在毕业之前，蹭着这次机会出来看看世界，看看祖国的大好河山（强行升华主题）</strong></p>
<h3 id="从学校出发"><a href="#从学校出发" class="headerlink" title="从学校出发"></a>从学校出发</h3><p>话说过节真的很难打车，我用滴滴等了好久没来车，就直接坐了学校北门的私家车（极不推荐）毕竟不安全，但是赶时间，就上车了，等到了车站，进了候车厅，我服了</p>
<p><img src="/2019/04/05/苏州Vlog（01）/车站.jpg" alt="插图"></p>
<p>这人，太！多！了！我想起来我去年去北京在地铁站等地铁的时候看到的情景</p>
<p><img src="/2019/04/05/苏州Vlog（01）/北京.jpg" alt="插图"></p>
<p>我更坚定了以后节假日要少出来，好好宅起来（真香警告）</p>
<p>我坐车做了一个半小时终于到苏州了，同学从南京出发，比我先到一个小时，后面还堵车缓行，磨磨蹭蹭最后还是落脚苏州，可是除了车站后才发现我们两个的车站离了差不多20分钟车程的距离，原本商量直接去原先定好的民宿，可是司机说那个民宿的地方都快出苏州了，我就凌乱了，果断退掉然后重新定了酒店，其中各种烦心事就懒得说了。到了新酒店，入住放包，休息了一下就出去玩了。</p>
<h3 id="第一站：诚品书店"><a href="#第一站：诚品书店" class="headerlink" title="第一站：诚品书店"></a>第一站：诚品书店</h3><p>关于诚品书店，我今天也才知道，不知道的请参照下图（手动滑稽）</p>
<p><img src="/2019/04/05/苏州Vlog（01）/百度.jpg" alt="插图"></p>
<p>发现诚品书店里面的书真多，但是吧，没有能够吸引我的，不是我眼光太高，实在是提不起兴趣，这里面的书大多数都是和艺术，设计，美学有关的，像我这种写个 APP 界面都要被吐槽的，逗比细胞反噬艺术细胞的直男，真心无感。。。。。。</p>
<p>但是感觉这个书店真的很不错的，也建议大家来看看，就算没有看上的书，来感受一波也是极好的</p>
<p><img src="/2019/04/05/苏州Vlog（01）/诚品书店1.jpg" alt="插图"></p>
<p><img src="/2019/04/05/苏州Vlog（01）/诚品书店2.jpg" alt="插图"></p>
<p><img src="/2019/04/05/苏州Vlog（01）/诚品书店3.jpg" alt="插图"></p>
<p><img src="/2019/04/05/苏州Vlog（01）/诚品书店4.jpg" alt="插图"></p>
<p><img src="/2019/04/05/苏州Vlog（01）/诚品书店5.jpg" alt="插图"></p>
<p><img src="/2019/04/05/苏州Vlog（01）/诚品书店6.jpg" alt="插图"></p>
<p><img src="/2019/04/05/苏州Vlog（01）/诚品书店7.jpg" alt="插图"></p>
<p><img src="/2019/04/05/苏州Vlog（01）/诚品书店8.jpg" alt="插图"></p>
<p><img src="/2019/04/05/苏州Vlog（01）/诚品书店9.jpg" alt="插图"></p>
<h3 id="第二站：桃花眷村"><a href="#第二站：桃花眷村" class="headerlink" title="第二站：桃花眷村"></a>第二站：桃花眷村</h3><p>逛完书店后，嘴馋了，就到楼下的 “桃花眷村” 吃了一小顿，点了一个豆花（不是我吃的），点了一个饭团和一份冷豆浆，一不小心就吃的有点饱了</p>
<p><img src="/2019/04/05/苏州Vlog（01）/小吃.jpg" alt="插图"></p>
<h3 id="第三站：月光码头"><a href="#第三站：月光码头" class="headerlink" title="第三站：月光码头"></a>第三站：月光码头</h3><p>第三站我们走到了金鸡湖边的一个广场，拍了点照片，这篇博客首页的图片就是在那拍的，逛了绕着湖边，我们走了半圈就返程了，回到酒店休息了一下，就点了份外卖（毕竟太累就不想出去吃了）然后写了这篇博客。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>今天的的日志也差不多就是这些了，没什么可以在多描述的了，明天再去玩玩新的地方，再去看看风景，OK 收工，睡觉了，在发一张买的东西</p>
<p><img src="/2019/04/05/苏州Vlog（01）/商品.jpg" alt="插图"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven的Web工程中获取相对路径无效</title>
    <url>/2019/03/26/Maven%E7%9A%84Web%E5%B7%A5%E7%A8%8B%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E6%97%A0%E6%95%88/</url>
    <content><![CDATA[<h2 id="Maven的Web工程中-pageContext-request-contextPath-获取相对路径无效"><a href="#Maven的Web工程中-pageContext-request-contextPath-获取相对路径无效" class="headerlink" title="Maven的Web工程中${pageContext.request.contextPath}获取相对路径无效"></a>Maven的Web工程中${pageContext.request.contextPath}获取相对路径无效</h2><blockquote>
<p>开发环境：Maven 3.6.0 || jdk 1.8 || Spring 4 </p>
</blockquote>
<p><img src="/2019/03/26/Maven的Web工程中获取相对路径无效/zahrin-lukman-1449925-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/VSNoQdimlQQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Zahrin Lukman</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h3 id="解决方案一（亲测有效）"><a href="#解决方案一（亲测有效）" class="headerlink" title="解决方案一（亲测有效）"></a>解决方案一（亲测有效）</h3><p>将 web.xml 文件中的 <web-app> 标签的版本修改高一些</web-app></p>
<pre><code>&lt;web-app version=&quot;3.0&quot;
    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt;

&lt;/web-app&gt;

&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt;

&lt;/web-app&gt;
</code></pre><p>原 web.xml</p>
<pre><code>&lt;web-app&gt;&lt;/web-app&gt;
</code></pre><h3 id="方案二（亲测无效且有毒）"><a href="#方案二（亲测无效且有毒）" class="headerlink" title="方案二（亲测无效且有毒）"></a>方案二（亲测无效且有毒）</h3><p>这种方法由于没成功我就不详细介绍了，大概说一下，因为用 maven 创建的 webapp 项目是模板的，这第二种方法直接就是去修改模板了，但是这个模板藏得很深，而且我修改了之后，我的 maven 直接用不了了，导致我直接重装的 maven，重装之后每次在命令行运行 mvn 命令就会报错，目前还无法解决，但还不至于影响我在 IDEA 中开发，说来也怪，在 IDEA 中一点事都没有，但是一旦执行 mvn -V 还是会报错，所以这个方法谨慎使用，最好别用，虽然每次都要改一次 web.xml 文件，但不至于把自己的软件搞坏，如果报错解决了再来更新</p>
<blockquote>
<p>找到为什么出错了，不好意思，命令打错了，是 mvn -version 不是 mvn -V 丢脸丢大发了，但是这个方法任然不可用！！！</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven项目加载不到Mybatis的xml文件报异常的解决方案</title>
    <url>/2019/03/24/Maven%E9%A1%B9%E7%9B%AE%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%88%B0Mybatis%E7%9A%84xml%E6%96%87%E4%BB%B6%E6%8A%A5%E5%BC%82%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="Maven项目加载不到Mybatis的xml文件报异常的解决方案"><a href="#Maven项目加载不到Mybatis的xml文件报异常的解决方案" class="headerlink" title="Maven项目加载不到Mybatis的xml文件报异常的解决方案"></a>Maven项目加载不到Mybatis的xml文件报异常的解决方案</h2><blockquote>
<p>这是第一篇解决开发问题的博客，以后也会按照这种格式来书写，并不断改进（这条仅本条博客存在）  </p>
</blockquote>
<blockquote>
<p>开发环境：Maven 3.6 || jdk 1.8 || Spring 4 （解决方案亲测有效）</p>
</blockquote>
<p><img src="/2019/03/24/Maven项目加载不到Mybatis的xml文件报异常的解决方案/christian-lambert-1452519-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/XR0kq2VDIUo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Christian Lambert</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><pre><code>&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre><p>在 Maven 的 pom.xml 配置文件下添加如上配置代码（用于 Mapper 自动扫描）</p>
<p>原因：</p>
<p>Maven编译项目的时候只会把src/main/java下所有的<em>.java和src/main/resources里的文件编译放入target/classes文件夹，所以位于src/main/java下的xml文件就被忽略了。此时只需要在项目的pom文件中加入resources，把src/main/java下所有的</em>.xml也编译放入target/classes然后启动项目就可以了。</p>
<blockquote>
<p>作者：暗夜黑光<br>链接：<a href="https://www.jianshu.com/p/42725b277611" target="_blank" rel="noopener">https://www.jianshu.com/p/42725b277611</a><br>来源：简书</p>
</blockquote>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>在工程中创建 resource 目录，将 ***Mapper.xml 文件放到该目录下，并在 sqlMapConfig.xml 文件中配置</p>
<pre><code>&lt;mappers&gt;
    &lt;mapper resource=&quot;***Mapper.xml&quot; /&gt;
&lt;/mappers&gt;
</code></pre><p>该方法用于指定 ***Mapper.xml 文件</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>开发问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer（二）</title>
    <url>/2019/03/10/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="面试题目录"><a href="#面试题目录" class="headerlink" title="面试题目录"></a>面试题目录</h2><ul>
<li>找出数组中重复的数字</li>
<li>不修改数组找出重复的数字</li>
</ul>
<p><img src="/2019/03/10/剑指Offer（二）/roberto-nickson-1424153-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/b1ovoL_F1S8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Roberto Nickson</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h3 id="找出数组中重复的数字-P39"><a href="#找出数组中重复的数字-P39" class="headerlink" title="找出数组中重复的数字(P39)"></a>找出数组中重复的数字(P39)</h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>在一个长度为 n 的数组里的所有数字都在 0~n-1 的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次，请找出数组中任意一个重复的数字。例如，如果输入长度为7，的数组 {2, 3, 1, 0, 2, 5, 3} ，那么对应的输出是重复的数字2和或者3。</p>
</blockquote>
<p><strong><em>解题思路</em></strong></p>
<blockquote>
<p>从头到位依次扫描这个数字中的每个数字，当扫描到下标为 i 的数字时，首先比较这个数字（用 m 表示）是不是等于 i，如果是，则接着扫描下一个数字；如果不是，则再拿它和第 m 个数字进行比较。如果它和第 m 个数字相等，就找到了一个重复的数字（该数字在下标为 i 和 m 的位置都出现了）；如果它和第 m 个数字不相等，就把第 i 个数字和第 m 个数字交换，把 m 个数字交换，把 m 放到属于它的位置。接下来，再重复比较、交换的过程，知道发现一个重复的数字。</p>
</blockquote>
<p><strong><em>代码</em></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3_1</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> boolean <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 &lt; <span class="number">0</span> || i1 &gt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == arr[arr[i]]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[temp];</span><br><span class="line">                arr[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(duplicate(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不修改数组找出重复的数字-P41"><a href="#不修改数组找出重复的数字-P41" class="headerlink" title="不修改数组找出重复的数字(P41)"></a>不修改数组找出重复的数字(P41)</h3><p><strong><em>题目</em></strong></p>
<blockquote>
<p>在一个长度为 n+1 的数组里的所有数字都在 1~n 的范围内，所以数组中至少有一个数字是重复的，请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为 8 的数组 {2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3</p>
</blockquote>
<p><strong><em>解题思路</em></strong></p>
<blockquote>
<p>把从 1~n 的数字从中间的数字m分为两部分，前面一半为 1~m，后面一半为 m+1~n。如果 1~m 的数字的数目超过 m，那么这一班的区间里一定包含重复的数字；否则，另一半 m+1~n 的区间里一定包含重复的数字。</p>
</blockquote>
<p><strong><em>代码</em></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3_2</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &gt;= start) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">            <span class="keyword">int</span> count = countRange(arr, start, middle);</span><br><span class="line">            <span class="keyword">if</span> (end == start) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> start;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; (middle - start + <span class="number">1</span>)) &#123;</span><br><span class="line">                end = middle;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= start &amp;&amp; i &lt;= end) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        System.out.println(getDuplication(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：该方法无法找到全部重复数字，总时间复杂度为O(nlogn)，空间复杂度为O(1)</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer（一）</title>
    <url>/2019/03/09/%E5%89%91%E6%8C%87Offer%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="知识点目录"><a href="#知识点目录" class="headerlink" title="知识点目录"></a>知识点目录</h2><ul>
<li>赋值运算符</li>
<li>C++ 中的 struct 和 class 的区别</li>
</ul>
<p><img src="/2019/03/09/剑指Offer（一）/ernest-ojeh-1422985-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>摄影：<a href="https://unsplash.com/photos/wJ10sn0mNrM?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Ernest Ojeh</a>，来自<a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h3 id="赋值运算符-P25"><a href="#赋值运算符-P25" class="headerlink" title="赋值运算符(P25)"></a>赋值运算符(P25)</h3><p>有以下类型CMyString的声明，添加赋值运算符函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CMyString(<span class="keyword">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">        CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">        ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>考点</em></strong></p>
<ul>
<li>是否发返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用（*this)</li>
<li>是否把传入的参数声明为常量引用</li>
<li>是否释放实例自身已有的内存</li>
<li>判断传入的参数和当前的实例（*this）是不是同一个实例</li>
</ul>
<p><strong>经典解法 - 初级程序员</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString &amp;str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>考虑异常安全性的解法 - 高级程序员</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString &amp;str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line">        CMyString strTemp(str);             <span class="comment">// 创建一个临时实例</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 以下三行是将临时实例与自身实例进行交换</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">char</span>* pTemp = strTemp.m_pData;</span><br><span class="line">        strTemp.m_pData = m_pData;</span><br><span class="line">        m_pData = pTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到该作用域外后，临时实例将会调用析构函数，销毁内存</span></span><br><span class="line">    <span class="comment">// 因为临时实例交换后就是之前的实例自身，析构后便可以达到销毁原实例内存的目的</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>源码<a href="https://github.com/zhedahht/CodingInterviewChinese2/tree/master/01_AssignmentOperator" target="_blank" rel="noopener">地址</a></p>
</blockquote>
<h3 id="C-中的-struct-和-class-的区别"><a href="#C-中的-struct-和-class-的区别" class="headerlink" title="C++ 中的 struct 和 class 的区别"></a>C++ 中的 struct 和 class 的区别</h3><ul>
<li>如果没有标明成员函数或者变量的访问权限级别，在 struct 中默认的是 public，而在class中默认的是private</li>
<li>struct 定义的是值类型，值类型的实例在栈上分配内存；而 class 定义的是引用类型，引用类型的实例在堆上分配内存</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程知识点（第三篇）</title>
    <url>/2019/03/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h2 id="知识点目录"><a href="#知识点目录" class="headerlink" title="知识点目录"></a>知识点目录</h2><ul>
<li>什么是并发容器的实现？</li>
<li>多线程同步和互斥实现方法</li>
<li>什么是竞争条件</li>
<li>为什么调用 start() 方法时会执行 run() 方法，为什么不直接调用 run() 方法</li>
<li>Java 中怎样唤醒一个阻塞地线程</li>
<li>CycliBarriar 和 CountdownLatch 有什么区别？</li>
<li>什么是不可变对象，它对写并发应用有什么帮助？</li>
</ul>
<p><img src="/2019/03/06/Java多线程知识点（第三篇）/hello-i-m-nik-1399233-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>图片来自第三方 <a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h3 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h3><p>何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如 Vector、Hashtable、Collections.synchronizedSet、synchronizedList 等方法返回的容器。</p>
<p>可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字synchronized。</p>
<p>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。</p>
<h3 id="多线程同步和互斥实现方法"><a href="#多线程同步和互斥实现方法" class="headerlink" title="多线程同步和互斥实现方法"></a>多线程同步和互斥实现方法</h3><p>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p>
<p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p>
<p>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p>
<p>用户模式下的方法有：原子操作、临界区。内核模式下的方法有：事件、信号量、互斥量。</p>
<h3 id="什么是竞争条件"><a href="#什么是竞争条件" class="headerlink" title="什么是竞争条件"></a>什么是竞争条件</h3><p>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件。</p>
<h3 id="为什么调用-start-方法时会执行-run-方法，为什么不直接调用-run-方法"><a href="#为什么调用-start-方法时会执行-run-方法，为什么不直接调用-run-方法" class="headerlink" title="为什么调用 start() 方法时会执行 run() 方法，为什么不直接调用 run() 方法"></a>为什么调用 start() 方法时会执行 run() 方法，为什么不直接调用 run() 方法</h3><p>当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。</p>
<p>但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。</p>
<h3 id="Java-中怎样唤醒一个阻塞地线程"><a href="#Java-中怎样唤醒一个阻塞地线程" class="headerlink" title="Java 中怎样唤醒一个阻塞地线程"></a>Java 中怎样唤醒一个阻塞地线程</h3><p>在 Java 发展史上曾经使用 suspend()、resume() 方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。</p>
<p>解决方案可以使用以对象为目标的阻塞，即利用 Object 类的 wait() 和 notify() 方法实现线程阻塞。</p>
<p>首先，wait、notify 方法是针对对象的，调用任意对象的 wait() 方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify() 方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行；其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</p>
<h3 id="CycliBarriar-和-CountdownLatch-有什么区别？"><a href="#CycliBarriar-和-CountdownLatch-有什么区别？" class="headerlink" title="CycliBarriar 和 CountdownLatch 有什么区别？"></a>CycliBarriar 和 CountdownLatch 有什么区别？</h3><p>CyclicBarrier 可以重复使用，而CountdownLatch不能重复使用。</p>
<p>Java 的 concurrent 包里面的 CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。</p>
<p>你可以向 CountDownLatch 对象设置一个初始的数字作为计数值，任何调用这个对象上的 await() 方法都会阻塞，直到这个计数器的计数值被其他的线程减为0为止。</p>
<p>所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。</p>
<p>CountDownLatch 的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个 CountDownLatch 对象的 await ()方法，其他的任务执行完自己的任务后调用同一个 CountDownLatch 对象上的 countDown() 方法，这个调用 await() 方法的任务将一直阻塞等待，直到这个 CountDownLatch 对象的计数值减到0为止</p>
<p>CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。</p>
<h3 id="什么是不可变对象，它对写并发应用有什么帮助？"><a href="#什么是不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="什么是不可变对象，它对写并发应用有什么帮助？"></a>什么是不可变对象，它对写并发应用有什么帮助？</h3><p>不可变对象即对象一旦被创建它的状态就不能改变，反之即为可变对象。 不可变对象的类即为不可变类。Java 平台类库中包含许多不可变类，如 String、基本类型的包装类、BigInteger 和 BigDecimal 等。</p>
<p>不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。</p>
<p>不可变对象永远是线程安全的。</p>
<p>只有满足如下状态，一个对象才是不可变的；</p>
<p>它的状态不能在创建后再被修改；</p>
<p>所有域都是 final 类型；并且，</p>
<p>它被正确创建（创建期间没有发生this引用的逸出）。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程知识点（第二篇）</title>
    <url>/2019/03/04/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h2 id="知识点目录"><a href="#知识点目录" class="headerlink" title="知识点目录"></a>知识点目录</h2><ul>
<li>在 Java 中 Executor 和 Executors 的区别</li>
<li>原子操作</li>
<li>Java Concurrency API 中的 Lock 接口是什么？对比同步有什么优势？</li>
<li>Executors 框架</li>
<li>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者 - 消费者模型？</li>
<li>什么是 Callable 和 Future ？</li>
<li>什么是 FutureTask ？</li>
</ul>
<p><img src="/2019/03/04/Java多线程知识点（第二篇）/nicole-honeywill-1406229-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>图片来自第三方 <a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h3 id="在-Java-中-Executor-和-Executors-的区别"><a href="#在-Java-中-Executor-和-Executors-的区别" class="headerlink" title="在 Java 中 Executor 和 Executors 的区别"></a>在 Java 中 Executor 和 Executors 的区别</h3><ul>
<li>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求  </li>
<li>Executor 接口对象能执行我们的线程任务  </li>
<li>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法，能获得任务的执行状态并且可以获取任务的返回值  </li>
<li>使用 ThreadPoolExecutor 可以穿件自定义线程池</li>
<li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果</li>
</ul>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。  </p>
<p>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作  </p>
<p>在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。CAS 操作 —— Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的CPU指令都支持 CAS 的原子操作  </p>
<p>int++ 并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误  </p>
<p>为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5之后，java.util.concurrent.automic 包提供了int和long类型的原子包装类，它们可以自动的保证对于它们的操作是原子的并且不需要使用同步  </p>
<p>java.util.concurrent 这个包里面提供了一组原子类。其基本方法的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令的时候，不会被其他线程打断，而别的线程就像自旋锁一样，一致等到该方法执行完成，才由 JVM 从等待队列中选择一个线程进入。</p>
<h3 id="Java-Concurrency-API-中的-Lock-接口是什么？对比同步有什么优势？"><a href="#Java-Concurrency-API-中的-Lock-接口是什么？对比同步有什么优势？" class="headerlink" title="Java Concurrency API 中的 Lock 接口是什么？对比同步有什么优势？"></a>Java Concurrency API 中的 Lock 接口是什么？对比同步有什么优势？</h3><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作  </p>
<p>他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关的条件对象  </p>
<p>优势有：  </p>
<ul>
<li>可以使锁更公平</li>
<li>可以使线程在等待锁的时候响应中断</li>
<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li>
<li>可以在不同的范围，以不同的顺序获取和释放锁</li>
</ul>
<p>整体上来说，Lock 是 synchronize 的扩展版，Lock提供了无条件的，可轮询的，定时的，可中断的，可多条件队列的锁操作。另外 Lock 的实现类都基本支持非公平锁和公平锁，synchronize 只支持非公平锁，但大部分情况下，非公平锁是高效的选择</p>
<h3 id="Executors-框架"><a href="#Executors-框架" class="headerlink" title="Executors 框架"></a>Executors 框架</h3><p>Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架  </p>
<p>无限制的创建线程或引起应用程序内存溢出。所以创建一个线程池是个更好的解决方案，因为可以限制线程的数量，并且可以回收再利用这些线程。利用 Executors 开那个价可以非常方便的创建一个线程池</p>
<h3 id="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者 - 消费者模型？"></a>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者 - 消费者模型？</h3><p>阻塞队列是一个支持两个附加操作的队列。在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿出元素</p>
<p>JDK7 提供了7个阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的游街阻塞队列</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li>
</ul>
<p>Java5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要技术就是用 wait，notify，notifyAll，synchronized 这些关键字。在 Java5 之后，可以使用阻塞队列来实现，此方式大大减少了代码量，是的多线程编程更加容易，安全方面也有保障。</p>
<p>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的工具，因此他具有一个很明显的特征，当生产者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为他所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，他可以很好的控制线程之间的通信</p>
<p>阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程，不断从队列取数据解析</p>
<h3 id="什么是-Callable-和-Future-？"><a href="#什么是-Callable-和-Future-？" class="headerlink" title="什么是 Callable 和 Future ？"></a>什么是 Callable 和 Future ？</h3><p>Callable 接口类似于 Runnable，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说 Future 可以拿到异步执行任务的返回值</p>
<p>可以认为是带有回调的 Runnable</p>
<p>Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以所 Callable 用于产生结果，Future 用于获取结果</p>
<h3 id="什么是-FutureTask-？"><a href="#什么是-FutureTask-？" class="headerlink" title="什么是 FutureTask ？"></a>什么是 FutureTask ？</h3><p>在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。他有启动和取消运算、查询运算是否完成和取回运算结果等方法</p>
<p>只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnabel 接口，所以它可以提交给 Executor 来执行</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程知识点（第一篇）</title>
    <url>/2019/03/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h2 id="知识点目录"><a href="#知识点目录" class="headerlink" title="知识点目录"></a>知识点目录</h2><ul>
<li>在java中守护线程和本地线程的区别</li>
<li>线程与进程的区别</li>
<li>多线程的上下文切换</li>
<li>死锁与活锁的区别，死锁与饥饿的区别</li>
<li>Java中用到的线程调度算法</li>
<li>什么是线程组，为什么在Java中不推荐使用</li>
<li>为什么使用Executor框架</li>
</ul>
<p><img src="/2019/03/03/Java多线程知识点（第一篇）/juan-gomez-1406168-unsplash.jpg" alt="插图"></p>
<blockquote>
<p>图片来自第三方 <a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a></p>
</blockquote>
<a id="more"></a>
<h3 id="在java中守护线程和本地线程的区别"><a href="#在java中守护线程和本地线程的区别" class="headerlink" title="在java中守护线程和本地线程的区别"></a>在java中守护线程和本地线程的区别</h3><p>java中的线程分为两种：守护线程（Daemon）和用户线程（User）</p>
<p>任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(boolean)；true则把该线程设置为守护线程，反之则为用户抛出异常。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常</p>
<p>两者的区别：<br>虚拟机（JVM）何时离开，Daemon是为其他线程提供服务，如果全部的UserThread已经撤离，Daemon没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程，守护线程就没有工作继续执行，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开</p>
<p>扩展：Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows下的监听Ctrl+break的守护进程、Finalizer守护进程、引用处理守护进程、GC守护进程</p>
<h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。<br>一个程序至少有一个进程，一个进程至少有一个线程</p>
<h3 id="多线程的上下文切换"><a href="#多线程的上下文切换" class="headerlink" title="多线程的上下文切换"></a>多线程的上下文切换</h3><p>多线程会共同使用一组计算机的CPU，二线程数大于给程序分配的CPU数是，为了让各个线程都有执行的机会，就需要轮转使用CPU。<br>不同的线程切换使用CPU发生的切换数据等就是上下文切换</p>
<h3 id="死锁与活锁的区别，死锁与饥饿的区别"><a href="#死锁与活锁的区别，死锁与饥饿的区别" class="headerlink" title="死锁与活锁的区别，死锁与饥饿的区别"></a>死锁与活锁的区别，死锁与饥饿的区别</h3><p><strong>死锁</strong>：是指两个或两个以上的进程（或线程）在指定过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去</p>
<p><strong>产生死锁的必要条件</strong>：</p>
<ul>
<li>互斥条件：所谓互斥就是进程在某一时间内独占资源</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程已获得资源，在未使用完之前不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ul>
<p><strong>活锁</strong>：任务或执行者没有阻塞，由于某些条件没有满足，导致一直重复尝试、失败、尝试、失败</p>
<p><strong>活锁和死锁的区别</strong>：处于活锁的实体是在不断的改变状态，所谓的“活”，而处于是死锁的实体表现为等待，活锁可能自己解开，死锁不能</p>
<p><strong>饥饿</strong>：一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态</p>
<p><strong>Java中导致饥饿的原因</strong>：</p>
<ul>
<li>高优先级线程吞噬所有低优先级线程的资源</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在他之前持续对该同步块进行访问</li>
<li>线程在等待一个本身也处于永久等待完成的对象（比如调用这个对象的wait方法），因为其他线程总是被持续地获得唤醒</li>
</ul>
<h3 id="Java中用到的线程调度算法"><a href="#Java中用到的线程调度算法" class="headerlink" title="Java中用到的线程调度算法"></a>Java中用到的线程调度算法</h3><p>采用时间片轮转的方式，可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿</p>
<h3 id="什么是线程组，为什么在Java中不推荐使用"><a href="#什么是线程组，为什么在Java中不推荐使用" class="headerlink" title="什么是线程组，为什么在Java中不推荐使用"></a>什么是线程组，为什么在Java中不推荐使用</h3><p>ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构类似于树，有安全隐患，推荐使用线程池</p>
<h3 id="为什么使用Executor框架"><a href="#为什么使用Executor框架" class="headerlink" title="为什么使用Executor框架"></a>为什么使用Executor框架</h3><p>每次执行任务创建线程 new Thread() 比较消耗性能，创建一个线程是比较耗时的、耗资源的</p>
<p>调用 new Thread() 创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的互相竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源</p>
<p>直接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>白蛇缘起影评</title>
    <url>/2019/02/14/%E7%99%BD%E8%9B%87%E7%BC%98%E8%B5%B7%E5%BD%B1%E8%AF%84/</url>
    <content><![CDATA[<p>这篇影评是我再三斟酌后决定发出来，只是为了表达我对于这部国漫单纯的喜爱，它并没有那么不堪<br>（本文没有大篇幅去评价剧情，画面，台词等等，只是想表达一名该电影粉丝的想法）</p>
<p><img src="/2019/02/14/白蛇缘起影评/缘起.jpg" alt="白蛇缘起"></p>
<a id="more"></a>
<p>先来说说看我这篇文章的三种人群，一类是《白蛇：缘起》这部动漫的粉丝，一类是《白蛇：缘起》的喷子，一类是持有保留意见的路人，我并不会去针对某一类人群说一些有失偏颇的话，这样做既没有意义，也违背了我这篇文章的初衷，但我之所以分开这三类人群，旨在希望各位能认真看完文章，它适合所有人</p>
<p>在农历新年之前，有两部电影都被我自己誉为我自己的打脸真香电影，一部是《海王》，另一部就是本文主题《白蛇：缘起》，在电影上映前，我都没抱着多大的期望值，但是观影后心中默认两字“牛逼”，对于看过不少科幻电影的我来说，《海王》是完全超乎我预料之外的好，很大程度归功于它的导演——温子仁，好了，回到我们的话题，相对于动漫，我看的就比较少了，日本动漫就看过《火影忍者》和《名侦探柯南》后者甚至只看过剧场版，而国漫相对多一些，比如《秦时明月》，画江湖系列的《侠岚》《风语咒》《灵主》《不良人》《换世门生》，还有《镇魂街》，有些估计也看过，想不起来了，虽然看过国漫，也挺喜欢，但一直处于喜欢的程度，并没有到达热爱，甚至成为自来水向身边的人疯狂安利，我看了四次《缘起》，每次看我都想不明白为什么我还愿意走进电影院再次观看，一点不觉得腻歪，知道最近我才觉得我找到了答案</p>
<p>在说答案之前，我想说说能让我四次走进电影院的一些原因，对于一场电影，看一遍基本就满足了，二刷就已经是热爱了，刷以上难免会觉得有点过分，甚至会让别人觉得看这么多次难道不觉的腻？我不是一个专业的影评人，没有丰富的词汇去描绘评论整个电影的剧情，但是作为一名观影者，我觉得我还是可以说一说自己的感受。《缘起》全程剧情十分紧凑，对于我来说，一个电影个情节衔接得好不好，可以用在你看电影时，有没有产生右划快进的欲望来恒定，这部电影完全没有，恐怕也正因为这个原因，在几次观影下来我发现了电影中很多地方剧情节奏太快不太符合逻辑。可是，整部电影的逻辑没有问题，四次《何须问》都让我身临其境，四次小白拉许宣魂魄都能触动到我，同样的剧情，能触动我四次的恐怕目前就只有《缘起》了。</p>
<p><img src="/2019/02/14/白蛇缘起影评/何须问.jpg" alt="白蛇缘起"></p>
<p><img src="/2019/02/14/白蛇缘起影评/破阵.jpg" alt="白蛇缘起"></p>
<p>但是仅仅只剧情触动的话，那我为我四刷的行为感到不值和奇怪了，接下来，我要说的仅仅代表我个人的观点：在我看来，无论是电影，电视剧，书，或者以任何媒介传播到我大脑里的信息都是可以分类的，但所有类别中有一类，是我认为最最重要的，很多人称之为情怀，我也认，但往往就是情怀能触碰到我内心深处最纯洁，单纯的向往，有同学跟我说过，现在社会变化太快了，有些东西已将变得不一样了，要试图适应，去改变自己。这句话没错，可是，任然有些东西在我心中，我愿意为它留下一方净土，希望在这净土上，能结出我期望的果实，在我没有找到合适的种子，我愿意继续守护它，我有过动摇，有过反思，我不能说这电影带给我什么珍贵的东西，可是剧情中许宣和小白的那种奋不顾身的爱情，的的确确触碰了我心中的这方净土，触及到了我自己对爱情的向往，就算这种爱情不存在，我也愿意相信它。可能会有人说我幼稚，什么都没经历，谈何如此这般，那我反问一句，你何尝没有为自己心中放弃的那一方净土感到后悔，惋惜，悲哀吗？人之初，我们本有着一片纯净的天地，逐渐成长，我们总是在用“无奈”来掩盖自己的妥协，用“放弃”掩盖自己的无能，用“现实”掩盖自己的退缩，这一片天地最终就留下了那一方可怜的土地，能不令人痛心。如果连最后这一点可怜的净土都没了，那我们还能找到自己最初所盼望的东西吗？我不想把“情怀”二字说的如何高大上，但至少，这玩意儿，能在你失落的时候给你一丝安慰，哪怕只有一丝光亮，你也会奋不顾身的往前跑，它不会为你指明任何方向，但是，至少在你行走的过程中，让你保持幸福感。</p>
<p>以上仅仅是我个人的观点，也是自己想了很久总结的话，所以在文章开头说了再三斟酌，并没想针对任何人，我仅仅想表达我为何爱这部电影之深，我也没有要故意抬杠捧高《缘起》的价值观，因为最终它只是一部电影，只是一个商业产物，一千个读者就有一千个哈姆雷特，我仅仅只是那千分之一，所以我尊重任何人的意见，就算是故意甚至恶意诋毁的人，我也愿意接纳，至少你们也是那“一千”中的一个。</p>
<p>全篇文章不长，恐怕还有些许矫情，看电影是我这个程序员业余最大的爱好之一了，我会愿意为自己喜欢的电影打call，好的电影我也会认认真真欣赏，如果有必要，我仍然会写成博客与诸位分享。</p>
]]></content>
      <categories>
        <category>观剧后感</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
</search>
